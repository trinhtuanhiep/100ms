import { HMSPeer, HMSScreenVideoTrack, HMSTrack, HMSTrackID, HMSVideoTrack } from '@100mslive/hms-video-store';
export declare const chunk: <T>(elements: T[], chunkSize: number, onlyOnePage: boolean) => T[][];
interface ChunkElements<T> {
    elements: T[];
    tilesInFirstPage: number;
    onlyOnePage: boolean;
    isLastPageDifferentFromFirstPage: boolean;
    defaultWidth: number;
    defaultHeight: number;
    lastPageWidth: number;
    lastPageHeight: number;
}
/**
 * Given a list of tracks/elements and some constraints, group the tracks in separate pages.
 * @return 2D list for every page which has the original element and height and width
 * for its tile.
 */
export declare const chunkElements: <T>({ elements, tilesInFirstPage, onlyOnePage, isLastPageDifferentFromFirstPage, defaultWidth, defaultHeight, lastPageWidth, lastPageHeight, }: ChunkElements<T>) => (T & {
    width: number;
    height: number;
})[][];
/**
 * Mathematical mode - the element with the highest occurrence in an array
 * @param array
 */
export declare function mode(array: number[]): number | null;
export declare type TrackWithPeer = {
    track?: HMSVideoTrack | HMSScreenVideoTrack;
    peer: HMSPeer;
};
export declare type TrackWithPeerAndDimensions = {
    track?: HMSVideoTrack | HMSScreenVideoTrack;
    peer: HMSPeer;
    width?: number;
    height?: number;
};
/**
 * get the aspect ration occurring with the highest frequency
 * @param tracks - video tracks to infer aspect ratios from
 */
export declare const getModeAspectRatio: (tracks: TrackWithPeer[]) => number | null;
interface GetTileSizesInList {
    count: number;
    parentWidth: number;
    parentHeight: number;
    maxTileCount?: number;
    maxRowCount?: number;
    maxColCount?: number;
    aspectRatio: {
        width: number;
        height: number;
    };
}
interface GetTileSizes {
    parentWidth: number;
    parentHeight: number;
    count: number;
    maxCount: number;
    aspectRatio: {
        width: number;
        height: number;
    };
}
/**
 * Finds the largest rectangle area when trying to place N rectangle into a containing
 * rectangle without rotation.
 *
 * @param {Number}  containerWidth      The width of the container.
 * @param {Number}  containerHeight     The height of the container.
 * @param {Number}  numRects            How many rectangles must fit within.
 * @param {Number}  width               The unscaled width of the rectangles to be placed.
 * @param {Number}  height              The unscaled height of the rectangles to be placed.
 * @return {Object}                     The area and number of rows and columns that fit.
 */
export declare const largestRect: (containerWidth: number, containerHeight: number, numRects: number, width: number | undefined, height: number | undefined) => {
    area: number;
    cols: number;
    rows: number;
    width: number;
    height: number;
};
export declare const getTileSizesWithColConstraint: ({ parentWidth, parentHeight, count, maxCount, aspectRatio, }: GetTileSizes) => {
    tilesInFirstPage: number;
    defaultWidth: number;
    defaultHeight: number;
    lastPageWidth: number;
    lastPageHeight: number;
    isLastPageDifferentFromFirstPage: boolean;
};
export declare const getTileSizesWithPageConstraint: ({ parentWidth, parentHeight, count, maxCount, aspectRatio, }: GetTileSizes) => {
    tilesInFirstPage: number;
    defaultWidth: number;
    defaultHeight: number;
    lastPageWidth: number;
    lastPageHeight: number;
    isLastPageDifferentFromFirstPage: boolean;
};
export declare const getTileSizesWithRowConstraint: ({ parentWidth, parentHeight, count, maxCount, aspectRatio, }: GetTileSizes) => {
    tilesInFirstPage: number;
    defaultWidth: number;
    defaultHeight: number;
    lastPageWidth: number;
    lastPageHeight: number;
    isLastPageDifferentFromFirstPage: boolean;
};
export declare function calculateLayoutSizes({ count, parentWidth, parentHeight, maxTileCount, maxRowCount, maxColCount, aspectRatio, }: GetTileSizesInList): {
    tilesInFirstPage: number;
    defaultWidth: number;
    defaultHeight: number;
    lastPageWidth: number;
    lastPageHeight: number;
    isLastPageDifferentFromFirstPage: boolean;
};
/**
 * given list of peers and all tracks in the room, get a list of tile objects to show in the UI
 * @param peers
 * @param tracks
 * @param includeScreenShareForPeer - fn will be called to check whether to include screenShare for the peer in returned tiles
 * @param filterNonPublishingPeers - by default a peer with no tracks won't be counted towards final tiles
 */
export declare const getVideoTracksFromPeers: (peers: HMSPeer[], tracks: Record<HMSTrackID, HMSTrack>, includeScreenShareForPeer: (peer: HMSPeer) => boolean, filterNonPublishingPeers?: boolean) => TrackWithPeer[];
export {};
