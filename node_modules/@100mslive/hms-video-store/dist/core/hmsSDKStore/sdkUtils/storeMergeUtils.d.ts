import { HMSLocalTrack as SDKHMSLocalTrack, HMSPoll } from '@100mslive/hms-video';
import { HMSPeer, HMSPeerID, HMSTrack, HMSTrackID } from '../../schema';
import { HMSPeerStats, HMSTrackStats } from '../sdkTypes';
/**
 * updates draftPeers with newPeers ensuring minimal reference changes
 * @remarks
 * This is mutable and impure function, it modifies the passed in data to ensure
 * minimal reference changes
 * @param draftPeers the current peers object in store, an immer draft object
 * @param newPeers the latest update which needs to be stored
 * @param newHmsTracks this will be update if required
 * @param newHmsSDkTracks this is future value of local hms tacks map
 */
export declare const mergeNewPeersInDraft: (draftPeers: Record<HMSPeerID, HMSPeer>, newPeers: Record<HMSPeerID, Partial<HMSPeer>>) => void;
export declare const mergeNewTracksInDraft: (draftTracks: Record<HMSTrackID, HMSTrack>, newTracks: Record<HMSTrackID, Partial<HMSTrack>>) => void;
export declare const mergeNewPollsInDraft: (draftPolls: Record<string, HMSPoll>, newPolls: Record<string, Partial<HMSPoll>>) => void;
export declare const mergeNewIndividualStatsInDraft: <TID extends string, T extends HMSTrackStats | HMSPeerStats>(draftStats: Record<TID, T | undefined>, newStats: Record<TID, Partial<T | undefined>>) => void;
export declare const mergeLocalTrackStats: (draftStats: Record<HMSTrackID, HMSTrackStats[] | undefined>, newStats: Record<HMSTrackID, Record<string, HMSTrackStats>>, tracks: SDKHMSLocalTrack[]) => void;
/**
 * array's are usually created with new reference, avoid that update if both arrays are same
 */
export declare const mergeTrackArrayFields: (oldTrack: HMSTrack, newTrack: Partial<HMSTrack>) => void;
export declare const isEntityUpdated: <T>(oldItem: T, newItem: T) => T;
export declare const areArraysEqual: <T>(arr1: T[], arr2?: T[] | undefined) => boolean;
