import { State } from 'zustand/vanilla';
import { HMSNotifications } from './HMSNotifications';
import { IHMSActions } from '../IHMSActions';
import { IHMSStatsStoreReadOnly, IHMSStore, IHMSStoreReadOnly, IStore } from '../IHMSStore';
import { HMSGenericTypes } from '../schema';
import { IHMSNotifications } from '../schema/notification';
declare global {
    interface Window {
        __hms: HMSReactiveStore;
        __triggerBeamEvent__: (args: any) => void;
    }
}
export declare class HMSReactiveStore<T extends HMSGenericTypes = {
    sessionStore: Record<string, any>;
}> {
    private readonly sdk?;
    private readonly actions;
    private readonly store;
    private readonly notifications;
    private stats?;
    /** @TODO store flag for both HMSStore and HMSInternalsStore */
    private initialTriggerOnSubscribe;
    constructor(hmsStore?: IHMSStore<T>, hmsActions?: IHMSActions<T>, hmsNotifications?: HMSNotifications<T>);
    /**
     * By default store.subscribe does not call the handler with the current state at time of subscription,
     * this behaviour can be modified by calling this function. What it means is that instead of calling the
     * handler only for changes which happen post subscription we'll also call it exactly once at the time
     * of subscription with the current state. This behaviour is similar to that of BehaviourSubject in rxjs.
     * This will be an irreversible change
     *
     * Note: you don't need this if you're using our react hooks, it takes care of this requirement.
     */
    triggerOnSubscribe(): void;
    /**
     * A reactive store which has a subscribe method you can use in combination with selectors
     * to subscribe to a subset of the store. The store serves as a single source of truth for
     * all data related to the corresponding HMS Room.
     */
    getStore(): IHMSStoreReadOnly;
    /**
     * Any action which may modify the store or may need to talk to the SDK will happen
     * through the IHMSActions instance returned by this
     *
     * @deprecated use getActions
     */
    getHMSActions(): IHMSActions<T>;
    /**
     * Any action which may modify the store or may need to talk to the SDK will happen
     * through the IHMSActions instance returned by this
     */
    getActions(): IHMSActions<T>;
    /**
     * This return notification handler function to which you can pass your callback to
     * receive notifications like peer joined, peer left, etc. to show in your UI or use
     * for analytics
     */
    getNotifications(): IHMSNotifications;
    /**
     * @alpha
     */
    getStats: () => IHMSStatsStoreReadOnly;
    /**
     * @internal
     */
    static createNewHMSStore<T extends State>(storeName: string, defaultCreatorFn: () => T): IStore<T>;
    /**
     * @internal
     */
    static makeStoreTriggerOnSubscribe<T extends State>(store: IStore<T>): void;
    /**
     * use shallow equality check by default for subscribe to optimize for array/object selectors.
     * by default zustand does only reference matching so something like, getPeers for eg. would trigger
     * the corresponding component even if peers didn't actually change, as selectPeers creates a new array every time.
     * Although the array reference changes, the order of peers and peer objects don't themselves change in this case,
     * and a shallow check avoids that triggering.
     * @private
     */
    private static compareWithShallowCheckInSubscribe;
    /**
     * @private
     * @privateRemarks
     * sets up redux devtools for the store, so redux extension can be used to visualize the store.
     * zustand's default devtool middleware only enhances the set function, we're here creating another nameSetState in
     * IHMStore which behaves like setState but takes an extra parameter for action name
     * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Methods.md
     * modified version of zustand's devtools - https://github.com/pmndrs/zustand/blob/v3.5.7/src/middleware.ts#L46
     */
    private static setUpDevtools;
    /**
     * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md
     */
    private static devtoolsOptions;
    /**
     * redux devtools allows for time travel debugging where it sends an action to update the store, users can
     * also export and import state in the devtools, listen to the corresponding functions from devtools and take
     * required action.
     * @param devtools - reference to devtools extension object
     * @param api
     * @param savedSetState - setState saved before its modified to update devtools
     * @private
     */
    private static devtoolsSubscribe;
}
