{
  "version": 3,
  "sources": ["../package.json", "../src/index.ts", "../src/sdk/models/HMSMessage.ts", "../src/sdk/models/HMSRoom.ts", "../src/utils/constants.ts", "../src/sdk/models/peer/HMSPeer.ts", "../src/utils/id-factory.ts", "../src/sdk/models/peer/HMSLocalPeer.ts", "../src/sdk/models/peer/HMSRemotePeer.ts", "../src/sdk/LocalTrackManager.ts", "../src/analytics/AnalyticsEvent.ts", "../src/utils/support.ts", "../src/analytics/domain-analytics.ts", "../src/utils/analytics-deviceId.ts", "../src/utils/local-storage-polyfill.ts", "../src/utils/local-storage.ts", "../src/utils/logger.ts", "../src/error/ErrorCodes.ts", "../src/error/HMSException.ts", "../src/signal/jsonrpc/models.ts", "../src/error/ErrorFactory.ts", "../src/utils/validations.ts", "../src/utils/user-agent.ts", "../src/analytics/AnalyticsEventFactory.ts", "../src/analytics/AnalyticsTimer.ts", "../src/error/utils.ts", "../src/internal.ts", "../src/media/streams/HMSMediaStream.ts", "../src/utils/json.ts", "../src/media/tracks/HMSTrack.ts", "../src/media/tracks/HMSTrackType.ts", "../src/media/tracks/HMSAudioTrack.ts", "../src/device-manager/DeviceStorage.ts", "../src/plugins/audio/HMSAudioPlugin.ts", "../src/analytics/MediaPluginsAnalyticsFactory.ts", "../src/plugins/audio/AudioPluginsAnalytics.ts", "../src/plugins/audio/HMSAudioPluginsManager.ts", "../src/utils/track.ts", "../src/utils/media.ts", "../src/utils/queue.ts", "../src/utils/timer-utils.ts", "../src/utils/track-audio-level-monitor.ts", "../src/interfaces/update-listener.ts", "../src/interfaces/simulcast-layers.ts", "../src/interfaces/track-settings.ts", "../src/interfaces/devices.ts", "../src/interfaces/playlist.ts", "../src/interfaces/session-store/polls.ts", "../src/media/settings/HMSAudioTrackSettings.ts", "../src/media/settings/HMSVideoTrackSettings.ts", "../src/media/settings/HMSTrackSettings.ts", "../src/media/tracks/HMSLocalAudioTrack.ts", "../src/media/tracks/HMSRemoteAudioTrack.ts", "../src/media/tracks/HMSVideoTrack.ts", "../src/media/tracks/VideoElementManager.ts", "../src/media/tracks/trackUtils.ts", "../src/utils/intersection-observer.ts", "../src/utils/resize-observer.ts", "../src/plugins/video/HMSVideoPlugin.ts", "../src/utils/math.ts", "../src/plugins/video/VideoPluginsAnalytics.ts", "../src/plugins/video/HMSVideoPluginsManager.ts", "../src/media/tracks/HMSLocalVideoTrack.ts", "../src/media/tracks/HMSRemoteVideoTrack.ts", "../src/media/streams/HMSLocalStream.ts", "../src/media/streams/HMSRemoteStream.ts", "../src/utils/device-error.ts", "../src/rtc-stats/utils.ts", "../src/rtc-stats/HMSWebrtcStats.ts", "../src/rtc-stats/HMSWebrtcInternals.ts", "../src/sdk/NetworkTestManager.ts", "../src/sdk/RoleChangeManager.ts", "../src/analytics/HTTPAnalyticsTransport.ts", "../src/sdk/store/Store.ts", "../src/sdk/WakeLockManager.ts", "../src/analytics/AnalyticsEventsService.ts", "../src/audio-sink-manager/AudioSinkManager.ts", "../src/device-manager/DeviceManager.ts", "../src/device-manager/AudioOutputManager.ts", "../src/events/EventBus.ts", "../src/events/HMSInternalEvent.ts", "../src/notification-manager/HMSNotifications.ts", "../src/notification-manager/managers/ActiveSpeakerManager.ts", "../src/notification-manager/managers/BroadcastManager.ts", "../src/notification-manager/managers/ConnectionQualityManager.ts", "../src/notification-manager/managers/TrackManager.ts", "../src/notification-manager/managers/onDemandTrackManager.ts", "../src/notification-manager/managers/PeerListManager.ts", "../src/utils/date.ts", "../src/notification-manager/managers/PeerManager.ts", "../src/notification-manager/managers/PolicyChangeManager.ts", "../src/notification-manager/managers/PollsManager.ts", "../src/notification-manager/managers/RequestManager.ts", "../src/notification-manager/managers/RoomUpdateManager.ts", "../src/notification-manager/managers/SessionMetadataManager.ts", "../src/notification-manager/NotificationManager.ts", "../src/playlist-manager/AudioContextManager.ts", "../src/utils/typed-event-emitter.ts", "../src/playlist-manager/PlaylistAudioManager.ts", "../src/playlist-manager/PlaylistVideoManager.ts", "../src/playlist-manager/PlaylistManager.ts", "../src/session-store/index.ts", "../src/session-store/interactivity-center/HMSInteractivityCenter.ts", "../src/transport/models/JoinParameters.ts", "../src/transport/models/TransportFailureCategory.ts", "../src/transport/models/TransportState.ts", "../src/utils/promise.ts", "../src/transport/RetryScheduler.ts", "../src/analytics/publish-stats/index.ts", "../src/analytics/signal-transport/LocalStoageEvents.ts", "../src/analytics/AnalyticsTransport.ts", "../src/analytics/signal-transport/SignalAnalyticsTransport.ts", "../src/connection/model.ts", "../src/utils/session-description.ts", "../src/connection/HMSConnection.ts", "../src/connection/publish/publishConnection.ts", "../src/connection/subscribe/subscribeConnection.ts", "../src/connection/HMSDataChannel.ts", "../src/signal/init/index.ts", "../src/signal/jsonrpc/index.ts", "../src/utils/network-info.ts", "../src/transport/index.ts", "../src/utils/fetch.ts", "../src/utils/jwt.ts", "../src/sdk/index.ts"],
  "sourcesContent": ["{\n  \"name\": \"@100mslive/hms-video\",\n  \"version\": \"0.9.16\",\n  \"license\": \"MIT\",\n  \"main\": \"dist/index.cjs.js\",\n  \"typings\": \"dist/index.d.ts\",\n  \"module\": \"dist/index.js\",\n  \"files\": [\n    \"dist\",\n    \"src\"\n  ],\n  \"engines\": {\n    \"node\": \">=10\"\n  },\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.cjs.js\",\n      \"import\": \"./dist/index.js\",\n      \"default\": \"./dist/index.js\"\n    }\n  },\n  \"scripts\": {\n    \"prestart\": \"rm -rf dist && yarn types:build\",\n    \"start\": \"concurrently \\\"yarn dev\\\" \\\"yarn types\\\"\",\n    \"dev\": \"node ../../scripts/dev\",\n    \"build:only\": \"node ../../scripts/build\",\n    \"build\": \"yarn build:only && yarn types:build\",\n    \"types\": \"tsc -w\",\n    \"types:build\": \"tsc -p tsconfig.json\",\n    \"test\": \"jest --maxWorkers=1\",\n    \"lint\": \"eslint -c ../../.eslintrc .\",\n    \"lint:fix\": \"yarn lint --fix\",\n    \"prepare\": \"yarn build\",\n    \"size\": \"size-limit\",\n    \"analyze\": \"size-limit --why\",\n    \"format\": \"prettier --write src/**/*.ts\"\n  },\n  \"author\": \"100ms <tech-common@100ms.live>\",\n  \"devDependencies\": {\n    \"@types/dom-screen-wake-lock\": \"^1.0.1\",\n    \"@types/sdp-transform\": \"^2.4.4\",\n    \"@types/ua-parser-js\": \"^0.7.36\",\n    \"@types/uuid\": \"^8.3.0\",\n    \"jest-canvas-mock\": \"^2.3.1\",\n    \"tslib\": \"^2.2.0\"\n  },\n  \"dependencies\": {\n    \"eventemitter2\": \"^6.4.7\",\n    \"sdp-transform\": \"^2.14.1\",\n    \"ua-parser-js\": \"^1.0.1\",\n    \"uuid\": \"^8.3.2\",\n    \"webrtc-adapter\": \"^8.0.0\"\n  },\n  \"gitHead\": \"c06edac3e71481de08e948ffe0affaf705564ad1\"\n}\n", "export * from './sdk';\nexport * from './internal';\n", "import { HMSPeer } from './peer';\nimport { HMSRole } from '../../interfaces';\nimport { HMSMessage } from '../../interfaces/message';\nimport { SendMessage } from '../../notification-manager';\nimport { ISignalParamsProvider } from '../../signal/ISignalSendParamsProvider';\n\nexport default class Message implements HMSMessage, ISignalParamsProvider<SendMessage> {\n  sender?: HMSPeer;\n  recipientPeer?: HMSPeer;\n  recipientRoles?: HMSRole[];\n  message: any;\n  time: Date;\n  type: string;\n  id?: string;\n\n  constructor({ sender, message, type = 'chat', recipientPeer, recipientRoles, time, id }: HMSMessage) {\n    this.sender = sender;\n    this.message = message;\n    this.type = type;\n    this.recipientPeer = recipientPeer;\n    this.recipientRoles = recipientRoles;\n    this.time = time;\n    this.id = id;\n  }\n\n  toSignalParams() {\n    const roles = this.recipientRoles?.map(role => role.name);\n    const peer = this.recipientPeer?.peerId;\n    const sendParams: SendMessage = {\n      info: {\n        message: this.message,\n        type: this.type,\n      },\n    };\n    if (roles?.length) {\n      sendParams.roles = roles;\n    }\n    if (peer) {\n      sendParams.peer_id = peer;\n    }\n    return sendParams;\n  }\n\n  toString() {\n    return `{\n      sender: ${this.sender};\n      recipientPeer: ${this.recipientPeer};\n      recipientRoles: ${this.recipientRoles?.map(role => role.name)};\n      message: ${this.message};\n      time: ${this.time};\n      type: ${this.type};\n      id: ${this.id}\n    }`;\n  }\n}\n", "import { HMSHLS, HMSRecording, HMSRoom, HMSRTMP } from '../../interfaces/room';\n\nexport default class Room implements HMSRoom {\n  id: string;\n  joinedAt?: Date | undefined;\n  templateId?: string | undefined;\n  sessionId?: string;\n  startedAt?: Date;\n  recording: HMSRecording = { server: { running: false }, browser: { running: false }, hls: { running: false } };\n  rtmp: HMSRTMP = { running: false };\n  hls: HMSHLS = { running: false, variants: [] };\n  name?: string;\n  peerCount?: number;\n  description?: string;\n  max_size?: number;\n  large_room_optimization?: boolean;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n}\n", "export const RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';\nexport const API_DATA_CHANNEL = 'ion-sfu';\nexport const ANALYTICS_BUFFER_SIZE = 100;\n\n/**\n * Maximum number of retries that transport-layer will try\n * before giving up on the connection and returning a failure\n *\n * Refer https://100ms.atlassian.net/browse/HMS-2369\n */\nexport const MAX_TRANSPORT_RETRIES = 5;\nexport const MAX_TRANSPORT_RETRY_DELAY = 60;\n\nexport const DEFAULT_SIGNAL_PING_TIMEOUT = 12_000;\nexport const DEFAULT_SIGNAL_PING_INTERVAL = 3_000;\nexport const PONG_RESPONSE_TIMES_SIZE = 5;\n\nexport const SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID = 'SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID';\nexport const SUBSCRIBE_TIMEOUT = 60_000;\n\nexport const ICE_DISCONNECTION_TIMEOUT = 5_000;\n\nexport const RTC_STATS_MONITOR_INTERVAL = 1_000;\n\nexport const MAINTAIN_TRACK_HISTORY = false;\n\nexport const CLIENT_ANAYLTICS_PROD_ENDPOINT = 'https://event.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_QA_ENDPOINT = 'https://event-nonprod.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_STORAGE_LIMIT = 100;\n\nexport const PUBLISH_STATS_SAMPLE_WINDOW = 30;\nexport const PUBLISH_STATS_PUSH_INTERVAL = 300;\n\nexport const HMSEvents = {\n  DEVICE_CHANGE: 'device-change',\n  LOCAL_AUDIO_ENABLED: 'local-audio-enabled',\n  LOCAL_VIDEO_ENABLED: 'local-video-enabled',\n  STATS_UPDATE: 'stats-update', // emitted by HMSWebrtcInternals\n  RTC_STATS_UPDATE: 'rtc-stats-update', // emitted by RTCStatsMonitor\n  TRACK_DEGRADED: 'track-degraded',\n  TRACK_RESTORED: 'track-restored',\n  TRACK_AUDIO_LEVEL_UPDATE: 'track-audio-level-update',\n  LOCAL_AUDIO_SILENCE: 'local-audio-silence',\n  ANALYTICS: 'analytics',\n  AUDIO_PLUGIN_FAILED: 'audio-plugin-failed',\n  POLICY_CHANGE: 'policy-change',\n  LOCAL_ROLE_UPDATE: 'local-role-update',\n  AUDIO_TRACK_UPDATE: 'audio-track-update',\n  AUDIO_TRACK_ADDED: 'audio-track-added',\n  AUDIO_TRACK_REMOVED: 'audio-track-removed',\n  AUTOPLAY_ERROR: 'autoplay-error',\n  LEAVE: 'leave',\n};\n\nexport const PROTOCOL_VERSION = '2.5';\n\nexport const PROTOCOL_SPEC = '20230627';\n\nexport const HAND_RAISE_GROUP_NAME = '_handraise';\n", "import { HMSPeer as IHMSPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSAudioTrack, HMSTrack, HMSVideoTrack } from '../../../media/tracks';\nimport { HAND_RAISE_GROUP_NAME } from '../../../utils/constants';\n\nexport type HMSPeerInit = {\n  peerId: string;\n  name: string;\n  isLocal: boolean;\n  customerUserId?: string;\n  metadata?: string;\n  role?: HMSRole;\n  joinedAt?: Date;\n  fromRoomState?: boolean;\n  metworkQuality?: number;\n  groups?: string[];\n  realtime?: boolean;\n  isHandRaised?: boolean;\n};\n\nexport class HMSPeer implements IHMSPeer {\n  readonly peerId: string;\n  readonly isLocal: boolean;\n  name: string;\n  customerUserId?: string = '';\n  metadata?: string = '';\n  audioTrack?: HMSAudioTrack;\n  videoTrack?: HMSVideoTrack;\n  auxiliaryTracks: HMSTrack[] = [];\n  role?: HMSRole;\n  joinedAt?: Date;\n  networkQuality?: number;\n  groups?: string[];\n  realtime?: boolean;\n\n  constructor({ peerId, name, isLocal, customerUserId, metadata, role, joinedAt, groups, realtime }: HMSPeerInit) {\n    this.name = name;\n    this.peerId = peerId;\n    this.isLocal = isLocal;\n    this.customerUserId = customerUserId;\n    this.metadata = metadata;\n    this.joinedAt = joinedAt;\n    this.groups = groups;\n    this.realtime = realtime;\n\n    if (role) {\n      this.role = role;\n    }\n  }\n\n  get isHandRaised() {\n    return !!this.groups?.includes(HAND_RAISE_GROUP_NAME);\n  }\n\n  /**\n   * @internal\n   */\n  updateRole(newRole: HMSRole) {\n    this.role = newRole;\n  }\n  /**\n   * @internal\n   */\n  updateName(newName: string) {\n    this.name = newName;\n  }\n\n  updateNetworkQuality(quality: number) {\n    this.networkQuality = quality;\n  }\n  /**\n   * @internal\n   */\n  updateMetadata(data: string) {\n    this.metadata = data;\n  }\n\n  updateGroups(groups: string[]) {\n    this.groups = groups;\n  }\n\n  toString() {\n    return `{\n      name: ${this.name};\n      role: ${this.role?.name};\n      peerId: ${this.peerId};\n      customerUserId: ${this.customerUserId};\n      ${this.audioTrack ? `audioTrack: ${this.audioTrack?.trackId};` : ''}\n      ${this.videoTrack ? `videoTrack: ${this.videoTrack?.trackId};` : ''}\n      groups: ${this.groups?.join()}\n    }`;\n  }\n}\n", "import { v4 as uuidv4 } from 'uuid';\n\nexport default class HMSIdFactory {\n  static makePeerId = () => uuidv4();\n}\n", "import { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSLocalPeer as IHMSLocalPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../../../media/tracks';\nimport HMSIdFactory from '../../../utils/id-factory';\n\ntype HMSLocalPeerInit = Omit<HMSPeerInit, 'isLocal' | 'peerId'> & { asRole?: HMSRole };\n\nexport class HMSLocalPeer extends HMSPeer implements IHMSLocalPeer {\n  isLocal = true;\n  declare audioTrack?: HMSLocalAudioTrack;\n  declare videoTrack?: HMSLocalVideoTrack;\n  auxiliaryTracks: HMSLocalTrack[] = [];\n  asRole?: HMSRole;\n\n  constructor(peerData: HMSLocalPeerInit) {\n    super({ ...peerData, peerId: HMSIdFactory.makePeerId(), isLocal: true });\n    this.asRole = peerData.asRole;\n  }\n\n  isInPreview() {\n    return !!this.asRole;\n  }\n\n  toString(): string {\n    return `{\n      name: ${this.name};\n      role: ${this.role?.name};\n      peerId: ${this.peerId};\n      customerUserId: ${this.customerUserId};\n      ${this.asRole ? `asRole: ${this.asRole.name};` : ''}\n      ${this.audioTrack ? `audioTrack: ${this.audioTrack?.trackId};` : ''}\n      ${this.videoTrack ? `videoTrack: ${this.videoTrack?.trackId};` : ''}\n    }`;\n  }\n}\n", "import { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSRemotePeer as IHMSRemotePeer } from '../../../interfaces/peer';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack } from '../../../media/tracks';\n\ntype HMSRemotePeerInit = Omit<HMSPeerInit, 'isLocal'>;\n\nexport class HMSRemotePeer extends HMSPeer implements IHMSRemotePeer {\n  isLocal = false;\n  declare audioTrack?: HMSRemoteAudioTrack;\n  declare videoTrack?: HMSRemoteVideoTrack;\n  auxiliaryTracks: HMSRemoteTrack[] = [];\n  fromRoomState = false;\n\n  constructor(peerData: HMSRemotePeerInit) {\n    super({ ...peerData, isLocal: false });\n    this.fromRoomState = !!peerData.fromRoomState;\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport { IStore } from './store';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { HMSException } from '../error/HMSException';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { EventBus } from '../events/EventBus';\nimport { HMSAudioCodec, HMSScreenShareConfig, HMSVideoCodec, ScreenCaptureHandleConfig } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack, HMSTrackType } from '../internal';\nimport {\n  HMSAudioTrackSettings,\n  HMSAudioTrackSettingsBuilder,\n  HMSTrackSettings,\n  HMSTrackSettingsBuilder,\n  HMSVideoTrackSettings,\n  HMSVideoTrackSettingsBuilder,\n} from '../media/settings';\nimport { HMSLocalStream } from '../media/streams/HMSLocalStream';\nimport { IFetchAVTrackOptions } from '../transport/ITransport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport HMSLogger from '../utils/logger';\nimport { HMSAudioContextHandler } from '../utils/media';\n\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nlet blankCanvas: HTMLCanvasElement | undefined;\nlet intervalID: ReturnType<typeof setInterval> | undefined;\n\nexport class LocalTrackManager {\n  readonly TAG: string = '[LocalTrackManager]';\n  private captureHandleIdentifier?: string;\n\n  constructor(\n    private store: IStore,\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private eventBus: EventBus,\n    private analyticsTimer: AnalyticsTimer,\n  ) {\n    this.setScreenCaptureHandleConfig();\n  }\n\n  // eslint-disable-next-line complexity\n  async getTracksToPublish(initialSettings: InitialSettings = defaultSettings): Promise<HMSLocalTrack[]> {\n    const trackSettings = this.getAVTrackSettings(initialSettings);\n    if (!trackSettings) {\n      return [];\n    }\n    const canPublishAudio = !!trackSettings.audio;\n    const canPublishVideo = !!trackSettings.video;\n    let tracksToPublish: Array<HMSLocalTrack> = [];\n    const { videoTrack, audioTrack } = await this.updateCurrentLocalTrackSettings(trackSettings);\n    const localStream = (videoTrack?.stream || audioTrack?.stream) as HMSLocalStream | undefined;\n    // The track gets added to the store only after it is published.\n    const isVideoTrackPublished = Boolean(videoTrack && this.store.getTrackById(videoTrack.trackId));\n    const isAudioTrackPublished = Boolean(audioTrack && this.store.getTrackById(audioTrack.trackId));\n\n    if (isVideoTrackPublished && isAudioTrackPublished) {\n      // there is nothing to publish\n      return [];\n    }\n\n    const fetchTrackOptions: IFetchAVTrackOptions = {\n      audio: canPublishAudio && !audioTrack && (initialSettings.isAudioMuted ? 'empty' : true),\n      video: canPublishVideo && !videoTrack && (initialSettings.isVideoMuted ? 'empty' : true),\n    };\n\n    if (fetchTrackOptions.audio) {\n      this.analyticsTimer.start(TimedEvent.LOCAL_AUDIO_TRACK);\n    }\n    if (fetchTrackOptions.video) {\n      this.analyticsTimer.start(TimedEvent.LOCAL_VIDEO_TRACK);\n    }\n    try {\n      HMSLogger.d(this.TAG, 'Init Local Tracks', { fetchTrackOptions });\n      tracksToPublish = await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n    } catch (error) {\n      tracksToPublish = await this.retryGetLocalTracks(\n        error as HMSException,\n        trackSettings,\n        fetchTrackOptions,\n        localStream,\n      );\n    }\n    if (fetchTrackOptions.audio) {\n      this.analyticsTimer.end(TimedEvent.LOCAL_AUDIO_TRACK);\n    }\n    if (fetchTrackOptions.video) {\n      this.analyticsTimer.end(TimedEvent.LOCAL_VIDEO_TRACK);\n    }\n\n    if (videoTrack && canPublishVideo && !isVideoTrackPublished) {\n      tracksToPublish.push(videoTrack);\n    }\n    if (audioTrack && canPublishAudio && !isAudioTrackPublished) {\n      tracksToPublish.push(audioTrack);\n    }\n    return tracksToPublish;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  async getLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      const nativeTracks = await this.getNativeLocalTracks(fetchTrackOptions, settings);\n      return this.createHMSLocalTracks(nativeTracks, settings, localStream);\n    } catch (error) {\n      // TOOD: On OverConstrained error, retry with dropping all constraints.\n      // Just retry getusermedia again - it sometimes work when AbortError or NotFoundError is thrown on a few devices\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          devices: this.deviceManager.getDevices(),\n          error: error as Error,\n          settings,\n        }),\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getNativeLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: false, video: false },\n    settings: HMSTrackSettings,\n  ) {\n    const trackSettings = new HMSTrackSettings(\n      fetchTrackOptions.video === true ? settings.video : null,\n      fetchTrackOptions.audio === true ? settings.audio : null,\n      settings.simulcast,\n    );\n    const nativeTracks: MediaStreamTrack[] = [];\n\n    if (trackSettings.audio || trackSettings.video) {\n      nativeTracks.push(...(await this.getAVTracks(trackSettings)));\n    }\n    nativeTracks.push(...this.getEmptyTracks(fetchTrackOptions));\n    return nativeTracks;\n  }\n\n  async getLocalScreen(partialConfig?: HMSScreenShareConfig) {\n    const config = await this.getOrDefaultScreenshareConfig(partialConfig);\n    const screenSettings = this.getScreenshareSettings(config.videoOnly);\n    const constraints = {\n      video: { ...screenSettings?.video.toConstraints(true), displaySurface: config.displaySurface },\n      preferCurrentTab: config.preferCurrentTab,\n      selfBrowserSurface: config.selfBrowserSurface,\n      surfaceSwitching: config.surfaceSwitching,\n      systemAudio: config.systemAudio,\n    } as MediaStreamConstraints;\n    if (screenSettings?.audio) {\n      const audioConstraints: MediaTrackConstraints = screenSettings?.audio?.toConstraints();\n      // remove advanced constraints as it not supported for screenshare audio\n      delete audioConstraints.advanced;\n      constraints.audio = {\n        ...audioConstraints,\n        autoGainControl: false,\n        noiseSuppression: false,\n        // @ts-ignore\n        googAutoGainControl: false,\n        echoCancellation: false,\n      };\n    }\n    let stream;\n    try {\n      HMSLogger.d('retrieving screenshare with ', { config }, { constraints });\n      // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n      stream = (await navigator.mediaDevices.getDisplayMedia(constraints)) as MediaStream;\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'error in getting screenshare - ', err);\n      const error = BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          error: error as Error,\n          devices: this.deviceManager.getDevices(),\n          settings: new HMSTrackSettings(screenSettings?.video, screenSettings?.audio, false),\n        }),\n      );\n      throw error;\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    const local = new HMSLocalStream(stream);\n    const nativeVideoTrack = stream.getVideoTracks()[0];\n    const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'screen', this.eventBus, screenSettings?.video);\n    videoTrack.setSimulcastDefinitons(this.store.getSimulcastDefinitionsForPeer(this.store.getLocalPeer()!, 'screen'));\n\n    try {\n      const isCurrentTabShared = this.validateCurrentTabCapture(videoTrack, config.forceCurrentTab);\n      videoTrack.isCurrentTab = isCurrentTabShared;\n      await videoTrack.cropTo(config.cropTarget);\n    } catch (err) {\n      stream.getTracks().forEach(track => track.stop());\n      throw err;\n    }\n\n    tracks.push(videoTrack);\n    const nativeAudioTrack = stream.getAudioTracks()[0];\n    if (nativeAudioTrack) {\n      const audioTrack = new HMSLocalAudioTrack(\n        local,\n        nativeAudioTrack,\n        'screen',\n        this.eventBus,\n        screenSettings?.audio,\n      );\n      tracks.push(audioTrack);\n    }\n\n    HMSLogger.v(this.TAG, 'getLocalScreen', tracks);\n    return tracks;\n  }\n\n  setScreenCaptureHandleConfig(config?: Partial<ScreenCaptureHandleConfig>) {\n    // @ts-ignore\n    if (!navigator.mediaDevices?.setCaptureHandleConfig || this.isInIframe()) {\n      // setCaptureHandleConfig can't be called from within an iframe\n      return;\n    }\n    config = config || {};\n    Object.assign(config, { handle: uuid(), exposeOrigin: false, permittedOrigins: [window.location.origin] });\n    HMSLogger.d('setting capture handle - ', config.handle);\n    // @ts-ignore\n    navigator.mediaDevices.setCaptureHandleConfig(config);\n    this.captureHandleIdentifier = config.handle;\n  }\n\n  validateCurrentTabCapture(track: HMSLocalVideoTrack, forceCurrentTab: boolean): boolean {\n    const trackHandle = track.getCaptureHandle();\n    const isCurrentTabShared = !!(this.captureHandleIdentifier && trackHandle?.handle === this.captureHandleIdentifier);\n    if (forceCurrentTab && !isCurrentTabShared) {\n      HMSLogger.e(this.TAG, 'current tab was not shared with forceCurrentTab as true');\n      throw ErrorFactory.TracksErrors.CurrentTabNotShared();\n    }\n    return isCurrentTabShared;\n  }\n\n  async requestPermissions() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true,\n      });\n      // Stop stream\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      HMSLogger.e(this.TAG, error);\n    }\n  }\n\n  static getEmptyVideoTrack(prevTrack?: MediaStreamTrack): MediaStreamTrack {\n    const width = prevTrack?.getSettings()?.width || 320;\n    const height = prevTrack?.getSettings()?.height || 240;\n    const frameRate = 1; // fps TODO: experiment, see if this can be reduced\n    if (!blankCanvas) {\n      blankCanvas = document.createElement('canvas');\n      blankCanvas.width = width;\n      blankCanvas.height = height;\n      blankCanvas.getContext('2d')?.fillRect(0, 0, width, height);\n    }\n    if (!intervalID) {\n      // This is needed to send some data so the track is received on sfu\n      intervalID = setInterval(() => {\n        const ctx = blankCanvas?.getContext('2d');\n        if (ctx) {\n          ctx.fillRect(0, 0, 1, 1);\n        }\n      }, 1000 / frameRate);\n    }\n\n    const stream = blankCanvas.captureStream(frameRate);\n    const emptyTrack = stream.getVideoTracks()[0];\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  static getEmptyAudioTrack(): MediaStreamTrack {\n    const ctx = HMSAudioContextHandler.getAudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(dst);\n    oscillator.start();\n    const emptyTrack = dst.stream.getAudioTracks()[0];\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  static cleanup() {\n    clearInterval(intervalID);\n    intervalID = undefined;\n    blankCanvas = undefined;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getAVTracks(settings: HMSTrackSettings): Promise<Array<MediaStreamTrack>> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: settings.audio ? settings.audio.toConstraints() : false,\n        video: settings.video ? settings.video.toConstraints() : false,\n      });\n\n      return stream.getVideoTracks().concat(stream.getAudioTracks());\n    } catch (error) {\n      await this.deviceManager.init();\n      const videoError = !!(!this.deviceManager.hasWebcamPermission && settings.video);\n      const audioError = !!(!this.deviceManager.hasMicrophonePermission && settings.audio);\n      /**\n       * TODO: Only permission error throws correct device info in error(audio or video or both),\n       * Right now for other errors such as overconstrained error we are unable to get whether audio/video failure.\n       * Fix this by checking the native error message.\n       */\n      const errorType = this.getErrorType(videoError, audioError);\n      throw BuildGetMediaError(error as Error, errorType);\n    }\n  }\n\n  private getAVTrackSettings(initialSettings: InitialSettings): HMSTrackSettings | null {\n    const audioSettings = this.getAudioSettings(initialSettings);\n    const videoSettings = this.getVideoSettings(initialSettings);\n    if (!audioSettings && !videoSettings) {\n      return null;\n    }\n    return new HMSTrackSettingsBuilder().video(videoSettings).audio(audioSettings).build();\n  }\n\n  private isInIframe() {\n    try {\n      return window.self !== window.top;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  private async retryGetLocalTracks(\n    error: HMSException,\n    trackSettings: HMSTrackSettings,\n    fetchTrackOptions: IFetchAVTrackOptions,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    if (error instanceof HMSException && error.action === HMSAction.TRACK) {\n      this.observer.onFailure(error);\n\n      const overConstrainedFailure = error.code === ErrorCodes.TracksErrors.OVER_CONSTRAINED;\n      const audioFailure = error.message.includes('audio');\n      const videoFailure = error.message.includes('video');\n      if (overConstrainedFailure) {\n        // TODO: Use this once TODO@L#250 is completed\n        // const newTrackSettings = new HMSTrackSettingsBuilder()\n        //   .video(videoFailure ? new HMSVideoTrackSettings() : trackSettings.video)\n        //   .audio(audioFailure ? new HMSAudioTrackSettings() : trackSettings.audio)\n        //   .build();\n        const newTrackSettings = new HMSTrackSettingsBuilder()\n          .video(new HMSVideoTrackSettings())\n          .audio(new HMSAudioTrackSettings())\n          .build();\n\n        HMSLogger.w(this.TAG, 'Fetch AV Tracks failed with overconstrained error', { fetchTrackOptions }, { error });\n\n        try {\n          // Try get local tracks with no constraints\n          return await this.getLocalTracks(fetchTrackOptions, newTrackSettings, localStream);\n        } catch (error) {\n          /**\n           * This error shouldn't be overconstrained error(as we've dropped all constraints).\n           * If it's an overconstrained error, change error code to avoid recursive loop\n           * Try get local tracks for empty tracks\n           */\n          const nativeError: Error | undefined = error instanceof HMSException ? error.nativeError : (error as Error);\n          let ex = error;\n          if (nativeError?.name === 'OverconstrainedError') {\n            const newError = ErrorFactory.TracksErrors.GenericTrack(\n              HMSAction.TRACK,\n              'Overconstrained error after dropping all constraints',\n            );\n            newError.addNativeError(nativeError);\n            ex = newError;\n          }\n\n          return await this.retryGetLocalTracks(ex as HMSException, trackSettings, fetchTrackOptions, localStream);\n        }\n      }\n\n      fetchTrackOptions.audio = audioFailure ? 'empty' : fetchTrackOptions.audio;\n      fetchTrackOptions.video = videoFailure ? 'empty' : fetchTrackOptions.video;\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed', { fetchTrackOptions }, error);\n      try {\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      } catch (error) {\n        HMSLogger.w(this.TAG, 'Fetch empty tacks failed', error);\n        fetchTrackOptions.audio = fetchTrackOptions.audio && 'empty';\n        fetchTrackOptions.video = fetchTrackOptions.video && 'empty';\n        this.observer.onFailure(error as HMSException);\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      }\n    } else {\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed - unknown exception', error);\n      this.observer.onFailure(error);\n      return [];\n    }\n  }\n\n  private getErrorType(videoError: boolean, audioError: boolean): HMSGetMediaActions {\n    if (videoError && audioError) {\n      return HMSGetMediaActions.AV;\n    }\n    if (videoError) {\n      return HMSGetMediaActions.VIDEO;\n    }\n    if (audioError) {\n      return HMSGetMediaActions.AUDIO;\n    }\n    return HMSGetMediaActions.UNKNOWN;\n  }\n\n  private getEmptyTracks(fetchTrackOptions: IFetchAVTrackOptions) {\n    const nativeTracks: MediaStreamTrack[] = [];\n    if (fetchTrackOptions.audio === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyAudioTrack());\n    }\n\n    if (fetchTrackOptions.video === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyVideoTrack());\n    }\n    return nativeTracks;\n  }\n\n  private async updateCurrentLocalTrackSettings(trackSettings: HMSTrackSettings | null) {\n    const localTracks = this.store.getLocalPeerTracks();\n    const videoTrack = localTracks.find(t => t.type === HMSTrackType.VIDEO && t.source === 'regular') as\n      | HMSLocalVideoTrack\n      | undefined;\n    const audioTrack = localTracks.find(t => t.type === HMSTrackType.AUDIO && t.source === 'regular') as\n      | HMSLocalAudioTrack\n      | undefined;\n\n    const screenVideoTrack = localTracks.find(t => t.type === HMSTrackType.VIDEO && t.source === 'screen') as\n      | HMSLocalVideoTrack\n      | undefined;\n\n    if (trackSettings?.video) {\n      await videoTrack?.setSettings(trackSettings.video);\n    }\n\n    if (trackSettings?.audio) {\n      await audioTrack?.setSettings(trackSettings.audio);\n    }\n\n    const screenSettings = this.getScreenshareSettings(true);\n    if (screenSettings?.video) {\n      await screenVideoTrack?.setSettings(screenSettings?.video);\n    }\n\n    return { videoTrack, audioTrack };\n  }\n\n  private getAudioSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('audio')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const audioTrack = localPeer?.audioTrack;\n    // Get device from the tracks already added in preview\n    const audioDeviceId = audioTrack?.settings.deviceId || initialSettings.audioInputDeviceId;\n\n    return new HMSAudioTrackSettingsBuilder()\n      .codec(publishParams.audio.codec as HMSAudioCodec)\n      .maxBitrate(publishParams.audio.bitRate)\n      .deviceId(audioDeviceId || defaultSettings.audioInputDeviceId)\n      .build();\n  }\n\n  private getVideoSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('video')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const videoTrack = localPeer?.videoTrack;\n    // Get device from the tracks already added in preview\n    const videoDeviceId = videoTrack?.settings.deviceId || initialSettings.videoDeviceId;\n    const video = publishParams.video;\n    return new HMSVideoTrackSettingsBuilder()\n      .codec(video.codec as HMSVideoCodec)\n      .maxBitrate(video.bitRate)\n      .maxFramerate(video.frameRate)\n      .setWidth(video.width) // take simulcast width if available\n      .setHeight(video.height) // take simulcast width if available\n      .deviceId(videoDeviceId || defaultSettings.videoDeviceId)\n      .build();\n  }\n\n  private getScreenshareSettings(isVideoOnly = false) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('screen')) {\n      return null;\n    }\n    const screen = publishParams.screen;\n    return {\n      video: new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(screen.width)\n        .setHeight(screen.height)\n        .build(),\n      audio: isVideoOnly ? undefined : new HMSAudioTrackSettingsBuilder().build(),\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  private async getOrDefaultScreenshareConfig(partialConfig?: Partial<HMSScreenShareConfig>) {\n    type RequiredConfig = HMSScreenShareConfig &\n      Required<Omit<HMSScreenShareConfig, 'cropTarget' | 'cropElement' | 'displaySurface'>>;\n    const config: RequiredConfig = Object.assign(\n      {\n        videoOnly: false,\n        audioOnly: false,\n        forceCurrentTab: false,\n        preferCurrentTab: false,\n        selfBrowserSurface: 'exclude', // don't give self tab in options\n        surfaceSwitching: 'include', // give option to switch tabs while sharing\n        systemAudio: 'exclude', // system audio share leads to echo in windows\n        displaySurface: 'monitor',\n      },\n      partialConfig || {},\n    );\n    if (config.forceCurrentTab) {\n      config.videoOnly = true; // there will be echo otherwise\n      config.preferCurrentTab = true;\n      config.selfBrowserSurface = 'include';\n      config.surfaceSwitching = 'exclude';\n    }\n    if (config.preferCurrentTab) {\n      config.selfBrowserSurface = 'include';\n      config.displaySurface = undefined; // so the default selected is the current tab\n    }\n    // @ts-ignore\n    if (config.cropElement && window.CropTarget?.fromElement) {\n      // @ts-ignore\n      config.cropTarget = await window.CropTarget.fromElement(config.cropElement);\n    }\n    return config;\n  }\n\n  private createHMSLocalTracks(\n    nativeTracks: MediaStreamTrack[],\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ) {\n    const nativeVideoTrack = nativeTracks.find(track => track.kind === 'video');\n    const nativeAudioTrack = nativeTracks.find(track => track.kind === 'audio');\n    if (localStream) {\n      nativeTracks.forEach(track => localStream?.nativeStream.addTrack(track));\n    } else {\n      localStream = new HMSLocalStream(new MediaStream(nativeTracks));\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    if (nativeAudioTrack && settings?.audio) {\n      const audioTrack = new HMSLocalAudioTrack(\n        localStream,\n        nativeAudioTrack,\n        'regular',\n        this.eventBus,\n        settings.audio,\n      );\n      tracks.push(audioTrack);\n    }\n\n    if (nativeVideoTrack && settings?.video) {\n      const videoTrack = new HMSLocalVideoTrack(\n        localStream,\n        nativeVideoTrack,\n        'regular',\n        this.eventBus,\n        settings.video,\n      );\n      videoTrack.setSimulcastDefinitons(\n        this.store.getSimulcastDefinitionsForPeer(this.store.getLocalPeer()!, 'regular'),\n      );\n      tracks.push(videoTrack);\n    }\n    return tracks;\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { domainCategory } from './domain-analytics';\nimport { ISignalParamsProvider } from '../signal/ISignalSendParamsProvider';\nimport { getAnalyticsDeviceId } from '../utils/analytics-deviceId';\nimport { createUserAgent } from '../utils/user-agent';\n\ninterface AnalyticsEventInit {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII?: boolean;\n  properties?: Record<string, any>;\n  timestamp?: number;\n}\n\ninterface SignalEventParams {\n  name: string;\n  info: any;\n  timestamp: number;\n}\n\nexport default class AnalyticsEvent implements ISignalParamsProvider<SignalEventParams> {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII: boolean;\n  properties: Record<string, any>;\n  metadata: {\n    token?: string;\n    peer: {\n      peer_id?: string;\n      session_id?: string;\n      room_id?: string;\n      role?: string;\n      room_name?: string;\n      joined_at?: number;\n      template_id?: string;\n      session_started_at?: number;\n      user_name?: string;\n      user_data?: string;\n    };\n    userAgent: string;\n  } = {\n    peer: {},\n    userAgent: createUserAgent(),\n  };\n  timestamp: number;\n  event_id: string;\n  device_id: string;\n\n  constructor({ name, level, properties, includesPII, timestamp }: AnalyticsEventInit) {\n    this.name = name;\n    this.level = level;\n    this.includesPII = includesPII || false;\n    this.properties = properties || {};\n    this.timestamp = timestamp || new Date().getTime(); // Timestamp of generating the event\n    this.event_id = uuid();\n    this.device_id = getAnalyticsDeviceId();\n  }\n\n  toSignalParams() {\n    return {\n      name: this.name,\n      info: { ...this.properties, timestamp: this.timestamp, domain: domainCategory },\n      timestamp: new Date().getTime(), // Timestamp of sending the event\n    };\n  }\n}\n", "import { UAParser } from 'ua-parser-js';\n\nexport const parsedUserAgent = new UAParser();\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport const isNode =\n  typeof window === 'undefined' && !parsedUserAgent.getBrowser().name?.toLowerCase().includes('electron');\n\nexport enum ENV {\n  PROD = 'prod',\n  QA = 'qa',\n  DEV = 'dev',\n}\n\nconst checkIsSupported = () => {\n  if (isNode) {\n    return false;\n  }\n  // @TODO: Get this from preview/init API from server\n  return true;\n};\n\nexport const isSupported = checkIsSupported();\n\nexport const isMobile = () => parsedUserAgent.getDevice().type === 'mobile';\n\nexport const isPageHidden = () => typeof document !== 'undefined' && document.hidden;\n\nexport const isIOS = () => parsedUserAgent.getOS().name?.toLowerCase() === 'ios';\n", "import { DomainCategory } from './AnalyticsEventDomains';\nimport { isBrowser } from '../utils/support';\n\nfunction getDomainCategory() {\n  // this function gives us the domain category(sutom, hms , local) of the base url.\n  // below if statement checks if it's running in a browser ; or if we can use 'window' safely\n\n  if (isBrowser && window) {\n    const baseurl = window.location.hostname;\n\n    if (baseurl === 'localhost' || baseurl === '127.0.0.1') {\n      return DomainCategory.LOCAL;\n    }\n\n    if (baseurl.includes('app.100ms.live')) {\n      return DomainCategory.HMS;\n    } else {\n      return DomainCategory.CUSTOM;\n    }\n  }\n\n  return DomainCategory.CUSTOM;\n}\n\nexport const domainCategory = getDomainCategory();\n", "import { v4 as uuid } from 'uuid';\nimport { LocalStorage } from './local-storage';\n\nexport const getAnalyticsDeviceId = () => {\n  let id;\n  const storage = new LocalStorage<string>('hms-analytics-deviceId');\n  const storageId = storage.get();\n  if (storageId) {\n    id = storageId;\n  } else {\n    id = uuid();\n    storage.set(id);\n  }\n  return id;\n};\n", "import { isBrowser } from './support';\n\nclass LocalStorage {\n  valuesMap = new Map();\n  getItem(key: string) {\n    if (this.valuesMap.has(key)) {\n      return String(this.valuesMap.get(key));\n    }\n    return null;\n  }\n\n  setItem(key: string, val: string) {\n    this.valuesMap.set(key, val);\n  }\n\n  removeItem(key: string) {\n    this.valuesMap.delete(key);\n  }\n\n  clear() {\n    this.valuesMap.clear();\n  }\n\n  key(i: number) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n    }\n    const arr = Array.from(this.valuesMap.keys());\n    return arr[i];\n  }\n\n  get length() {\n    return this.valuesMap.size;\n  }\n}\n\nexport const initializeLocalstoragePolyfill = () => {\n  if (isBrowser && !localStorage) {\n    window.localStorage = new LocalStorage();\n  }\n};\n", "import { initializeLocalstoragePolyfill } from './local-storage-polyfill';\nimport { isBrowser } from './support';\n\nexport class LocalStorage<T> {\n  private storage: Storage | null = null;\n\n  constructor(public readonly key: string) {}\n\n  /**\n   * localstorage is not available in SSR, so get it only at time of use\n   */\n  getStorage() {\n    if (isBrowser && !this.storage) {\n      initializeLocalstoragePolyfill();\n      this.storage = window.localStorage;\n    }\n    return this.storage;\n  }\n\n  get(): T | undefined {\n    const stringItem = this.getStorage()?.getItem(this.key);\n    if (!stringItem) {\n      return;\n    }\n    const item = JSON.parse(stringItem) as T;\n    return item;\n  }\n\n  set(value: T) {\n    const stringValue = JSON.stringify(value);\n    this.getStorage()?.setItem(this.key, stringValue);\n  }\n\n  clear() {\n    this.getStorage()?.removeItem(this.key);\n  }\n}\n", "export enum HMSLogLevel {\n  VERBOSE,\n  DEBUG,\n  INFO,\n  WARN,\n  TIME,\n  TIMEEND,\n  ERROR,\n  NONE,\n}\n\n// @ts-ignore - window.expect is available only when in test environment\nconst isTestEnv = typeof window !== 'undefined' && typeof window.expect !== 'undefined';\n/**\n * TODO: fix this so logs show the real file and line numbers where they originated from instead of this class\n * https://stackoverflow.com/questions/13815640/a-proper-wrapper-for-console-log-with-correct-line-number\n */\nexport default class HMSLogger {\n  static level: HMSLogLevel = isTestEnv ? HMSLogLevel.NONE : HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, tag, ...data);\n  }\n\n  static i(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.INFO, tag, ...data);\n  }\n\n  static w(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.WARN, tag, ...data);\n  }\n\n  static e(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.ERROR, tag, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanup() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  // eslint-disable-next-line complexity\n  private static log(level: HMSLogLevel, tag: string, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[0]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const mark = data[0];\n        try {\n          const entry = performance.measure(mark, mark);\n          // @ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n", "/*\n * ErrorCodes.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nexport const ErrorCodes = {\n  // https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1\n  WebSocketConnectionErrors: {\n    // Error connecting to ws or init config not available\n    FAILED_TO_CONNECT: 1000,\n\n    // Network connection lost\n    WEBSOCKET_CONNECTION_LOST: 1003,\n\n    // Abnormal close without receiving a Close control frame\n    ABNORMAL_CLOSE: 1006,\n  },\n\n  APIErrors: {\n    // [INIT]: Server error\n    SERVER_ERRORS: 2000,\n    //init config not available\n    INIT_CONFIG_NOT_AVAILABLE: 2002,\n\n    // Endpoint is not reachable.\n    ENDPOINT_UNREACHABLE: 2003,\n\n    // Token is not in proper JWT format\n    INVALID_TOKEN_FORMAT: 2004,\n  },\n\n  TracksErrors: {\n    // [PUBLISH]: Error with getusermedia request\n    GENERIC_TRACK: 3000,\n\n    // [PUBLISH]: No permission to access capture device - {device_type}\n    CANT_ACCESS_CAPTURE_DEVICE: 3001,\n\n    // [PUBLISH]: Capture device is no longer available - {device_type}\n    DEVICE_NOT_AVAILABLE: 3002,\n\n    // [PUBLISH]: Capture device is in use by another application - {device_type}\n    DEVICE_IN_USE: 3003,\n\n    // Lost access to capture device midway - {device_type}\n    DEVICE_LOST_MIDWAY: 3008,\n\n    // There is no media to return. Please select either video or audio or both.\n    NOTHING_TO_RETURN: 3005,\n\n    // Cannot enable simulcast when no video settings are provided\n    INVALID_VIDEO_SETTINGS: 3006,\n\n    // Codec can't be changed mid call.\n    CODEC_CHANGE_NOT_PERMITTED: 3007,\n\n    // When the browser throws autoplay exception if something is played before interacting\n    AUTOPLAY_ERROR: 3008,\n\n    // Over constrained error - device hardware unable to satisfy requested constraints\n    OVER_CONSTRAINED: 3009,\n\n    // No audio detected from track, indicates problem with device hardware\n    NO_AUDIO_DETECTED: 3010,\n\n    // Operating System denied permission\n    SYSTEM_DENIED_PERMISSION: 3011,\n\n    // Current tab is not shared when forceCurrentTab was set to true for screenshare\n    CURRENT_TAB_NOT_SHARED: 3012,\n\n    // any error that occurs while playing audio of remote audio tracks\n    AUDIO_PLAYBACK_ERROR: 3013,\n  },\n\n  WebrtcErrors: {\n    // [{action}]: Failed to create offer.\n    CREATE_OFFER_FAILED: 4001,\n\n    // [{action}]: Failed to create answer.\n    CREATE_ANSWER_FAILED: 4002,\n\n    // [{action}]: Failed to set offer.\n    SET_LOCAL_DESCRIPTION_FAILED: 4003,\n\n    // [{action}]: Failed to set answer.\n    SET_REMOTE_DESCRIPTION_FAILED: 4004,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_FAILURE: 4005,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_DISCONNECTED: 4006,\n\n    STATS_FAILED: 4007,\n  },\n\n  WebsocketMethodErrors: {\n    // [JOIN]: {server_error}\n    SERVER_ERRORS: 5000,\n\n    // [JOIN]: You have already joined this room.\n    ALREADY_JOINED: 5001,\n\n    // [JOIN]: Cannot join if preview is in progress\n    CANNOT_JOIN_PREVIEW_IN_PROGRESS: 5002,\n  },\n\n  GenericErrors: {\n    // Client is not connected\n    NOT_CONNECTED: 6000,\n\n    // Unknown signalling error: {action} {error_info}\n    SIGNALLING: 6001,\n\n    // Unknown exception: {error_info}\n    UNKNOWN: 6002,\n\n    // WebRTC engine is not ready yet\n    NOT_READY: 6003,\n\n    // Failed to parse JSON message - {json_message}\n    JSON_PARSING_FAILED: 6004,\n\n    // Track Metadata Missing\n    TRACK_METADATA_MISSING: 6005,\n\n    // RTC Track missing\n    RTC_TRACK_MISSING: 6006,\n\n    // Peer Metadata Missing\n    PEER_METADATA_MISSING: 6007,\n\n    // Joined with invalid role\n    INVALID_ROLE: 6008,\n\n    PREVIEW_IN_PROGRESS: 6009,\n\n    MISSING_MEDIADEVICES: 6010,\n\n    MISSING_RTCPEERCONNECTION: 6011,\n  },\n\n  PlaylistErrors: {\n    NO_ENTRY_TO_PLAY: 8001,\n    NO_ENTRY_IS_PLAYING: 8002,\n  },\n};\n", "import { HMSAction } from './HMSAction';\nimport { IAnalyticsPropertiesProvider } from '../analytics/IAnalyticsPropertiesProvider';\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\n\nexport class HMSException extends Error implements IAnalyticsPropertiesProvider {\n  action: string;\n  nativeError?: Error;\n\n  constructor(\n    public readonly code: number,\n    public name: string,\n    action: HMSAction | HMSSignalMethod,\n    public message: string,\n    public description: string,\n    public isTerminal: boolean = false,\n  ) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSException.prototype);\n    this.action = action.toString();\n  }\n\n  toAnalyticsProperties() {\n    return {\n      error_name: this.name,\n      error_code: this.code,\n      error_message: this.message,\n      error_description: this.description,\n      action: this.action,\n      is_terminal: this.isTerminal,\n    };\n  }\n\n  addNativeError(error: Error) {\n    this.nativeError = error;\n  }\n\n  toString() {\n    return `{\n      code: ${this.code};\n      name: ${this.name};\n      action: ${this.action};\n      message: ${this.message};\n      description: ${this.description};\n      isTerminal: ${this.isTerminal};\n      nativeError: ${this.nativeError?.message};\n    }`;\n  }\n}\n", "import { HMSAction } from '../../error/HMSAction';\n\nexport interface JsonRpcRequest {\n  id: string;\n  method: string;\n  params: Map<string, any>;\n}\n\nexport interface JsonRpcResponse {\n  id: string;\n  result: any;\n  error: {\n    code: number;\n    message: string;\n  };\n}\n\nexport enum HMSSignalMethod {\n  JOIN = 'join',\n  OFFER = 'offer',\n  ANSWER = 'answer',\n  TRICKLE = 'trickle',\n  TRACK_UPDATE = 'track-update',\n  BROADCAST = 'broadcast',\n  ANALYTICS = 'analytics',\n  SERVER_ERROR = 'on-error',\n  SERVER_WARNING = 'on-warning',\n  SDK_NOTIFICATION = 'sdk-notification',\n  LEAVE = 'leave',\n  END_ROOM = 'end-room',\n  PING = 'ping',\n  ROLE_CHANGE_REQUEST = 'role-change-request',\n  ROLE_CHANGE = 'role-change',\n  TRACK_UPDATE_REQUEST = 'track-update-request',\n  PEER_LEAVE_REQUEST = 'peer-leave-request',\n  CHANGE_TRACK_MUTE_STATE_REQUEST = 'change-track-mute-state-request',\n  START_RTMP_OR_RECORDING_REQUEST = 'rtmp-start',\n  STOP_RTMP_AND_RECORDING_REQUEST = 'rtmp-stop',\n  UPDATE_PEER_METADATA = 'peer-update',\n  START_HLS_STREAMING = 'hls-start',\n  STOP_HLS_STREAMING = 'hls-stop',\n  HLS_TIMED_METADATA = 'hls-timed-metadata',\n  SET_METADATA = 'set-metadata',\n  GET_METADATA = 'get-metadata',\n  LISTEN_METADATA_CHANGE = 'listen-metadata-change',\n  POLL_INFO_SET = 'poll-info-set',\n  POLL_INFO_GET = 'poll-info-get',\n  POLL_QUESTIONS_SET = 'poll-questions-set',\n  POLL_QUESTIONS_GET = 'poll-questions-get',\n  POLL_START = 'poll-start',\n  POLL_STOP = 'poll-stop',\n  POLL_RESPONSE_SET = 'poll-response',\n  POLL_LIST = 'poll-list',\n  POLL_RESPONSES = 'poll-responses',\n  POLL_RESULT = 'poll-result',\n  GET_PEER = 'get-peer',\n  GROUP_JOIN = 'group-join',\n  GROUP_LEAVE = 'group-leave',\n  GROUP_ADD = 'group-add',\n  GROUP_REMOVE = 'group-leave',\n}\n\nexport function convertSignalMethodtoErrorAction(method: HMSSignalMethod): HMSAction {\n  switch (method) {\n    case HMSSignalMethod.JOIN:\n      return HMSAction.JOIN;\n    case HMSSignalMethod.OFFER:\n      return HMSAction.PUBLISH;\n    case HMSSignalMethod.ANSWER:\n      return HMSAction.SUBSCRIBE;\n    case HMSSignalMethod.TRACK_UPDATE:\n      return HMSAction.TRACK;\n    default:\n      return HMSAction.NONE;\n  }\n}\n", "/*\n * ErrorFactory.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nimport { ErrorCodes } from './ErrorCodes';\nimport { HMSAction } from './HMSAction';\nimport { HMSException } from './HMSException';\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\n\nconst terminalActions: (HMSSignalMethod | HMSAction)[] = [\n  HMSSignalMethod.JOIN,\n  HMSSignalMethod.OFFER,\n  HMSSignalMethod.ANSWER,\n  HMSSignalMethod.TRICKLE,\n  HMSSignalMethod.SERVER_ERROR,\n  HMSAction.JOIN,\n];\n\nexport const ErrorFactory = {\n  WebSocketConnectionErrors: {\n    FailedToConnect(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n        'WebsocketFailedToConnect',\n        action,\n        `[WS]: ${description}`,\n        `[WS]: ${description}`,\n      );\n    },\n\n    WebSocketConnectionLost(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n        'WebSocketConnectionLost',\n        action,\n        `Network connection lost `,\n        description,\n      );\n    },\n\n    AbnormalClose(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.ABNORMAL_CLOSE,\n        'WebSocketAbnormalClose',\n        action,\n        `Websocket closed abnormally`,\n        description,\n      );\n    },\n  },\n\n  APIErrors: {\n    ServerErrors(code: number, action: HMSAction, description = '', isTerminal = true) {\n      return new HMSException(\n        code,\n        'ServerErrors',\n        action,\n        `[${action}]: Server error ${description}`,\n        description,\n        isTerminal,\n      );\n    },\n\n    EndpointUnreachable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.APIErrors.ENDPOINT_UNREACHABLE,\n        'EndpointUnreachable',\n        action,\n        `Endpoint is not reachable - ${description}`,\n        description,\n      );\n    },\n\n    InvalidTokenFormat(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.APIErrors.INVALID_TOKEN_FORMAT,\n        'InvalidTokenFormat',\n        action,\n        `Token is not in proper JWT format - ${description}`,\n        description,\n        true,\n      );\n    },\n\n    InitConfigNotAvailable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.APIErrors.INIT_CONFIG_NOT_AVAILABLE,\n        'InitError',\n        action,\n        `[INIT]: ${description}`,\n        `[INIT]: ${description}`,\n      );\n    },\n  },\n\n  TracksErrors: {\n    GenericTrack(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.GENERIC_TRACK,\n        'GenericTrack',\n        action,\n        `[TRACK]: ${description}`,\n        `[TRACK]: ${description}`,\n      );\n    },\n\n    CantAccessCaptureDevice(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n        'CantAccessCaptureDevice',\n        action,\n        `User denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceNotAvailable(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        'DeviceNotAvailable',\n        action,\n        `[TRACK]: Capture device is no longer available - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceInUse(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_IN_USE,\n        'DeviceInUse',\n        action,\n        `[TRACK]: Capture device is in use by another application - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceLostMidway(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_LOST_MIDWAY,\n        'DeviceLostMidway',\n        action,\n        `Lost access to capture device midway - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NothingToReturn(\n      action: HMSAction,\n      description = '',\n      message = `There is no media to return. Please select either video or audio or both.`,\n    ) {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NOTHING_TO_RETURN,\n        'NothingToReturn',\n        action,\n        message,\n        description,\n      );\n    },\n\n    InvalidVideoSettings(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.INVALID_VIDEO_SETTINGS,\n        'InvalidVideoSettings',\n        action,\n        `Cannot enable simulcast when no video settings are provided`,\n        description,\n      );\n    },\n\n    AutoplayBlocked(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUTOPLAY_ERROR,\n        'AutoplayBlocked',\n        action,\n        \"Autoplay blocked because the user didn't interact with the document first\",\n        description,\n      );\n    },\n\n    CodecChangeNotPermitted(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CODEC_CHANGE_NOT_PERMITTED,\n        'CodecChangeNotPermitted',\n        action,\n        `Codec can't be changed mid call.`,\n        description,\n      );\n    },\n\n    OverConstrained(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.OVER_CONSTRAINED,\n        'OverConstrained',\n        action,\n        `[TRACK]: Requested constraints cannot be satisfied with the device hardware - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NoAudioDetected(action: HMSAction, description = 'Please check the mic or use another audio input') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NO_AUDIO_DETECTED,\n        'NoAudioDetected',\n        action,\n        'No audio input detected from microphone',\n        description,\n      );\n    },\n\n    SystemDeniedPermission(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.SYSTEM_DENIED_PERMISSION,\n        'SystemDeniedPermission',\n        action,\n        `Operating System denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    CurrentTabNotShared() {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CURRENT_TAB_NOT_SHARED,\n        'CurrentTabNotShared',\n        HMSAction.TRACK,\n        'The app requires you to share the current tab',\n        'You must screen share the current tab in order to proceed',\n      );\n    },\n\n    AudioPlaybackError(description: string) {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUDIO_PLAYBACK_ERROR,\n        'Audio playback error',\n        HMSAction.TRACK,\n        description,\n        description,\n      );\n    },\n  },\n\n  WebrtcErrors: {\n    CreateOfferFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_OFFER_FAILED,\n        'CreateOfferFailed',\n        action,\n        `[${action.toString()}]: Failed to create offer. `,\n        description,\n      );\n    },\n\n    CreateAnswerFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_ANSWER_FAILED,\n        'CreateAnswerFailed',\n        action,\n        `[${action.toString()}]: Failed to create answer. `,\n        description,\n      );\n    },\n\n    SetLocalDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_LOCAL_DESCRIPTION_FAILED,\n        'SetLocalDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set offer. `,\n        description,\n      );\n    },\n\n    SetRemoteDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_REMOTE_DESCRIPTION_FAILED,\n        'SetRemoteDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set answer. `,\n        description,\n        true,\n      );\n    },\n\n    ICEFailure(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.ICE_FAILURE,\n        'ICEFailure',\n        action,\n        `[${action.toString()}]: Ice connection state FAILED`,\n        description,\n      );\n    },\n\n    ICEDisconnected(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.ICE_DISCONNECTED,\n        'ICEDisconnected',\n        action,\n        `[${action.toString()}]: Ice connection state DISCONNECTED`,\n        description,\n      );\n    },\n\n    StatsFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.STATS_FAILED,\n        'StatsFailed',\n        action,\n        `Failed to WebRTC get stats - ${description}`,\n        description,\n      );\n    },\n  },\n\n  WebsocketMethodErrors: {\n    ServerErrors(code: number, action: HMSAction | HMSSignalMethod, description: string) {\n      return new HMSException(code, 'ServerErrors', action, description, description, terminalActions.includes(action));\n    },\n\n    AlreadyJoined(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.ALREADY_JOINED,\n        'AlreadyJoined',\n        action,\n        `[JOIN]: You have already joined this room.`,\n        description,\n      );\n    },\n\n    CannotJoinPreviewInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.CANNOT_JOIN_PREVIEW_IN_PROGRESS,\n        'CannotJoinPreviewInProgress',\n        action,\n        `[JOIN]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n  },\n\n  GenericErrors: {\n    NotConnected(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.NOT_CONNECTED,\n        'NotConnected',\n        action,\n        `Client is not connected`,\n        description,\n      );\n    },\n\n    Signalling(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.SIGNALLING,\n        'Signalling',\n        action,\n        `Unknown signalling error: ${action.toString()} ${description} `,\n        description,\n      );\n    },\n\n    Unknown(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.UNKNOWN,\n        'Unknown',\n        action,\n        `Unknown exception: ${description}`,\n        description,\n      );\n    },\n\n    NotReady(action: HMSAction, description = '') {\n      return new HMSException(ErrorCodes.GenericErrors.NOT_READY, 'NotReady', action, description, description);\n    },\n\n    JsonParsingFailed(action: HMSAction, jsonMessage: string, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.JSON_PARSING_FAILED,\n        'JsonParsingFailed',\n        action,\n        `Failed to parse JSON message - ${jsonMessage}`,\n        description,\n      );\n    },\n\n    TrackMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.TRACK_METADATA_MISSING,\n        'TrackMetadataMissing',\n        action,\n        `Track Metadata Missing`,\n        description,\n      );\n    },\n\n    RTCTrackMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.RTC_TRACK_MISSING,\n        'RTCTrackMissing',\n        action,\n        `RTC Track missing`,\n        description,\n      );\n    },\n\n    PeerMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PEER_METADATA_MISSING,\n        'PeerMetadataMissing',\n        action,\n        `Peer Metadata Missing`,\n        description,\n      );\n    },\n\n    ValidationFailed(message: string, entity?: any) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'ValidationFailed',\n        HMSAction.VALIDATION,\n        message,\n        entity ? JSON.stringify(entity) : '',\n      );\n    },\n\n    InvalidRole(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'InvalidRole',\n        action,\n        `Invalid role. Join with valid role`,\n        description,\n        true,\n      );\n    },\n\n    PreviewAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PREVIEW_IN_PROGRESS,\n        'PreviewAlreadyInProgress',\n        action,\n        `[Preview]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n\n    MissingMediaDevices() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_MEDIADEVICES,\n        'MissingMediaDevices',\n        HMSAction.JOIN,\n        `navigator.mediaDevices is undefined. 100ms SDK won't work on this website as WebRTC is not supported on HTTP endpoints(missing navigator.mediaDevices). Please ensure you're using the SDK either on localhost or a valid HTTPS endpoint.`,\n        '',\n        true,\n      );\n    },\n\n    MissingRTCPeerConnection() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_RTCPEERCONNECTION,\n        'MissingRTCPeerConnection',\n        HMSAction.JOIN,\n        `RTCPeerConnection which is a core requirement for WebRTC call was not found, this could be due to an unsupported browser or browser extensions blocking WebRTC`,\n        '',\n        true,\n      );\n    },\n  },\n\n  MediaPluginErrors: {\n    PlatformNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7001,\n        'PlatformNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported platforms',\n        description,\n      );\n    },\n\n    InitFailed(action: HMSAction, description = '') {\n      return new HMSException(7002, 'InitFailed', action, 'Plugin init failed', description);\n    },\n\n    ProcessingFailed(action: HMSAction, description = '') {\n      return new HMSException(7003, 'ProcessingFailed', action, 'Plugin processing failed', description);\n    },\n\n    AddAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(7004, 'AddAlreadyInProgress', action, 'Plugin add already in progress', description);\n    },\n\n    DeviceNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7005,\n        'DeviceNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported devices',\n        description,\n      );\n    },\n  },\n\n  PlaylistErrors: {\n    NoEntryToPlay(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_TO_PLAY,\n        'NoEntryToPlay',\n        action,\n        'Reached end of playlist',\n        description,\n      );\n    },\n    NoEntryPlaying(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_IS_PLAYING,\n        'NoEntryIsPlaying',\n        action,\n        'No entry is playing at this time',\n        description,\n      );\n    },\n  },\n};\n", "import HMSLogger from './logger';\nimport { ErrorFactory } from '../error/ErrorFactory';\n\nconst TAG = `[VALIDATIONS]`;\n\n/**\n * Check only for presence(not truthy) of a value.\n * Use in places where 0, false need to be considered valid.\n */\nexport function isPresent(value: any) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * checks if RTCPeerConnection constructor is available\n */\nexport const validateRTCPeerConnection = () => {\n  if (!isPresent(RTCPeerConnection)) {\n    const error = ErrorFactory.GenericErrors.MissingRTCPeerConnection();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n\n/**\n * navigator.mediaDevices is undefined in insecure contexts served over HTTP protocol\n */\nexport const validateMediaDevicesExistence = () => {\n  if (!isPresent(navigator.mediaDevices)) {\n    const error = ErrorFactory.GenericErrors.MissingMediaDevices();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n", "import { ENV, isNode, parsedUserAgent } from './support';\nimport { isPresent } from './validations';\nimport { DomainCategory } from '../analytics/AnalyticsEventDomains';\nimport { domainCategory } from '../analytics/domain-analytics';\nimport { HMSFrameworkInfo } from '../interfaces';\n\nconst sdk_version = require('../../package.json').version;\n\ntype UserAgent = {\n  os: string;\n  os_version: string;\n  sdk: 'web';\n  sdk_version: string;\n  env: 'debug' | 'prod';\n  domain: DomainCategory;\n  is_prebuilt: boolean;\n  device_model?: string;\n  framework?: HMSFrameworkInfo['type'] | 'node';\n  framework_version?: HMSFrameworkInfo['version'];\n  framework_sdk_version?: HMSFrameworkInfo['sdkVersion'];\n};\n\nexport function createUserAgent(sdkEnv: ENV = ENV.PROD, frameworkInfo?: HMSFrameworkInfo): string {\n  const sdk = 'web';\n  const env = domainCategory !== DomainCategory.LOCAL && sdkEnv === ENV.PROD ? 'prod' : 'debug';\n\n  if (isNode) {\n    return convertObjectToString({\n      os: 'web_nodejs',\n      os_version: process.version,\n      sdk,\n      sdk_version,\n      env,\n      domain: domainCategory,\n      is_prebuilt: !!frameworkInfo?.isPrebuilt,\n      framework: 'node',\n      framework_version: process.version,\n      framework_sdk_version: frameworkInfo?.sdkVersion,\n    });\n  }\n\n  const parsedOs = parsedUserAgent.getOS();\n  const parsedDevice = parsedUserAgent.getDevice();\n  const parsedBrowser = parsedUserAgent.getBrowser();\n\n  const os = replaceSpaces(`web_${parsedOs.name}`);\n  const os_version = parsedOs.version || '';\n\n  const browser = replaceSpaces(`${parsedBrowser.name}_${parsedBrowser.version}`);\n  let device_model = browser;\n  if (parsedDevice.type) {\n    const deviceVendor = replaceSpaces(`${parsedDevice.vendor}_${parsedDevice.type}`);\n    device_model = `${deviceVendor}/${browser}`;\n  }\n\n  return convertObjectToString({\n    os,\n    os_version,\n    sdk,\n    sdk_version,\n    device_model,\n    env,\n    domain: domainCategory,\n    is_prebuilt: !!frameworkInfo?.isPrebuilt,\n    framework: frameworkInfo?.type,\n    framework_version: frameworkInfo?.version,\n    framework_sdk_version: frameworkInfo?.sdkVersion,\n  });\n}\n\nfunction replaceSpaces(s: string) {\n  return s.replace(/ /g, '_');\n}\n\nconst convertObjectToString = (object: UserAgent, delimiter = ',') =>\n  Object.keys(object)\n    .filter(key => isPresent(object[key as keyof UserAgent]))\n    .map(key => `${key}:${object[key as keyof UserAgent]}`)\n    .join(delimiter);\n", "import { PublishAnalyticPayload } from './publish-stats/interfaces';\nimport { AdditionalAnalyticsProperties } from './AdditionalAnalyticsProperties';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { IAnalyticsPropertiesProvider } from './IAnalyticsPropertiesProvider';\nimport { HMSException } from '../error/HMSException';\nimport { DeviceMap, SelectedDevices } from '../interfaces';\nimport { HMSTrackSettings } from '../media/settings/HMSTrackSettings';\nimport { HMSRemoteVideoTrack } from '../media/tracks';\n\nexport default class AnalyticsEventFactory {\n  private static KEY_REQUESTED_AT = 'requested_at';\n  private static KEY_RESPONDED_AT = 'responded_at';\n\n  static connect(\n    error?: Error,\n    additionalProperties?: AdditionalAnalyticsProperties,\n    requestedAt: Date = new Date(),\n    respondedAt: Date = new Date(),\n    endpoint?: string,\n  ) {\n    const name = this.eventNameFor('connect', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError(\n      {\n        ...additionalProperties,\n        [this.KEY_REQUESTED_AT]: requestedAt?.getTime(),\n        [this.KEY_RESPONDED_AT]: respondedAt?.getTime(),\n        endpoint,\n      },\n      error,\n    );\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static disconnect(error?: Error, additionalProperties?: AdditionalAnalyticsProperties) {\n    const name = 'disconnected';\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(additionalProperties, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static preview({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_audio_track_time?: number;\n    local_video_track_time?: number;\n  }) {\n    const name = this.eventNameFor('preview', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(props, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static join({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    is_preview_called?: boolean;\n    start?: Date;\n    end?: Date;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_audio_track_time?: number;\n    local_video_track_time?: number;\n    retries_join?: number;\n  }) {\n    const name = this.eventNameFor('join', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError({ ...props, is_preview_called: !!props.is_preview_called }, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static publish({ devices, settings, error }: { devices?: DeviceMap; settings?: HMSTrackSettings; error?: Error }) {\n    const name = this.eventNameFor('publish', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(\n      {\n        devices,\n        audio: settings?.audio,\n        video: settings?.video,\n      },\n      error,\n    );\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static hlsPlayerError(error: HMSException) {\n    return new AnalyticsEvent({\n      name: 'hlsPlayerError',\n      level: AnalyticsEventLevel.ERROR,\n      properties: this.getErrorProperties(error),\n    });\n  }\n  static subscribeFail(error: Error) {\n    const name = this.eventNameFor('subscribe', false);\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = this.getErrorProperties(error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static leave() {\n    return new AnalyticsEvent({ name: 'leave', level: AnalyticsEventLevel.INFO });\n  }\n\n  static autoplayError() {\n    return new AnalyticsEvent({ name: 'autoplayError', level: AnalyticsEventLevel.ERROR });\n  }\n\n  static audioPlaybackError(error: HMSException) {\n    return new AnalyticsEvent({\n      name: 'audioPlaybackError',\n      level: AnalyticsEventLevel.ERROR,\n      properties: this.getErrorProperties(error),\n    });\n  }\n\n  static deviceChange({\n    selection,\n    type,\n    devices,\n    error,\n  }: {\n    selection: Partial<SelectedDevices>;\n    type?: 'change' | 'list' | 'audioInput' | 'audioOutput' | 'video';\n    devices: DeviceMap;\n    error?: Error;\n  }) {\n    const name = this.eventNameFor(error ? 'publish' : `device.${type}`, error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError({ selection, devices }, error);\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static performance(stats: IAnalyticsPropertiesProvider) {\n    const name = 'perf.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static rtcStats(stats: IAnalyticsPropertiesProvider) {\n    const name = 'rtc.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static rtcStatsFailed(error: HMSException) {\n    const name = 'rtc.stats.failed';\n    const level = AnalyticsEventLevel.ERROR;\n\n    return new AnalyticsEvent({ name, level, properties: this.getErrorProperties(error) });\n  }\n\n  /**\n   * TODO: remove once everything is switched to server side degradation, this\n   * event can be handled on server side as well.\n   */\n  static degradationStats(track: HMSRemoteVideoTrack, isDegraded: boolean) {\n    const name = 'video.degradation.stats';\n    const level = AnalyticsEventLevel.INFO;\n    let properties: any = {\n      degradedAt: track.degradedAt,\n      trackId: track.trackId,\n    };\n\n    if (!isDegraded && track.degradedAt instanceof Date) {\n      // not degraded => restored\n      const restoredAt = new Date();\n      const duration = restoredAt.valueOf() - track.degradedAt.valueOf();\n      properties = { ...properties, duration, restoredAt };\n    }\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioDetectionFail(error: Error, device?: MediaDeviceInfo): AnalyticsEvent {\n    const properties = this.getPropertiesWithError({ device }, error);\n    const level = AnalyticsEventLevel.ERROR;\n    const name = 'audiopresence.failed';\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static previewNetworkQuality(properties: { downLink?: string; score?: number; error?: string }) {\n    return new AnalyticsEvent({\n      name: 'perf.networkquality.preview',\n      level: properties.error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO,\n      properties,\n    });\n  }\n\n  static publishStats(properties: PublishAnalyticPayload) {\n    return new AnalyticsEvent({\n      name: 'publisher.stats',\n      level: AnalyticsEventLevel.INFO,\n      properties,\n    });\n  }\n\n  private static eventNameFor(name: string, ok: boolean) {\n    const suffix = ok ? 'success' : 'failed';\n    return `${name}.${suffix}`;\n  }\n\n  private static getPropertiesWithError(initialProperties: any, error?: Error) {\n    const errorProperties = this.getErrorProperties(error);\n    initialProperties = { ...errorProperties, ...initialProperties };\n    return initialProperties;\n  }\n\n  private static getErrorProperties(error?: Error): Record<string, any> {\n    if (error) {\n      return error instanceof HMSException\n        ? error.toAnalyticsProperties()\n        : {\n            error_name: error.name,\n            error_message: error.message,\n            error_description: error.cause,\n          };\n    } else {\n      return {};\n    }\n  }\n}\n", "import HMSLogger from '../utils/logger';\n\nexport type TimedEventName = 'init' | 'websocket-open' | 'on-policy-change' | 'local-tracks' | 'preview' | 'join';\n\nexport enum TimedEvent {\n  INIT = 'init_response_time',\n  WEBSOCKET_CONNECT = 'ws_connect_time',\n  ON_POLICY_CHANGE = 'on_policy_change_time',\n  LOCAL_AUDIO_TRACK = 'local_audio_track_time',\n  LOCAL_VIDEO_TRACK = 'local_video_track_time',\n  JOIN = 'join_time',\n  PREVIEW = 'preview_time',\n  PEER_LIST = 'peer_list_time',\n  ROOM_STATE = 'room_state_time',\n  JOIN_RESPONSE = 'join_response_time',\n  GET_TOKEN = 'GET_TOKEN',\n}\n\nconst defaultEventNames = [\n  TimedEvent.INIT,\n  TimedEvent.WEBSOCKET_CONNECT,\n  TimedEvent.ON_POLICY_CHANGE,\n  TimedEvent.LOCAL_AUDIO_TRACK,\n  TimedEvent.LOCAL_VIDEO_TRACK,\n  TimedEvent.PEER_LIST,\n  TimedEvent.ROOM_STATE,\n  TimedEvent.JOIN_RESPONSE,\n];\n\nexport class AnalyticsTimer {\n  private eventPerformanceMeasures: Partial<Record<TimedEvent, PerformanceMeasure>> = {};\n\n  start(eventName: TimedEvent) {\n    performance.mark(eventName);\n  }\n\n  end(eventName: TimedEvent) {\n    try {\n      this.eventPerformanceMeasures[eventName] = performance.measure(eventName, eventName);\n      HMSLogger.d('[HMSPerformanceTiming]', eventName, this.eventPerformanceMeasures[eventName]?.duration);\n    } catch (error) {\n      HMSLogger.w('[AnalyticsTimer]', `Error in measuring performance for event ${eventName}`, { error });\n    }\n  }\n\n  getTimeTaken(eventName: TimedEvent) {\n    return this.eventPerformanceMeasures[eventName]?.duration;\n  }\n\n  getTimes(...eventNames: TimedEvent[]) {\n    return [...defaultEventNames, ...eventNames].reduce(\n      (timeObject, eventName) => ({ ...timeObject, [eventName]: this.getTimeTaken(eventName) }),\n      {},\n    );\n  }\n\n  cleanup() {\n    this.eventPerformanceMeasures = {};\n  }\n}\n", "import adapter from 'webrtc-adapter';\nimport { ErrorFactory } from './ErrorFactory';\nimport { HMSAction } from './HMSAction';\nimport { HMSException } from './HMSException';\n\nexport enum HMSGetMediaActions {\n  UNKNOWN = 'unknown(video or audio)',\n  AUDIO = 'audio',\n  VIDEO = 'video',\n  AV = 'audio, video',\n  SCREEN = 'screen',\n}\n\nfunction getDefaultError(error: string, deviceInfo: string) {\n  const message = error.toLowerCase();\n  if (message.includes('device not found')) {\n    return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, error);\n  } else if (message.includes('permission denied')) {\n    return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, error);\n  } else {\n    return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, error);\n  }\n}\n\n/**\n * # Edge Cases:\n * - Screenshare error: The problem is when block at OS level, chrome throws NotAllowedError(HMS code - 3001) while firefox throws NotFoundError(HMS code - 3002),\n * we will handle this internally and throw error as User block - 3001 and OS block - 3011 for all browsers.\n * Chrome -\n * User blocked - NotAllowedError - Permission denied\n * System blocked - NotAllowedError - Permission denied by system\n */\n// eslint-disable-next-line complexity\nfunction convertMediaErrorToHMSException(err: Error, deviceInfo = ''): HMSException {\n  /**\n   * Note: Adapter detects all chromium browsers as 'chrome'\n   */\n  const chromeSystemDenied =\n    adapter.browserDetails.browser === 'chrome' &&\n    err.name === 'NotAllowedError' &&\n    err.message.includes('denied by system');\n\n  if (chromeSystemDenied) {\n    return ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n  }\n\n  if (adapter.browserDetails.browser === 'firefox' && err.name === 'NotFoundError') {\n    const hmsError = ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n    hmsError.description = `Capture device is either blocked at Operating System level or not available - ${deviceInfo}`;\n    return hmsError;\n  }\n\n  switch (err.name) {\n    case 'OverconstrainedError':\n      return ErrorFactory.TracksErrors.OverConstrained(\n        HMSAction.TRACK,\n        deviceInfo,\n        (err as OverconstrainedError).constraint,\n      );\n    case 'NotAllowedError':\n      return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotFoundError':\n      return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotReadableError':\n      return ErrorFactory.TracksErrors.DeviceInUse(HMSAction.TRACK, deviceInfo, err.message);\n    case 'TypeError':\n      return ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK, err.message);\n    default:\n      return getDefaultError(err.message, deviceInfo);\n  }\n}\n\nexport function BuildGetMediaError(err: Error, deviceInfo: string): HMSException {\n  const exception = convertMediaErrorToHMSException(err, deviceInfo);\n  exception.addNativeError(err);\n  return exception;\n}\n", "import adapter from 'webrtc-adapter';\nimport './utils/local-storage-polyfill';\nimport HMSLogger from './utils/logger';\nconst sdk_version = require('../package.json').version;\n\nHMSLogger.d('adapter', `${adapter.browserDetails.browser} v${adapter.browserDetails.version}`);\nHMSLogger.d('sdk version', sdk_version);\n\nexport * from './media/streams';\nexport * from './media/tracks';\nexport * from './utils/media';\nexport * from './utils/device-error';\nexport * from './utils/support';\nexport * from './error/HMSException';\nexport * from './interfaces';\nexport * from './rtc-stats';\nexport * from './plugins';\nexport * from './utils/logger';\n", "import { HMSTrack } from '../tracks';\n\nexport class HMSMediaStream {\n  readonly nativeStream: MediaStream;\n  id: string;\n\n  readonly tracks = new Array<HMSTrack>();\n\n  constructor(nativeStream: MediaStream) {\n    this.nativeStream = nativeStream;\n    this.id = nativeStream.id;\n  }\n\n  /**\n   * This is only used when onDemandTracks flag is enabled in Init\n   * @param id\n   */\n  updateId(id: string) {\n    this.id = id;\n  }\n}\n", "export const stringifyMediaStreamTrack = (track: MediaStreamTrack) => {\n  if (!track) {\n    return '';\n  }\n  return `{\n    trackId: ${track.id};\n    kind: ${track.kind};\n    enabled: ${track.enabled};\n    muted: ${track.muted};\n    readyState: ${track.readyState};\n  }`;\n};\n", "import { HMSTrackType } from './HMSTrackType';\nimport { stringifyMediaStreamTrack } from '../../utils/json';\nimport HMSLogger from '../../utils/logger';\nimport { HMSMediaStream } from '../streams';\n\nexport type HMSTrackSource = 'regular' | 'screen' | 'plugin' | 'audioplaylist' | 'videoplaylist' | string;\n\nexport abstract class HMSTrack {\n  /**\n   * @internal\n   */\n  readonly stream: HMSMediaStream;\n  source?: HMSTrackSource;\n  peerId?: string;\n  transceiver?: RTCRtpTransceiver;\n\n  /**\n   * @internal to print as a helpful identifier alongside logs\n   */\n  logIdentifier = '';\n\n  /** The native mediastream track, for local, this changes on mute/unmute(for video),\n   * and on device change.\n   * @internal */\n  nativeTrack: MediaStreamTrack;\n\n  /**\n   * Firefox doesn't respect the track id as sent from the backend when calling peerconnection.ontrack callback. This\n   * breaks correlation of future track updates from backend. So we're storing the sdp track id as present in the\n   * original offer along with the track as well and will let this override the native track id for any correlation\n   * purpose.\n   * This applies for remote tracks only.\n   * @internal */\n  private sdpTrackId?: string;\n\n  /**\n   * @internal\n   * The local track id is changed on mute/unmute or when device id changes, this is abstracted as an internal\n   * detail of HMSTrack and the variable is used for this enacapsulation where the first track id is remembered\n   * and treated as the fixed track id for this HMSTrack. This simplifies things for the user of the sdk who\n   * do not have to worry about changing track IDs.\n   * This applies for local tracks only.\n   */\n  private firstTrackId?: string;\n\n  abstract readonly type: HMSTrackType;\n\n  public get enabled(): boolean {\n    return this.nativeTrack.enabled;\n  }\n\n  /**\n   * firstTrackId => encapsulates change in local track ids\n   * sdpTrackId => fixes remote track updates correlation on firefox\n   */\n  public get trackId(): string {\n    return this.firstTrackId || this.sdpTrackId || this.nativeTrack.id;\n  }\n\n  getMediaTrackSettings(): MediaTrackSettings {\n    return this.nativeTrack.getSettings();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    this.nativeTrack.enabled = value;\n  }\n\n  protected constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: HMSTrackSource) {\n    this.stream = stream;\n    this.nativeTrack = track;\n    this.source = source;\n  }\n\n  /**\n   * @internal\n   */\n  setSdpTrackId(sdpTrackId: string) {\n    this.sdpTrackId = sdpTrackId;\n  }\n\n  /**\n   * @internal\n   */\n  protected setFirstTrackId(trackId: string) {\n    this.firstTrackId = trackId;\n  }\n\n  /**\n   * @internal\n   * take care of -\n   * 1. https://bugs.chromium.org/p/chromium/issues/detail?id=1232649\n   * 2. stopping any tracks\n   * 3. plugins related cleanups and stopping\n   */\n  cleanup() {\n    HMSLogger.d('[HMSTrack]', 'Stopping track', this.toString());\n    this.nativeTrack?.stop();\n  }\n\n  toString() {\n    return `{\n      streamId: ${this.stream.id};\n      peerId: ${this.peerId};\n      trackId: ${this.trackId};\n      mid: ${this.transceiver?.mid || '-'};\n      logIdentifier: ${this.logIdentifier};\n      source: ${this.source};\n      enabled: ${this.enabled};\n      nativeTrack: ${stringifyMediaStreamTrack(this.nativeTrack)};\n    }`;\n  }\n}\n", "export enum HMSTrackType {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSLogger from '../../utils/logger';\nimport { HMSMediaStream, HMSRemoteStream } from '../streams';\n\nexport class HMSAudioTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.AUDIO;\n  private audioElement: HTMLAudioElement | null = null;\n  private outputDevice?: MediaDeviceInfo;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'audio') {\n      throw new Error(\"Expected 'track' kind = 'audio'\");\n    }\n  }\n\n  getVolume() {\n    return this.audioElement ? this.audioElement.volume * 100 : null;\n  }\n\n  async setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    // Don't subscribe to audio when volume is 0\n    await this.subscribeToAudio(value === 0 ? false : this.enabled);\n    if (this.audioElement) {\n      this.audioElement.volume = value / 100;\n    }\n  }\n\n  setAudioElement(element: HTMLAudioElement | null) {\n    HMSLogger.d('[HMSAudioTrack]', this.logIdentifier, 'adding audio element', `${this}`, element);\n    this.audioElement = element;\n  }\n\n  /**\n   * @internal\n   * @returns {HTMLAudioElement | null}\n   */\n  getAudioElement(): HTMLAudioElement | null {\n    return this.audioElement;\n  }\n\n  getOutputDevice() {\n    return this.outputDevice;\n  }\n\n  cleanup() {\n    super.cleanup();\n    if (this.audioElement) {\n      this.audioElement.srcObject = null;\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n  }\n\n  async setOutputDevice(device?: MediaDeviceInfo) {\n    if (!device) {\n      HMSLogger.d('[HMSAudioTrack]', this.logIdentifier, 'device is null', `${this}`);\n      return;\n    }\n    if (!this.audioElement) {\n      HMSLogger.d('[HMSAudioTrack]', this.logIdentifier, 'no audio element to set output', `${this}`);\n      this.outputDevice = device;\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (typeof this.audioElement.setSinkId === 'function') {\n        // @ts-ignore\n        await this.audioElement?.setSinkId(device.deviceId);\n        this.outputDevice = device;\n      }\n    } catch (error) {\n      HMSLogger.d('[HMSAudioTrack]', 'error in setSinkId', error);\n    }\n  }\n\n  protected async subscribeToAudio(value: boolean) {\n    if (this.stream instanceof HMSRemoteStream) {\n      await this.stream.setAudio(value, this.trackId, this.logIdentifier);\n    }\n  }\n}\n", "import { DeviceMap, SelectedDevices } from '../interfaces';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\n\ntype DeviceInfo = { deviceId?: string; groupId?: string };\n/**\n * This class is to manage storing and retrieving selected devices\n * from localstorage\n * @internal\n */\nclass DeviceStorage {\n  private storage = new LocalStorage<SelectedDevices>('hms-device-selection');\n  private remember = false;\n  private devices?: DeviceMap;\n  private readonly TAG = '[HMSDeviceStorage]';\n\n  setDevices(devices: DeviceMap) {\n    this.devices = devices;\n  }\n\n  rememberDevices(value: boolean) {\n    this.remember = value;\n  }\n\n  /**\n   * This will update the passed in type value in storage\n   * @param {string} type - One of audioInput | videoInput | audioOutput\n   * @param {DeviceInfo} param\n   * @returns {void}\n   */\n  updateSelection(type: 'audioInput' | 'videoInput' | 'audioOutput', { deviceId, groupId }: DeviceInfo) {\n    if (!this.devices || !this.remember) {\n      return;\n    }\n    const newSelection = this.devices[type].find(device => this.isSame({ deviceId, groupId }, device));\n    if (!newSelection) {\n      HMSLogger.w(this.TAG, `Could not find device with deviceId: ${deviceId}, groupId: ${groupId}`);\n      return;\n    }\n    const selectedDevices = this.storage.get() || {};\n    if (type === 'audioOutput') {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    } else {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    }\n    this.storage.set(selectedDevices);\n  }\n\n  getSelection() {\n    if (!this.remember) {\n      return undefined;\n    }\n    return this.storage.get();\n  }\n\n  cleanup() {\n    this.remember = false;\n    this.devices = undefined;\n  }\n\n  private isSame(current: DeviceInfo, device: DeviceInfo) {\n    // Safari doesn't give groupId from nativeTrack. Check if groupId's match or current groupId is not present\n    return current.deviceId === device.deviceId && (current.groupId === device.groupId || !current.groupId);\n  }\n}\n\nexport const DeviceStorageManager = new DeviceStorage();\n", "/**\n * A plugin implementing this interface can be registered with HMSLocalAudioTrack to transform, process or\n * analyze the local audio track.These can include applications like background noise removal, speech commands, live\n * analysis of audio etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\n\nexport interface HMSAudioPlugin {\n  /**\n   * This function will be called by the SDK for audio track which the plugin needs to process.\n   * The reason audio context is also part of the interface is that it's recommeneded to reuse on audio context\n   * instead of creating new for every use - https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n   */\n  processAudioTrack(ctx: AudioContext, source: AudioNode): Promise<AudioNode>;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS, browser and audio device or not. An error object will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(ctx?: AudioContext): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processAudio is called.\n   */\n  init(): Promise<void> | void;\n\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   This sets the Plugin type @see HMSAudioPluginType, processing will happen\n   based on the type of plugin\n   */\n  getPluginType(): HMSAudioPluginType;\n  /*\n   * the plugin can use this function to dispose off its resources. It'll be called when the plugin instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output audio node to give the resulting\n * transformation. While an analyzing plugin will only be passed the input node.\n * For analyse plugins, you can return the source node passed to plugin.processTrack to not modify anything\n */\nexport enum HMSAudioPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport interface HMSPluginSupportResult {\n  isSupported: boolean;\n  errType?: HMSPluginUnsupportedTypes;\n  errMsg?: string;\n}\n\nexport enum HMSPluginUnsupportedTypes {\n  PLATFORM_NOT_SUPPORTED = 'PLATFORM_NOT_SUPPORTED',\n  DEVICE_NOT_SUPPORTED = 'DEVICE_NOT_SUPPORTED',\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { HMSException } from '../error/HMSException';\n\nexport default class MediaPluginsAnalyticsFactory {\n  static failure(pluginName: string, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginFailure(pluginName: string, sampleRate: number, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, sampleRate: sampleRate, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginStats({\n    pluginName,\n    duration,\n    loadTime,\n    sampleRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    sampleRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      sampleRate: sampleRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static stats({\n    pluginName,\n    duration,\n    loadTime,\n    avgPreProcessingTime,\n    avgProcessingTime,\n    inputFrameRate,\n    pluginFrameRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    avgPreProcessingTime: number;\n    avgProcessingTime: number;\n    inputFrameRate: number;\n    pluginFrameRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      avg_preprocessing_time: avgPreProcessingTime,\n      avg_processing_time: avgProcessingTime,\n      input_frame_rate: inputFrameRate,\n      plugin_frame_rate: pluginFrameRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n}\n", "import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport HMSLogger from '../../utils/logger';\n\nexport class AudioPluginsAnalytics {\n  private readonly TAG = '[AudioPluginsAnalytics]';\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginSampleRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.addedTimestamps = {};\n    this.pluginAdded = {};\n    this.pluginSampleRate = {};\n  }\n\n  added(name: string, sampleRate: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.pluginSampleRate[name] = sampleRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        sampleRate: this.pluginSampleRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.audioPluginStats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(\n        MediaPluginsAnalyticsFactory.audioPluginFailure(name, this.pluginSampleRate[name], error),\n      );\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(this.TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(this.TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.AUDIO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.pluginAdded[name];\n    delete this.pluginSampleRate[name];\n  }\n}\n", "import { AudioPluginsAnalytics } from './AudioPluginsAnalytics';\nimport { HMSAudioPlugin, HMSPluginUnsupportedTypes } from './HMSAudioPlugin'; //HMSAudioPluginType\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSLocalAudioTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\n\nconst DEFAULT_SAMPLE_RATE = 48000;\n\n//Handling sample rate error in case of firefox\nconst checkBrowserSupport = () => {\n  return navigator.userAgent.indexOf('Firefox') !== -1;\n};\n\n/**\n * This class manages applying different plugins on a local audio track. Plugins which need to modify the audio\n * are called in the order they were added. Plugins which do not need to modify the audio are called\n * with the original input.\n *\n * Concepts -\n * Audio Plugin - A module which can take in input audio, do some processing on it and return an AudioNode\n *\n * For Each Plugin, an AudioNode will be created and the source will be created from local audio track.\n * Each Audio node will be connected in the following order\n * source -> first plugin -> second plugin -> third plugin .. so on\n * @see HMSAudioPlugin\n */\nexport class HMSAudioPluginsManager {\n  private readonly TAG = '[AudioPluginsManager]';\n  private readonly hmsTrack: HMSLocalAudioTrack;\n  // Map maintains the insertion order\n  private readonly pluginsMap: Map<string, HMSAudioPlugin>;\n  private audioContext?: AudioContext;\n\n  private sourceNode?: MediaStreamAudioSourceNode;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private prevAudioNode?: any;\n  private analytics: AudioPluginsAnalytics;\n  // This will replace the native track in peer connection when plugins are enabled\n  private outputTrack?: MediaStreamTrack;\n  private pluginAddInProgress = false;\n\n  constructor(track: HMSLocalAudioTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.analytics = new AudioPluginsAnalytics(eventBus);\n    this.createAudioContext();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  async addPlugin(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!name) {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginAddInProgress) {\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.AUDIO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      this.analytics.failure(name, err);\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  private async addPluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} already added.`);\n      return;\n    }\n\n    await this.validateAndThrow(name, plugin);\n\n    try {\n      if (this.pluginsMap.size === 0) {\n        await this.initAudioNodes();\n      } else if (this.prevAudioNode) {\n        // Previous node will be connected to destination. Disconnect that\n        this.prevAudioNode.disconnect();\n      }\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      await this.analytics.initWithTime(name, async () => plugin.init());\n      this.pluginsMap.set(name, plugin);\n      await this.processPlugin(plugin);\n      await this.connectToDestination();\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to add plugin', err);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSAudioPlugin) {\n    return plugin.checkSupport(this.audioContext);\n  }\n\n  async validateAndThrow(name: string, plugin: HMSAudioPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(this.TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      //Needed to re-add in the reprocess case, to send error message in case of failure\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      if (result.errType === HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'platform not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      } else if (result.errType === HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'audio device not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSAudioPlugin) {\n    await this.removePluginInternal(plugin);\n    if (this.pluginsMap.size === 0) {\n      // remove all previous nodes\n      await this.cleanup();\n      HMSLogger.i(this.TAG, `No plugins left, stopping plugins loop`);\n      await this.hmsTrack.setProcessedTrack(undefined);\n    } else {\n      // Reprocess the remaining plugins again because there is no way to connect\n      // the source of the removed plugin to destination of removed plugin\n      await this.reprocessPlugins();\n    }\n  }\n\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePluginInternal(plugin);\n    }\n    await this.hmsTrack.setProcessedTrack(undefined);\n    //disconnect nodes, stop track\n    this.sourceNode?.disconnect();\n    this.prevAudioNode?.disconnect();\n    this.outputTrack?.stop();\n\n    // reset all variables\n    this.sourceNode = undefined;\n    this.destinationNode = undefined;\n    this.prevAudioNode = undefined;\n    this.outputTrack = undefined;\n  }\n\n  //Keeping it separate since we are initializing context only once\n  async closeContext() {\n    this.audioContext?.close();\n    this.audioContext = undefined;\n  }\n\n  async reprocessPlugins() {\n    if (this.pluginsMap.size === 0 || !this.sourceNode) {\n      return;\n    }\n    const plugins = Array.from(this.pluginsMap.values()); // make a copy of plugins\n    await this.cleanup();\n    await this.initAudioNodes();\n    for (const plugin of plugins) {\n      await this.addPlugin(plugin);\n    }\n  }\n\n  private async initAudioNodes() {\n    if (this.audioContext) {\n      if (!this.sourceNode) {\n        const audioStream = new MediaStream([this.hmsTrack.nativeTrack]);\n        this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);\n      }\n      if (!this.destinationNode) {\n        this.destinationNode = this.audioContext.createMediaStreamDestination();\n        this.outputTrack = this.destinationNode.stream.getAudioTracks()[0];\n        try {\n          await this.hmsTrack.setProcessedTrack(this.outputTrack);\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'error in setting processed track', err);\n          throw err;\n        }\n      }\n    }\n  }\n\n  private async processPlugin(plugin: HMSAudioPlugin) {\n    try {\n      const currentNode = await plugin.processAudioTrack(\n        this.audioContext!, // it is always present at this point\n        this.prevAudioNode || this.sourceNode,\n      );\n      if (this.prevAudioNode) {\n        // if previous node was present while adding this plugin\n        // it is disconnected from destination, connect the previous node to\n        // to the current node\n        this.prevAudioNode.connect(currentNode);\n      }\n      this.prevAudioNode = currentNode;\n    } catch (err) {\n      const name = plugin.getName();\n      //TODO error happened on processing of plugin notify UI\n      HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n      //remove plugin from loop and stop analytics for it\n      await this.removePluginInternal(plugin);\n    }\n  }\n\n  private async connectToDestination() {\n    try {\n      if (this.prevAudioNode && this.destinationNode && this.prevAudioNode.context === this.destinationNode.context) {\n        this.prevAudioNode.connect(this.destinationNode);\n      }\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'error in connecting to destination node', err);\n    }\n  }\n\n  private async removePluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(this.TAG, `removing plugin ${name}`);\n    this.pluginsMap.delete(name);\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  private createAudioContext() {\n    if (!this.audioContext) {\n      if (checkBrowserSupport()) {\n        /**\n        Not setting default sample rate for firefox since connecting\n        audio nodes from context with different sample rate is not\n        supported in firefox\n */\n        this.audioContext = new AudioContext();\n      } else {\n        this.audioContext = new AudioContext({ sampleRate: DEFAULT_SAMPLE_RATE });\n      }\n    }\n  }\n}\n", "import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { HMSAudioTrackSettings, HMSVideoTrackSettings } from '../media/settings';\n\nexport async function getAudioTrack(settings: HMSAudioTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: settings ? settings.toConstraints() : false,\n    });\n    return stream.getAudioTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AUDIO);\n  }\n}\n\nexport async function getVideoTrack(settings: HMSVideoTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: settings ? settings.toConstraints() : false,\n    });\n    return stream.getVideoTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.VIDEO);\n  }\n}\n\n// To differentiate between normal track and empty track.\nexport function isEmptyTrack(track: MediaStreamTrack) {\n  // Firefox gives '' as label for empty track(created from audio context)\n  return 'canvas' in track || track.label === 'MediaStreamAudioDestinationNode' || track.label === '';\n}\n", "import HMSLogger from './logger';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\n\nexport async function getLocalStream(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport async function getLocalScreen(constraints: MediaStreamConstraints['video']): Promise<MediaStream> {\n  try {\n    // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: constraints, audio: false });\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n  }\n}\n\ninterface MediaDeviceGroups {\n  audioinput: MediaDeviceInfo[];\n  audiooutput: MediaDeviceInfo[];\n  videoinput: MediaDeviceInfo[];\n}\n\nexport async function getLocalDevices(): Promise<MediaDeviceGroups> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const deviceGroups: MediaDeviceGroups = {\n      audioinput: [],\n      audiooutput: [],\n      videoinput: [],\n    };\n    devices.forEach(device => deviceGroups[device.kind].push(device));\n    return deviceGroups;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport interface HMSAudioContext {\n  audioContext: AudioContext | null;\n  getAudioContext: () => AudioContext;\n  resumeContext: () => Promise<void>;\n}\n\nexport const HMSAudioContextHandler: HMSAudioContext = {\n  audioContext: null,\n  getAudioContext() {\n    if (!this.audioContext) {\n      this.audioContext = new AudioContext();\n    }\n    return this.audioContext;\n  },\n  async resumeContext() {\n    try {\n      return await this.getAudioContext().resume();\n    } catch (error) {\n      HMSLogger.e('AudioContext', error);\n    }\n  },\n};\n", "export interface IQueue<T> {\n  size(): number;\n  enqueue(item: T): void;\n  dequeue(): T | undefined;\n}\n\nexport class Queue<T> implements IQueue<T> {\n  protected storage: T[] = [];\n\n  constructor(private capacity: number = Infinity) {}\n\n  size() {\n    return this.storage.length;\n  }\n\n  toList() {\n    return this.storage.slice(0);\n  }\n\n  enqueue(item: T) {\n    if (this.size() === this.capacity) {\n      this.dequeue();\n    }\n    this.storage.push(item);\n  }\n\n  dequeue() {\n    return this.storage.shift();\n  }\n\n  aggregate<R>(aggregationFn: (values: T[]) => R): R {\n    return aggregationFn(this.storage);\n  }\n}\n", "/**\n * Delay for a @see ms amount of time\n * @param ms -- time in milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  if (ms < 0) {\n    throw Error('`ms` should be a positive integer');\n  }\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Debounce Fn - Function to limit the number of executions of the passed in\n * function in a given time duration\n * @param fn Function to be called\n * @param delay time by which the function execution has to be delayed\n * @returns {void}\n */\nexport function debounce<T extends (...args: any) => any>(fn: T, delay = 300) {\n  let timer: any | undefined;\n  return function (...args: []) {\n    clearTimeout(timer);\n    timer = undefined;\n    //@ts-ignore\n    //eslint-disable-next-line\n    const context = this;\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n", "import HMSLogger from './logger';\nimport { HMSAudioContextHandler } from './media';\nimport { Queue } from './queue';\nimport { sleep } from './timer-utils';\nimport { HMSInternalEvent } from '../events/HMSInternalEvent';\nimport { HMSLocalAudioTrack } from '../internal';\n\n/** Send update only if audio level is above THRESHOLD */\nconst THRESHOLD = 35;\n\n/** Send update only if audio level is changed by UPDATE_THRESHOLD */\nconst UPDATE_THRESHOLD = 5;\n\nexport interface ITrackAudioLevelUpdate {\n  track: HMSLocalAudioTrack;\n  audioLevel: number;\n}\n\nexport class TrackAudioLevelMonitor {\n  private readonly TAG = '[TrackAudioLevelMonitor]';\n  private audioLevel = 0;\n  private analyserNode?: AnalyserNode;\n  private isMonitored = false;\n  /** Frequency of polling audio level from track */\n  private interval = 100;\n  /** Store past audio levels for this duration */\n  private historyInterval = 700;\n  private history = new Queue<number>(this.historyInterval / this.interval);\n\n  constructor(\n    private track: HMSLocalAudioTrack,\n    private audioLevelEvent: HMSInternalEvent<ITrackAudioLevelUpdate>,\n    private silenceEvent: HMSInternalEvent<{ track: HMSLocalAudioTrack }>,\n  ) {\n    try {\n      const stream = new MediaStream([this.track.nativeTrack]);\n      this.analyserNode = this.createAnalyserNodeForStream(stream);\n    } catch (ex) {\n      HMSLogger.w(this.TAG, 'Unable to initialize AudioContext', ex);\n    }\n  }\n\n  /**\n   * To detect silence we check if the track is unmuted and silent in the current moment\n   * periodically. If the track is found to be silent more than a threshold number of times\n   * we send the event. The threshold number of time is there to reduce the chance of false\n   * positives.\n   */\n  detectSilence = async () => {\n    const tickInterval = 20;\n    const tickThreshold = 50;\n    let silenceCounter = 0;\n\n    while (this.isMonitored) {\n      if (this.track.enabled) {\n        if (this.isSilentThisInstant()) {\n          silenceCounter++;\n          if (silenceCounter > tickThreshold) {\n            this.silenceEvent.publish({ track: this.track });\n            break;\n          }\n        } else {\n          // bail out immediately if sound is found\n          break;\n        }\n      }\n      await sleep(tickInterval);\n    }\n  };\n\n  start() {\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting track Monitor', `${this.track}`);\n    this.loop().then(() => HMSLogger.d(this.TAG, 'Stopping track Monitor', `${this.track}`));\n  }\n\n  stop() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    this.sendAudioLevel(0);\n    this.isMonitored = false;\n  }\n\n  private async loop() {\n    while (this.isMonitored) {\n      this.sendAudioLevel(this.getMaxAudioLevelOverPeriod());\n      await sleep(this.interval);\n    }\n  }\n\n  private sendAudioLevel(audioLevel = 0) {\n    audioLevel = audioLevel > THRESHOLD ? audioLevel : 0;\n    const isSignificantChange = Math.abs(this.audioLevel - audioLevel) > UPDATE_THRESHOLD;\n    if (isSignificantChange) {\n      this.audioLevel = audioLevel;\n      const audioLevelUpdate: ITrackAudioLevelUpdate = { track: this.track, audioLevel: this.audioLevel };\n      this.audioLevelEvent.publish(audioLevelUpdate);\n    }\n  }\n\n  private getMaxAudioLevelOverPeriod() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n    const newLevel = this.calculateAudioLevel();\n    newLevel !== undefined && this.history.enqueue(newLevel);\n    return this.history.aggregate(values => Math.max(...values));\n  }\n\n  private calculateAudioLevel() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n    const lowest = 0.009;\n    let max = lowest;\n    for (const frequency of data) {\n      max = Math.max(max, (frequency - 128) / 128);\n    }\n    const normalized = (Math.log(lowest) - Math.log(max)) / Math.log(lowest);\n    const percent = Math.ceil(Math.min(Math.max(normalized * 100, 0), 100));\n    return percent;\n  }\n\n  private isSilentThisInstant() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n\n    // For absolute silence(in case of mic/software failures), all frequencies are 128 or 0.\n    return !data.some(frequency => frequency !== 128 && frequency !== 0);\n  }\n\n  private createAnalyserNodeForStream(stream: MediaStream): AnalyserNode {\n    const audioContext = HMSAudioContextHandler.getAudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    return analyser;\n  }\n}\n", "import { HMSChangeMultiTrackStateRequest, HMSChangeTrackStateRequest } from './change-track-state';\nimport { DeviceChangeListener } from './devices';\nimport { HMSLeaveRoomRequest } from './leave-room-request';\nimport { HMSMessage } from './message';\nimport { HMSConnectionQuality } from './peer';\nimport { HMSRoleChangeRequest } from './role-change-request';\nimport { HMSRoom } from './room';\nimport { HMSPoll, SessionStoreUpdate } from './session-store';\nimport { HMSSpeaker } from './speaker';\nimport { HMSException } from '../error/HMSException';\nimport { HMSTrack } from '../media/tracks/HMSTrack';\nimport { HMSPeer } from '../sdk/models/peer';\n\nexport enum HMSRoomUpdate {\n  RECORDING_STATE_UPDATED = 'RECORDING_STATE_UPDATED',\n  BROWSER_RECORDING_STATE_UPDATED = 'BROWSER_RECORDING_STATE_UPDATED',\n  SERVER_RECORDING_STATE_UPDATED = 'SERVER_RECORDING_STATE_UPDATED',\n  RTMP_STREAMING_STATE_UPDATED = 'RTMP_STREAMING_STATE_UPDATED',\n  HLS_STREAMING_STATE_UPDATED = 'HLS_STREAMING_STATE_UPDATED',\n  ROOM_PEER_COUNT_UPDATED = 'ROOM_PEER_COUNT_UPDATED',\n}\n\nexport enum HMSPeerUpdate {\n  PEER_JOINED,\n  PEER_LEFT,\n  AUDIO_TOGGLED,\n  VIDEO_TOGGLED,\n  BECAME_DOMINANT_SPEAKER,\n  RESIGNED_DOMINANT_SPEAKER,\n  STARTED_SPEAKING,\n  STOPPED_SPEAKING,\n  ROLE_UPDATED,\n  PEER_LIST,\n  NAME_UPDATED,\n  METADATA_UPDATED,\n  HAND_RAISE_CHANGED,\n  PEER_REMOVED,\n  PEER_ADDED,\n}\n\nexport enum HMSTrackUpdate {\n  TRACK_ADDED,\n  TRACK_REMOVED,\n  TRACK_MUTED,\n  TRACK_UNMUTED,\n  TRACK_DESCRIPTION_CHANGED,\n  TRACK_DEGRADED,\n  TRACK_RESTORED,\n}\n\nexport enum HMSPollsUpdate {\n  POLL_CREATED,\n  POLL_STARTED,\n  POLL_STOPPED,\n  POLL_STATS_UPDATED,\n}\n\nexport interface HMSAudioListener {\n  onAudioLevelUpdate(speakers: HMSSpeaker[]): void;\n}\n\nexport interface HMSConnectionQualityListener {\n  onConnectionQualityUpdate(qualityUpdates: HMSConnectionQuality[]): void;\n}\n\nexport interface SessionStoreListener {\n  onSessionStoreUpdate(values: SessionStoreUpdate[]): void;\n}\n\nexport interface PollsListener {\n  onPollsUpdate(type: HMSPollsUpdate, polls: HMSPoll[]): void;\n}\n\nexport interface HMSUpdateListener extends DeviceChangeListener, SessionStoreListener, PollsListener {\n  onJoin(room: HMSRoom): void;\n  onRoomUpdate(type: HMSRoomUpdate, room: HMSRoom): void;\n  onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer | HMSPeer[] | null): void;\n  onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer): void;\n  onMessageReceived(message: HMSMessage): void;\n  onError(error: HMSException): void;\n  onReconnecting(error: HMSException): void;\n  onReconnected(): void;\n  onRoleChangeRequest(request: HMSRoleChangeRequest): void;\n  onRoleUpdate(newRole: string): void;\n  onChangeTrackStateRequest(request: HMSChangeTrackStateRequest): void;\n  onChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest): void;\n  onRemovedFromRoom(request: HMSLeaveRoomRequest): void;\n  onNetworkQuality?(score: number): void;\n  onPreview(room: HMSRoom, localTracks: HMSTrack[]): void;\n}\n", "export enum HMSSimulcastLayer {\n  NONE = 'none',\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n}\n\nexport interface SimulcastLayer {\n  rid: string;\n  scaleResolutionDownBy: number;\n  maxBitrate: number;\n  maxFramerate: number;\n}\n\nexport interface SimulcastResolution {\n  width: number;\n  height: number;\n}\n\nexport interface SimulcastLayers {\n  layers?: SimulcastLayer[];\n}\n\nexport type HMSPreferredSimulcastLayer = Exclude<HMSSimulcastLayer, HMSSimulcastLayer.NONE>;\nexport interface HMSSimulcastLayerDefinition {\n  layer: HMSPreferredSimulcastLayer;\n  resolution: SimulcastResolution;\n}\n\nexport type RID = 'f' | 'h' | 'q';\n\nexport const simulcastMapping = {\n  f: HMSSimulcastLayer.HIGH,\n  h: HMSSimulcastLayer.MEDIUM,\n  q: HMSSimulcastLayer.LOW,\n};\n", "export enum HMSVideoCodec {\n  VP8 = 'vp8',\n  VP9 = 'vp9',\n  H264 = 'h264',\n}\n\nexport enum HMSAudioCodec {\n  OPUS = 'opus',\n}\n\n/**\n * Refer https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode\n * for more details.\n */\nexport enum HMSFacingMode {\n  USER = 'user',\n  ENVIRONMENT = 'environment',\n  LEFT = 'left',\n  RIGHT = 'right',\n}\n\nexport interface HMSAudioTrackSettings {\n  volume?: number;\n  codec?: HMSAudioCodec;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n}\n\nexport interface HMSVideoTrackSettings {\n  width?: number;\n  height?: number;\n  codec?: HMSVideoCodec;\n  maxFramerate?: number;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n  facingMode?: HMSFacingMode;\n}\n\n/**\n * Config to have control over screenshare being captured. Note that\n * not all fields are supported on all browsers. Even when they're supported\n * the fields acts as hints and the browser can override them.\n */\nexport interface HMSScreenShareConfig {\n  /**\n   * discard the video and only share audio track with others, useful\n   * for sharing music.\n   * @default false\n   */\n  audioOnly?: boolean;\n  /**\n   * do not give an option to share audio while screen sharing.\n   * @default false\n   */\n  videoOnly?: boolean;\n  /**\n   * preselect the relevant tab in screenshare menu\n   * browser - for preferring a browser tab\n   * window - for application window\n   * monitor - for full screen\n   * @default monitor\n   */\n  displaySurface?: 'browser' | 'monitor' | 'window';\n  /**\n   * show the current tab first in supported browser, throws\n   * error if user doesn't select current tab for sharing.\n   * @default false\n   */\n  forceCurrentTab?: boolean;\n  /**\n   * show the current tab first in supported browser, but don't throw error\n   * if user selects something else.\n   * @default false\n   */\n  preferCurrentTab?: boolean;\n  /**\n   * whether to show an option for sharing the current tab in the screen share\n   * prompt. Screen sharing current tab might lead to hall of mirrors effect.\n   * Default is exclude, if either of forceCurrentTab or preferCurrentTab are true,\n   * this is set to include.\n   * @default exclude\n   */\n  selfBrowserSurface?: 'include' | 'exclude';\n  /**\n   * whether to hint browser to show a \"share this tab instead\" option when\n   * tab is shared.\n   * Default is include, set to exclude if forceCurrentTab is true\n   * @default include\n   */\n  surfaceSwitching?: 'include' | 'exclude';\n  /**\n   * whether to show option for sharing system level audio if full screen\n   * is being shared. Not applicable if isVideoOnly is true.\n   * Note that sharing system audio will cause echo if mic is on.\n   * @default exclude\n   */\n  systemAudio?: 'include' | 'exclude';\n  /**\n   * used for region capture in screenshare, if the current tab is being screenshared\n   * the screenshare video track will be cropped to only this element. Will throw\n   * error if the element is not present in DOM.\n   */\n  cropElement?: HTMLDivElement;\n  /**\n   * used for region capture in screenshare, the screenshare video track will be\n   * cropped to only the passed in cropTarget. This cropTarget must come from\n   * the tab which is being shared\n   */\n  cropTarget?: object;\n}\n\nexport interface ScreenCaptureHandle {\n  handle: string;\n  exposeOrigin: boolean;\n}\n\nexport interface ScreenCaptureHandleConfig extends ScreenCaptureHandle {\n  permittedOrigins: string[];\n}\n", "import { HMSException } from '../error/HMSException';\n\nexport interface HMSDeviceChangeEvent {\n  error?: HMSException;\n  devices: DeviceMap;\n  selection?: MediaDeviceInfo;\n  type: 'audioOutput' | 'audioInput' | 'video';\n}\n\nexport enum DeviceType {\n  videoInput = 'videoInput',\n  audioInput = 'audioInput',\n  audioOutput = 'audioOutput',\n}\n\nexport interface DeviceMap {\n  [DeviceType.audioInput]: MediaDeviceInfo[];\n  [DeviceType.audioOutput]: MediaDeviceInfo[];\n  [DeviceType.videoInput]: MediaDeviceInfo[];\n}\n\nexport interface DeviceChangeListener {\n  onDeviceChange?(event: HMSDeviceChangeEvent): void;\n}\n\nexport type SelectedDevices = {\n  [DeviceType.audioInput]?: MediaDeviceInfo;\n  [DeviceType.videoInput]?: MediaDeviceInfo;\n  [DeviceType.audioOutput]?: MediaDeviceInfo;\n};\n", "export enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\n\nexport interface HMSPlaylistItem<T> {\n  /**\n   * uniquely identifies a playlist item\n   */\n  id: string;\n  name: string;\n  type: HMSPlaylistType;\n  /**\n   * the url to play from, local files are not supported currently.\n   */\n  url: string;\n  /**\n   * any additional info, for eg. composer, musician etc.\n   */\n  metadata?: T;\n  /**\n   * duration in seconds\n   */\n  duration?: number;\n}\n\nexport interface HMSPlaylistProgressEvent {\n  type: HMSPlaylistType;\n  progress: number;\n}\n\nexport interface HMSPlaylistManager {\n  getList<T>(type: HMSPlaylistType): HMSPlaylistItem<T>[];\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  clearList(type: HMSPlaylistType): Promise<void>;\n  playNext(type: HMSPlaylistType): Promise<void>;\n  playPrevious(type: HMSPlaylistType): Promise<void>;\n  removeItem(id: string, type: HMSPlaylistType): Promise<boolean>;\n  /**\n   * Seek forward/backward on selected type relative to currentTime\n   * @param value - number in seconds to go forward(if negative, it goes backwards)\n   * @param {HMSPlaylistType} type\n   */\n  seek(value: number, type: HMSPlaylistType): void;\n  /**\n   * Seek forward/backward on selected type - absolute value\n   * @param value - point in playlist item to go to\n   * @param {HMSPlaylistType} type\n   */\n  seekTo(value: number, type: HMSPlaylistType): void;\n  /**\n   * set volume on the selected type\n   * @param value - number between 0-100\n   * @param type\n   */\n  setVolume(value: number, type: HMSPlaylistType): void;\n  /**\n   * Get volume of selected type, between 0-100\n   * @param type\n   */\n  getVolume(type: HMSPlaylistType): number;\n  isPlaying(type: HMSPlaylistType): boolean;\n  getCurrentIndex(type: HMSPlaylistType): number;\n  getCurrentSelection<T>(type: HMSPlaylistType): HMSPlaylistItem<T> | undefined;\n  /**\n   * Returns a value between 0-100\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentProgress(type: HMSPlaylistType): number;\n  /**\n   * Get the currentTime of audio/video based on type\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentTime(type: HMSPlaylistType): number;\n  setEnabled(enabled: boolean, info: { id: string; type: HMSPlaylistType }): Promise<void>;\n  stop(type: HMSPlaylistType): Promise<void>;\n  /**\n   * Subscriber to progress event with a callback\n   * @param fn\n   */\n  onProgress(fn: (event: HMSPlaylistProgressEvent) => void): void;\n  /**\n   * This will be called when a new track is played\n   * @param fn\n   */\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void): void;\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n  /**\n   * Function to autoplay status i.e. whether next item in playlist after the current one ends\n   * @param {HMSPlaylistType} type\n   * @param {boolean} autoplay\n   */\n  setIsAutoplayOn(type: HMSPlaylistType, autoplay: boolean): void;\n  /**\n   * Get the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType} type\n   */\n  getPlaybackRate(type: HMSPlaylistType): number;\n  /**\n   * set the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType}type\n   * @param {number}value - number between 0.25 and 2.0\n   */\n  setPlaybackRate(type: HMSPlaylistType, value: number): void;\n}\n", "import { HMSRoleName } from '../role';\n\nexport type HMSPollUserTrackingMode = 'peerID' | 'customerID' | 'userName';\n\nexport type HMSPollState = 'created' | 'started' | 'stopped';\n\nexport interface HMSPoll {\n  id: string;\n  title: string;\n  state?: HMSPollState;\n  type: 'poll' | 'quiz';\n  duration?: number;\n  anonymous?: boolean;\n  visibility?: boolean;\n  locked?: boolean;\n  mode?: HMSPollUserTrackingMode;\n  createdBy?: string;\n  startedBy?: string;\n  stoppedBy?: string;\n  createdAt?: Date;\n  startedAt?: Date;\n  stoppedAt?: Date;\n  questions?: HMSPollQuestion[];\n  rolesThatCanVote?: HMSRoleName[];\n  rolesThatCanViewResponses?: HMSRoleName[];\n  result?: HMSPollResult;\n}\n\nexport interface HMSPollCreateParams\n  extends Pick<\n    HMSPoll,\n    | 'id'\n    | 'title'\n    | 'type'\n    | 'duration'\n    | 'anonymous'\n    | 'visibility'\n    | 'locked'\n    | 'mode'\n    | 'rolesThatCanVote'\n    | 'rolesThatCanViewResponses'\n  > {\n  questions?: HMSPollQuestionCreateParams[];\n}\n\nexport interface HMSPollQuestion {\n  index: number;\n  text: string;\n  type: HMSPollQuestionType;\n  skippable?: boolean;\n  duration?: number;\n  once?: boolean;\n  weight?: number;\n  negative?: boolean;\n  answerMinLen?: number;\n  answerMaxLen?: number;\n  options?: HMSPollQuestionOption[];\n  answer?: HMSPollQuestionAnswer;\n  responses?: HMSPollQuestionResponse[];\n  result?: HMSPollQuestionResult;\n}\n\nexport interface HMSPollQuestionCreateParams extends Pick<HMSPollQuestion, 'text' | 'skippable' | 'type' | 'answer'> {\n  index?: number;\n  options?: HMSPollQuestionOptionCreateParams[];\n}\n\nexport interface HMSPollQuestionAnswer {\n  hidden: boolean; // if true answer will not be returned when poll is running\n  option?: number; // option index for correct answer, in case of single choice\n  options?: number[]; // list of options that shoould be in answer\n  text?: string; // answer text for answer.\n  case?: boolean; // if false case is ignored when comparing.\n  trim?: boolean; // if true, empty space is trimmer from start and end of asnwer.\n}\n\nexport enum HMSPollQuestionType {\n  SINGLE_CHOICE = 'single-choice',\n  MULTIPLE_CHOICE = 'multiple-choice',\n  SHORT_ANSWER = 'short-answer',\n  LONG_ANSWER = 'long-answer',\n}\n\nexport interface HMSPollQuestionOption {\n  index: number;\n  text: string;\n  weight?: number;\n  voteCount?: number;\n}\n\nexport interface HMSPollQuestionOptionCreateParams extends Pick<HMSPollQuestionOption, 'text' | 'weight'> {\n  isCorrectAnswer?: boolean;\n}\n\nexport interface HMSPollQuestionResponse {\n  id?: string;\n  questionIndex: number;\n  peer?: HMSPollResponsePeerInfo;\n  type?: HMSPollQuestionType;\n  skipped?: boolean;\n  option?: number;\n  options?: number[];\n  text?: string;\n  update?: boolean; // SDK Needs to track wether we previously answered and set accordingly\n  duration?: number; // Time it took to answer the question for leaderboard\n  responseFinal?: boolean; // Indicates wether this is last update when fetching responses\n}\n\nexport type HMSPollQuestionResponseCreateParams = Omit<\n  HMSPollQuestionResponse,\n  'type' | 'peer' | 'update' | 'responseFinal'\n>;\n\ninterface HMSPollResponsePeerInfo {\n  userHash?: string;\n  peerid?: string;\n  userid?: string;\n  username?: string;\n}\n\nexport interface HMSPollResult {\n  /**\n   * The number of unique users who responded to the poll\n   */\n  totalUsers?: number;\n  /**\n   * The maximum number of users in the room during the poll.\n   */\n  maxUsers?: number;\n  totalResponses?: number;\n}\n\nexport interface HMSPollQuestionResult {\n  correctResponses?: number;\n  skippedCount?: number;\n  totalResponses?: number;\n}\n", "import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSAudioCodec, HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\n\nexport class HMSAudioTrackSettingsBuilder {\n  private _volume = 1.0;\n  private _codec?: HMSAudioCodec = HMSAudioCodec.OPUS;\n  private _maxBitrate?: number = 32;\n  private _deviceId = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [\n    // @ts-ignore\n    { googEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { googExperimentalEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { autoGainControl: { exact: true } },\n    // @ts-ignore\n    { noiseSuppression: { exact: true } },\n    // @ts-ignore\n    { googHighpassFilter: { exact: true } },\n    // @ts-ignore\n    { googAudioMirroring: { exact: true } },\n  ];\n\n  volume(volume: number) {\n    if (!(0.0 <= volume && volume <= 1.0)) {\n      throw Error('volume can only be in range [0.0, 1.0]');\n    }\n    this._volume = volume;\n    return this;\n  }\n\n  codec(codec?: HMSAudioCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxBitrate(maxBitrate?: number) {\n    if (maxBitrate && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);\n  }\n}\n\nexport class HMSAudioTrackSettings implements IHMSAudioTrackSettings, IAnalyticsPropertiesProvider {\n  readonly volume?: number;\n  readonly codec?: HMSAudioCodec;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    volume?: number,\n    codec?: HMSAudioCodec,\n    maxBitrate?: number,\n    deviceId?: string,\n    advanced?: Array<MediaTrackConstraintSet>,\n  ) {\n    this.volume = volume;\n    this.codec = codec;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      deviceId: this.deviceId,\n      advanced: this.advanced,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      audio_bitrate: this.maxBitrate,\n      audio_codec: this.codec,\n    };\n  }\n}\n", "import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSFacingMode, HMSVideoCodec, HMSVideoTrackSettings as IHMSVideoTrackSettings } from '../../interfaces';\nimport { isMobile } from '../../utils/support';\n\nexport class HMSVideoTrackSettingsBuilder {\n  private _width?: number = 320;\n  private _height?: number = 180;\n  private _codec?: HMSVideoCodec = HMSVideoCodec.VP8;\n  private _maxFramerate?: number = 30;\n  private _maxBitrate?: number = 150;\n  private _deviceId?: string;\n  private _facingMode?: HMSFacingMode;\n  private _advanced: Array<MediaTrackConstraintSet> = [];\n\n  setWidth(width?: number) {\n    this._width = width;\n    return this;\n  }\n\n  setHeight(height?: number) {\n    this._height = height;\n    return this;\n  }\n\n  codec(codec?: HMSVideoCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxFramerate(maxFramerate?: number) {\n    if (maxFramerate && maxFramerate <= 0) {\n      throw Error('maxFramerate should be >= 1');\n    }\n    this._maxFramerate = maxFramerate;\n    return this;\n  }\n\n  /**\n   * @param useDefault Ignored if maxBitrate is valid.\n   * If true and maxBitrate is undefined - sets a default value.\n   * If false and maxBitrate is undefined - sets undefined.\n   */\n  maxBitrate(maxBitrate?: number, useDefault = true) {\n    if (typeof maxBitrate === 'number' && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    if (!this._maxBitrate && useDefault) {\n      this._maxBitrate = 150_000;\n    }\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  facingMode(mode: HMSFacingMode) {\n    this._facingMode = mode;\n    return this;\n  }\n\n  build() {\n    return new HMSVideoTrackSettings(\n      this._width,\n      this._height,\n      this._codec,\n      this._maxFramerate,\n      this._deviceId,\n      this._advanced,\n      this._maxBitrate,\n      this._facingMode,\n    );\n  }\n}\n\nexport class HMSVideoTrackSettings implements IHMSVideoTrackSettings, IAnalyticsPropertiesProvider {\n  readonly width?: number;\n  readonly height?: number;\n  readonly codec?: HMSVideoCodec;\n  readonly maxFramerate?: number;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n  facingMode?: HMSFacingMode;\n\n  constructor(\n    width?: number,\n    height?: number,\n    codec?: HMSVideoCodec,\n    maxFramerate?: number,\n    deviceId?: string | undefined,\n    advanced?: Array<MediaTrackConstraintSet>,\n    maxBitrate?: number,\n    facingMode?: HMSFacingMode,\n  ) {\n    this.width = width;\n    this.height = height;\n    this.codec = codec;\n    this.maxFramerate = maxFramerate;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n    this.facingMode = facingMode;\n  }\n\n  toConstraints(isScreenShare?: boolean): MediaTrackConstraints {\n    let dimensionConstraintKey = 'ideal';\n    if (isScreenShare) {\n      dimensionConstraintKey = 'max';\n    }\n    const aspectRatio = this.improviseConstraintsAspect();\n    return {\n      width: { [dimensionConstraintKey]: aspectRatio.width },\n      height: { [dimensionConstraintKey]: aspectRatio.height },\n      frameRate: this.maxFramerate,\n      deviceId: this.deviceId,\n      facingMode: this.facingMode,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      width: this.width,\n      height: this.height,\n      video_bitrate: this.maxBitrate,\n      framerate: this.maxFramerate,\n      video_codec: this.codec,\n      facingMode: this.facingMode,\n    };\n  }\n\n  // reverse the height and width if mobile as mobile web browsers override the height and width basis orientation\n  private improviseConstraintsAspect(): Partial<IHMSVideoTrackSettings> {\n    if (isMobile() && this.height && this.width && this.height > this.width) {\n      return {\n        width: this.height,\n        height: this.width,\n      };\n    }\n    return {\n      width: this.width,\n      height: this.height,\n    };\n  }\n}\n", "import { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from './HMSAudioTrackSettings';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from './HMSVideoTrackSettings';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\n\nexport class HMSTrackSettingsBuilder {\n  private _video: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _audio: HMSAudioTrackSettings | null = new HMSAudioTrackSettingsBuilder().build();\n  private _screen: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _simulcast = false;\n\n  video(video: HMSVideoTrackSettings | null) {\n    this._video = video;\n    return this;\n  }\n\n  audio(audio: HMSAudioTrackSettings | null) {\n    this._audio = audio;\n    return this;\n  }\n\n  screen(screen: HMSVideoTrackSettings | null) {\n    this._screen = screen;\n    return this;\n  }\n\n  simulcast(enabled: boolean) {\n    this._simulcast = enabled;\n    return this;\n  }\n\n  build() {\n    if (this._audio === null && this._video === null) {\n      throw ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK);\n    }\n\n    if (this._video === null && this._simulcast) {\n      throw ErrorFactory.TracksErrors.InvalidVideoSettings(\n        HMSAction.TRACK,\n        'Cannot enable simulcast when no video settings are provided',\n      );\n    }\n\n    return new HMSTrackSettings(this._video, this._audio, this._simulcast, this._screen || undefined);\n  }\n}\n\nexport class HMSTrackSettings implements IAnalyticsPropertiesProvider {\n  readonly video: HMSVideoTrackSettings | null | undefined;\n  readonly audio: HMSAudioTrackSettings | null | undefined;\n  readonly screen: HMSVideoTrackSettings | null;\n  readonly simulcast: boolean;\n\n  constructor(\n    video: HMSVideoTrackSettings | null | undefined,\n    audio: HMSAudioTrackSettings | null | undefined,\n    simulcast: boolean,\n    screen: HMSVideoTrackSettings | null = null,\n  ) {\n    this.video = video;\n    this.audio = audio;\n    this.simulcast = simulcast;\n    this.screen = screen;\n  }\n\n  toAnalyticsProperties() {\n    let properties = {\n      audio_enabled: this.audio !== null,\n      video_enabled: this.video !== null,\n    };\n\n    if (this.audio) {\n      properties = { ...this.audio.toAnalyticsProperties(), ...properties };\n    }\n\n    if (this.video) {\n      properties = { ...this.video.toAnalyticsProperties(), ...properties };\n    }\n\n    return properties;\n  }\n}\n", "import { HMSAudioTrack } from './HMSAudioTrack';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\nimport { HMSAudioPlugin, HMSPluginSupportResult } from '../../plugins';\nimport { HMSAudioPluginsManager } from '../../plugins/audio';\nimport HMSLogger from '../../utils/logger';\nimport { isBrowser, isIOS } from '../../utils/support';\nimport { getAudioTrack, isEmptyTrack } from '../../utils/track';\nimport { TrackAudioLevelMonitor } from '../../utils/track-audio-level-monitor';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from '../settings';\nimport { HMSLocalStream } from '../streams';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSAudioTrackSettings>, oldSettings: HMSAudioTrackSettings) {\n  return function hasChanged(prop: 'codec' | 'volume' | 'maxBitrate' | 'deviceId' | 'advanced') {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalAudioTrack extends HMSAudioTrack {\n  private readonly TAG = '[HMSLocalAudioTrack]';\n  settings: HMSAudioTrackSettings;\n  private pluginsManager: HMSAudioPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  audioLevelMonitor?: TrackAudioLevelMonitor;\n\n  /**\n   * see the doc in HMSLocalVideoTrack\n   * @internal\n   */\n  publishedTrackId?: string;\n\n  /**\n   * will be false for preview tracks\n   */\n  isPublished = false;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSAudioTrackSettings = new HMSAudioTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n    // Replace the 'default' or invalid deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId !== track.getSettings().deviceId && !isEmptyTrack(track)) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSAudioPluginsManager(this, eventBus);\n    this.setFirstTrackId(track.id);\n    if (isIOS() && isBrowser) {\n      document.addEventListener('visibilitychange', this.handleVisibilityChange);\n    }\n  }\n\n  private handleVisibilityChange = async () => {\n    if (document.visibilityState === 'visible') {\n      await this.replaceTrackWith(this.settings);\n    }\n  };\n\n  private async replaceTrackWith(settings: HMSAudioTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    /*\n     * Note: Do not change the order of this.\n     * stop the previous before acquiring the new track otherwise this can lead to\n     * no audio when the above getAudioTrack throws an error. ex: DeviceInUse error\n     */\n    prevTrack?.stop();\n    const isLevelMonitored = Boolean(this.audioLevelMonitor);\n    const newTrack = await getAudioTrack(settings);\n    newTrack.enabled = this.enabled;\n    HMSLogger.d(this.TAG, 'replaceTrack, Previous track stopped', prevTrack, 'newTrack', newTrack);\n\n    const localStream = this.stream as HMSLocalStream;\n    // change nativeTrack so plugin can start its work\n    await localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);\n    await localStream.replaceStreamTrack(prevTrack, newTrack);\n    this.nativeTrack = newTrack;\n    isLevelMonitored && this.initAudioLevelMonitor();\n    try {\n      await this.pluginsManager.reprocessPlugins();\n    } catch (e) {\n      this.eventBus.audioPluginFailed.publish(e as HMSException);\n    }\n  }\n\n  async setEnabled(value: boolean) {\n    if (value === this.enabled) {\n      return;\n    }\n\n    // Replace silent empty track with an actual audio track, if enabled.\n    if (value && isEmptyTrack(this.nativeTrack)) {\n      await this.replaceTrackWith(this.settings);\n    }\n    await super.setEnabled(value);\n    if (value) {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    this.eventBus.localAudioEnabled.publish({ enabled: value, track: this });\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like audio level\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  async setSettings(settings: Partial<IHMSAudioTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n\n    if (isEmptyTrack(this.nativeTrack)) {\n      // if it is an empty track, cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleDeviceChange(newSettings, internal);\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async addPlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async removePlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  validatePlugin(plugin: HMSAudioPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  initAudioLevelMonitor() {\n    if (this.audioLevelMonitor) {\n      this.destroyAudioLevelMonitor();\n    }\n    HMSLogger.d(this.TAG, 'Monitor Audio Level for', this, this.getMediaTrackSettings().deviceId);\n    this.audioLevelMonitor = new TrackAudioLevelMonitor(\n      this,\n      this.eventBus.trackAudioLevelUpdate,\n      this.eventBus.localAudioSilence,\n    );\n    this.audioLevelMonitor.start();\n    this.audioLevelMonitor.detectSilence();\n  }\n\n  destroyAudioLevelMonitor() {\n    this.audioLevelMonitor?.stop();\n    this.audioLevelMonitor = undefined;\n  }\n\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    await this.pluginsManager.closeContext();\n    this.transceiver = undefined;\n    this.processedTrack?.stop();\n    this.isPublished = false;\n    this.destroyAudioLevelMonitor();\n    if (isIOS() && isBrowser) {\n      document.removeEventListener('visibilitychange', this.handleVisibilityChange);\n    }\n  }\n\n  /**\n   * @internal\n   * published track id will be different in case there was some processing done using plugins.\n   */\n  getTrackIDBeingSent() {\n    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;\n  }\n\n  /**\n   * @internal\n   */\n  getTrackBeingSent() {\n    return this.processedTrack || this.nativeTrack;\n  }\n\n  private buildNewSettings(settings: Partial<HMSAudioTrackSettings>) {\n    const { volume, codec, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);\n    return newSettings;\n  }\n\n  private handleSettingsChange = async (settings: HMSAudioTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrateAndFramerate(this);\n    }\n\n    if (hasPropertyChanged('advanced')) {\n      await this.replaceTrackWith(settings);\n    }\n  };\n\n  /**\n   * Replace audio track with new track on device change if enabled\n   * @param settings - AudioSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSAudioTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('deviceId')) {\n      await this.replaceTrackWith(settings);\n      if (!internal) {\n        DeviceStorageManager.updateSelection('audioInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n}\n", "import { HMSAudioTrack } from './HMSAudioTrack';\n\nexport class HMSRemoteAudioTrack extends HMSAudioTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    await super.setEnabled(value);\n    await this.subscribeToAudio(value);\n  }\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport { VideoElementManager } from './VideoElementManager';\nimport { HMSMediaStream } from '../streams';\n\nexport class HMSVideoTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.VIDEO;\n  private sinkCount = 0;\n  videoHandler!: VideoElementManager;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'video') {\n      throw new Error(\"Expected 'track' kind = 'video'\");\n    }\n  }\n\n  setVideoHandler(videoHandler: VideoElementManager) {\n    this.videoHandler = videoHandler;\n  }\n\n  /**\n   * sink=video element rendering the video\n   */\n  hasSinks() {\n    return this.sinkCount > 0;\n  }\n\n  getSinks() {\n    return this.videoHandler.getVideoElements() || [];\n  }\n\n  attach(videoElement: HTMLVideoElement) {\n    this.videoHandler.addVideoElement(videoElement);\n  }\n\n  detach(videoElement: HTMLVideoElement) {\n    this.videoHandler.removeVideoElement(videoElement);\n  }\n\n  /**\n   * attaches the track to the passed in video element\n   * @param videoElement\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.nativeTrack);\n  }\n\n  /**\n   * removes the track from the passed in video element\n   * @param videoElement\n   */\n  removeSink(videoElement: HTMLVideoElement) {\n    if (videoElement.srcObject !== null) {\n      videoElement.srcObject = null;\n      this.reduceSinkCount();\n    }\n  }\n\n  cleanup(): void {\n    super.cleanup();\n    this.videoHandler.cleanup();\n  }\n\n  protected addSinkInternal(videoElement: HTMLVideoElement, track: MediaStreamTrack) {\n    const srcObject = videoElement.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrack = srcObject.getVideoTracks()[0];\n      if (existingTrack?.id === track.id) {\n        if (!existingTrack.muted && existingTrack.readyState === 'live') {\n          // it's already attached, attaching again would just cause flickering\n          return;\n        } else {\n          this.reduceSinkCount();\n        }\n      } else {\n        this.reduceSinkCount();\n      }\n    }\n    videoElement.srcObject = new MediaStream([track]);\n    this.sinkCount++;\n  }\n\n  private reduceSinkCount() {\n    if (this.sinkCount > 0) {\n      this.sinkCount--;\n    }\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport { getClosestLayer, layerToIntMapping } from './trackUtils';\nimport { HMSPreferredSimulcastLayer } from '../../interfaces/simulcast-layers';\nimport { HMSLocalVideoTrack, HMSRemoteVideoTrack } from '../../internal';\nimport { HMSIntersectionObserver } from '../../utils/intersection-observer';\nimport HMSLogger from '../../utils/logger';\nimport { HMSResizeObserver } from '../../utils/resize-observer';\nimport { isBrowser } from '../../utils/support';\n\n/**\n * This class is to manager video elements for video tracks.\n * This will handle attaching/detaching when element is in view or out of view.\n * This will also handle selecting appropriate layer when element size changesx\n */\nexport class VideoElementManager {\n  private readonly TAG = '[VideoElementManager]';\n  private resizeObserver?: typeof HMSResizeObserver;\n  private intersectionObserver?: typeof HMSIntersectionObserver;\n  private videoElements = new Set<HTMLVideoElement>();\n  private entries = new WeakMap<HTMLVideoElement, DOMRectReadOnly>();\n  private id: string;\n\n  constructor(private track: HMSLocalVideoTrack | HMSRemoteVideoTrack) {\n    this.init();\n    this.id = uuid();\n  }\n\n  updateSinks(requestLayer = false) {\n    for (const videoElement of this.videoElements) {\n      if (this.track.enabled) {\n        this.track.addSink(videoElement, requestLayer);\n      } else {\n        this.track.removeSink(videoElement, requestLayer);\n      }\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  async addVideoElement(videoElement: HTMLVideoElement) {\n    if (this.videoElements.has(videoElement)) {\n      return;\n    }\n    // Call init again, to initialize again if for some reason it failed in constructor\n    // it will be a no-op if initialize already\n    this.init();\n    HMSLogger.d(this.TAG, `Adding video element for ${this.track}`, this.id);\n    this.videoElements.add(videoElement);\n    if (this.videoElements.size >= 10) {\n      HMSLogger.w(\n        this.TAG,\n        `${this.track}`,\n        `the track is added to ${this.videoElements.size} video elements, while this may be intentional, it's likely that there is a bug leading to unnecessary creation of video elements in the UI`,\n      );\n    }\n\n    if (this.intersectionObserver?.isSupported()) {\n      this.intersectionObserver.observe(videoElement, this.handleIntersection);\n    } else if (isBrowser) {\n      if (this.isElementInViewport(videoElement)) {\n        this.track.addSink(videoElement);\n      } else {\n        this.track.removeSink(videoElement);\n      }\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.observe(videoElement, this.handleResize);\n    } else if (this.track instanceof HMSRemoteVideoTrack) {\n      await this.track.setPreferredLayer(this.track.getPreferredLayer());\n    }\n  }\n\n  removeVideoElement(videoElement: HTMLVideoElement): void {\n    this.track.removeSink(videoElement);\n    this.videoElements.delete(videoElement);\n    this.entries.delete(videoElement);\n    this.resizeObserver?.unobserve(videoElement);\n    this.intersectionObserver?.unobserve(videoElement);\n    HMSLogger.d(this.TAG, `Removing video element for ${this.track}`);\n  }\n\n  getVideoElements(): HTMLVideoElement[] {\n    return Array.from(this.videoElements);\n  }\n\n  private init() {\n    if (isBrowser) {\n      this.resizeObserver = HMSResizeObserver;\n      this.intersectionObserver = HMSIntersectionObserver;\n    }\n  }\n\n  private handleIntersection = async (entry: IntersectionObserverEntry) => {\n    const isVisibile = getComputedStyle(entry.target).visibility === 'visible';\n    // .contains check is needed for pip component as the video tiles are not mounted to dom element\n    if (this.track.enabled && ((entry.isIntersecting && isVisibile) || !document.contains(entry.target))) {\n      HMSLogger.d(this.TAG, 'add sink intersection', `${this.track}`, this.id);\n      this.entries.set(entry.target as HTMLVideoElement, entry.boundingClientRect);\n      await this.selectMaxLayer();\n      await this.track.addSink(entry.target as HTMLVideoElement);\n    } else {\n      HMSLogger.d(this.TAG, 'remove sink intersection', `${this.track}`, this.id);\n      await this.track.removeSink(entry.target as HTMLVideoElement);\n    }\n  };\n\n  private handleResize = async (entry: ResizeObserverEntry) => {\n    if (!this.track.enabled || !(this.track instanceof HMSRemoteVideoTrack)) {\n      return;\n    }\n    this.entries.set(entry.target as HTMLVideoElement, entry.contentRect);\n    await this.selectMaxLayer();\n  };\n\n  /**\n   *  Taken from\n   *  https://stackoverflow.com/a/125106/4321808\n   */\n  // eslint-disable-next-line complexity\n  private isElementInViewport(el: HTMLElement) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n\n    while (el.offsetParent) {\n      el = el.offsetParent as HTMLElement;\n      top += el.offsetTop;\n      left += el.offsetLeft;\n    }\n\n    return (\n      top < window.pageYOffset + window.innerHeight &&\n      left < window.pageXOffset + window.innerWidth &&\n      top + height > window.pageYOffset &&\n      left + width > window.pageXOffset &&\n      !hidden &&\n      (opacity !== '' ? parseFloat(opacity) > 0 : true) &&\n      display !== 'none'\n    );\n  }\n\n  // eslint-disable-next-line complexity\n  private async selectMaxLayer() {\n    if (!(this.track instanceof HMSRemoteVideoTrack) || this.videoElements.size === 0) {\n      return;\n    }\n    let maxLayer!: HMSPreferredSimulcastLayer;\n    for (const element of this.videoElements) {\n      const entry = this.entries.get(element);\n      if (!entry) {\n        continue;\n      }\n      const { width, height } = entry;\n      if (width === 0 || height === 0) {\n        continue;\n      }\n      const layer = getClosestLayer(this.track.getSimulcastDefinitions(), { width, height });\n      if (!maxLayer) {\n        maxLayer = layer;\n      } else {\n        maxLayer = layerToIntMapping[layer] > layerToIntMapping[maxLayer] ? layer : maxLayer;\n      }\n    }\n    if (maxLayer) {\n      HMSLogger.d(this.TAG, `selecting max layer ${maxLayer} for the track`, `${this.track}`);\n      await this.track.setPreferredLayer(maxLayer);\n    }\n  }\n\n  cleanup = () => {\n    this.videoElements.forEach(videoElement => {\n      videoElement.srcObject = null;\n      this.resizeObserver?.unobserve(videoElement);\n      this.intersectionObserver?.unobserve(videoElement);\n    });\n    this.videoElements.clear();\n    this.resizeObserver = undefined;\n    this.intersectionObserver = undefined;\n  };\n}\n", "import { HMSPreferredSimulcastLayer, HMSSimulcastLayer, HMSSimulcastLayerDefinition } from '../../interfaces';\n\nexport const layerToIntMapping = {\n  [HMSSimulcastLayer.NONE]: -1,\n  [HMSSimulcastLayer.LOW]: 0,\n  [HMSSimulcastLayer.MEDIUM]: 1,\n  [HMSSimulcastLayer.HIGH]: 2,\n};\nconst DELTA_THRESHOLD = 0.5;\n\n/**\n * Given the simulcast layers and the current video element dimensions, this function finds the\n * layer with dimensions closer to the video element dimensions.\n */\n// eslint-disable-next-line complexity\nexport const getClosestLayer = (\n  simulcastLayers: HMSSimulcastLayerDefinition[],\n  videoElementDimensions: { width: number; height: number },\n): HMSPreferredSimulcastLayer => {\n  let closestLayer: HMSPreferredSimulcastLayer = HMSSimulcastLayer.HIGH;\n  // when both width and height are equal pick height to select a better quality\n  const maxDimension = videoElementDimensions.width > videoElementDimensions.height ? 'width' : 'height';\n  const layers = [...simulcastLayers].sort((a, b) => layerToIntMapping[a.layer] - layerToIntMapping[b.layer]);\n  const videoDimesion = videoElementDimensions[maxDimension] * (window?.devicePixelRatio || 1);\n  for (let i = 0; i < layers.length; i++) {\n    const { resolution, layer } = layers[i];\n    const layerDimension = resolution[maxDimension];\n    // we break here because the layers are already sorted, the next would always be greater if the below condition satisifes\n    if (videoDimesion <= layerDimension) {\n      closestLayer = layer;\n      break;\n    } else {\n      const nextLayer = layers[i + 1];\n      const nextLayerDimension = nextLayer ? nextLayer.resolution[maxDimension] : Number.POSITIVE_INFINITY;\n      // calculating which layer this dimension is closer to\n      const proximityPercent = (videoDimesion - layerDimension) / (nextLayerDimension - layerDimension);\n      if (proximityPercent < DELTA_THRESHOLD) {\n        // the element's dimension is closer to the current layer\n        closestLayer = layer;\n        break;\n      }\n    }\n  }\n  return closestLayer;\n};\n", "import HMSLogger from './logger';\nimport { isBrowser } from './support';\n\nexport interface HMSIntersectionObserverCallback {\n  (entry: IntersectionObserverEntry): void;\n}\n\n/**\n * This is a wrapper around IntersectionObserver which will call the callback passed\n * for an element while observing, only when that element is intersecting\n */\nexport class HMSIntersectionObserverWrapper {\n  private intersectionObserver?: IntersectionObserver;\n  private readonly TAG = '[HMSIntersectionObserverWrapper]';\n  private listeners = new WeakMap<HTMLElement, HMSIntersectionObserverCallback>();\n  constructor() {\n    this.createObserver();\n  }\n\n  isSupported() {\n    const isSupported = isBrowser && typeof window.IntersectionObserver !== 'undefined';\n    if (!isSupported) {\n      HMSLogger.w(this.TAG, 'IntersectionObserver is not supported, fallback will be used instead');\n    }\n    return isSupported;\n  }\n\n  observe = (element: HTMLElement, onIntersection: HMSIntersectionObserverCallback) => {\n    this.createObserver();\n    // unobserve before observing the element\n    this.unobserve(element);\n    this.intersectionObserver?.observe(element);\n    this.listeners.set(element, onIntersection);\n  };\n\n  unobserve = (element: HTMLElement) => {\n    this.intersectionObserver?.unobserve(element);\n    this.listeners.delete(element);\n  };\n\n  private createObserver = () => {\n    if (this.isSupported() && !this.intersectionObserver) {\n      this.intersectionObserver = new IntersectionObserver(this.handleIntersection);\n    }\n  };\n\n  private handleIntersection = (entries: IntersectionObserverEntry[]) => {\n    for (const entry of entries) {\n      this.listeners.get(entry.target as HTMLElement)?.(entry);\n    }\n  };\n}\n\nexport const HMSIntersectionObserver = new HMSIntersectionObserverWrapper();\n", "import HMSLogger from './logger';\nimport { isBrowser } from './support';\nimport { debounce } from './timer-utils';\n\nexport interface HMSResizeObserverCallback {\n  (entry: ResizeObserverEntry): void;\n}\n\n/**\n * This is a wrapper around ResizeObserver which will call the callback passed\n * for an element while observing, only when that element is intersecting\n */\nexport class HMSResizeObserverWrapper {\n  private resizeObserver?: ResizeObserver;\n  private readonly TAG = '[HMSResizeObserverWrapper]';\n  private listeners = new WeakMap<HTMLElement, HMSResizeObserverCallback>();\n  constructor() {\n    this.createObserver();\n  }\n\n  isSupported() {\n    const isSupported = isBrowser && typeof window.ResizeObserver !== 'undefined';\n    if (!isSupported) {\n      HMSLogger.w(this.TAG, 'Resize Observer is not supported');\n    }\n    return isSupported;\n  }\n\n  observe = (\n    element: HTMLElement,\n    onResize: HMSResizeObserverCallback,\n    options: ResizeObserverOptions = { box: 'border-box' },\n  ) => {\n    this.createObserver();\n    // unobserve before observing the element\n    this.unobserve(element);\n    this.resizeObserver?.observe(element, options);\n    this.listeners.set(element, onResize);\n  };\n\n  unobserve = (element: HTMLElement) => {\n    this.resizeObserver?.unobserve(element);\n    this.listeners.delete(element);\n  };\n\n  private createObserver = () => {\n    if (this.isSupported() && !this.resizeObserver) {\n      this.resizeObserver = new ResizeObserver(debounce(this.handleResize, 300));\n    }\n  };\n\n  private handleResize = (entries: ResizeObserverEntry[]) => {\n    for (const entry of entries) {\n      this.listeners.get(entry.target as HTMLElement)?.(entry);\n    }\n  };\n}\n\nexport const HMSResizeObserver = new HMSResizeObserverWrapper();\n", "import { HMSPluginSupportResult } from '../audio';\n\n/**\n * A plugin implementing this interface can be registered with HMSLocalVideoTrack to transform, process or\n * analyze the local video track.These can include applications like video filters, virtual background, live\n * analysis of video etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\nexport interface HMSVideoPlugin {\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS and device or not. An error will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processVideoFrame is called.\n   */\n  init(): Promise<void>;\n\n  /**\n   * @see HMSVideoPluginType\n   */\n  getPluginType(): HMSVideoPluginType;\n\n  getContextType?(): HMSVideoPluginCanvasContextType;\n\n  /**\n   * This function will be called by the SDK for every video frame which the plugin needs to process.\n   * PluginFrameRate - the rate at which the plugin is expected to process the video frames. This is not necessarily\n   * equal to the capture frame rate. The user can specify this rate, and the sdk might also change it on basis of\n   * device type, or CPU usage.\n   * For an analyzing plugin, the below function will be called at plugin framerate.\n   * For a transforming plugin, the sdk will pass in the input and output at real frame rate with an additional boolean\n   * pass. The expectation is that the plugin should use results of previous runs instead of doing a complex processing\n   * again when pass is set to true. This helps in maintaining the framerate of the video as well as bringing down\n   * CPU usage in case of complex processing.\n   * @param input input canvas containing the input frame\n   * @param output the output canvas which should contain the output frame\n   * @param skipProcessing use results from previous run if true\n   */\n  processVideoFrame(\n    input: HTMLCanvasElement,\n    output?: HTMLCanvasElement,\n    skipProcessing?: boolean,\n  ): Promise<void> | void;\n\n  /**\n   * the plugin can use this function to dispose off its resources. It'll be called when the processor instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output canvas to give the resulting\n * transformation. While an analyzing plugin will only be passed the input canvas.\n */\nexport enum HMSVideoPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport enum HMSVideoPluginCanvasContextType {\n  '2D' = '2d',\n  WEBGL = 'webgl',\n  'WEBGL2' = 'webgl2',\n}\n", "export class RunningAverage {\n  private total = 0;\n  private count = 0;\n\n  add(item: number) {\n    this.count++;\n    this.total += item;\n  }\n\n  getAvg(): number {\n    return Math.floor(this.total / this.count);\n  }\n\n  reset() {\n    this.total = 0;\n    this.count = 0;\n  }\n}\n", "import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport HMSLogger from '../../utils/logger';\nimport { RunningAverage } from '../../utils/math';\n\nexport class VideoPluginsAnalytics {\n  private readonly TAG = '[VideoPluginsAnalytics]';\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly preProcessingAvgs: RunningAverage;\n  private readonly processingAvgs: Record<string, RunningAverage>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginInputFrameRate: Record<string, number>;\n  private readonly pluginFrameRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.preProcessingAvgs = new RunningAverage();\n    this.addedTimestamps = {};\n    this.processingAvgs = {};\n    this.pluginAdded = {};\n    this.pluginInputFrameRate = {};\n    this.pluginFrameRate = {};\n  }\n\n  added(name: string, inputFrameRate: number, pluginFrameRate?: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.processingAvgs[name] = new RunningAverage();\n    this.pluginInputFrameRate[name] = inputFrameRate;\n    this.pluginFrameRate[name] = pluginFrameRate || inputFrameRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        avgPreProcessingTime: this.preProcessingAvgs.getAvg(), //Do we need this in stat not plugin specific\n        avgProcessingTime: this.processingAvgs[name]?.getAvg(),\n        inputFrameRate: this.pluginInputFrameRate[name],\n        pluginFrameRate: this.pluginFrameRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.stats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.failure(name, error));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(this.TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(this.TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  async preProcessWithTime<T>(preProcessFn: () => Promise<T>) {\n    //TODO: check if it is required to maintain and shall we handle preprocess failures\n    const time = await this.timeInMs(preProcessFn);\n    this.preProcessingAvgs.add(time);\n  }\n\n  async processWithTime<T>(name: string, processFn: () => Promise<T>) {\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(processFn);\n    } catch (e) {\n      //Failed during processing of plugin\n      const err = ErrorFactory.MediaPluginErrors.ProcessingFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `Failed during processing of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.processingAvgs[name]?.add(time);\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.processingAvgs[name];\n    delete this.pluginAdded[name];\n    delete this.pluginInputFrameRate[name];\n    delete this.pluginFrameRate[name];\n  }\n}\n", "/* eslint-disable complexity */\nimport { HMSVideoPlugin, HMSVideoPluginCanvasContextType, HMSVideoPluginType } from './HMSVideoPlugin';\nimport { VideoPluginsAnalytics } from './VideoPluginsAnalytics';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSLocalVideoTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { sleep } from '../../utils/timer-utils';\nimport { HMSPluginUnsupportedTypes } from '../audio';\n\nconst DEFAULT_FRAME_RATE = 24;\nconst DEFAULT_WIDTH = 320;\nconst DEFAULT_HEIGHT = 240;\n\ninterface CanvasElement extends HTMLCanvasElement {\n  captureStream(frameRate?: number): MediaStream;\n}\n\n/**\n * This class manages applying different plugins on a local video track. Plugins which need to modify the video\n * are called in the order they were added. Plugins which do not need to modify the video frames are called\n * with the original input.\n *\n * Concepts -\n * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally\n * render its output on a passed in output canvas which will be shown in the UI.\n *\n * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames\n * are being produced and the rate we need to maintain in output as well.\n *\n * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an\n * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the\n * real frame rate.\n *\n * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added\n * plugins are called one by one in the order they were called.\n *\n * @see HMSVideoPlugin\n */\nexport class HMSVideoPluginsManager {\n  private readonly TAG = '[VideoPluginsManager]';\n\n  /**\n   * plugins loop is the loop in which all plugins are applied\n   */\n  private pluginsLoopRunning = false;\n  private pluginsLoopState: 'paused' | 'running' = 'paused';\n  private readonly hmsTrack: HMSLocalVideoTrack;\n  private readonly pluginsMap: Map<string, HMSVideoPlugin>; // plugin names to their instance mapping\n  private inputVideo?: HTMLVideoElement;\n  private inputCanvas?: CanvasElement;\n  private outputCanvas?: CanvasElement;\n  private outputTrack?: MediaStreamTrack;\n  private analytics: VideoPluginsAnalytics;\n  private pluginAddInProgress = false;\n  private pluginNumFramesToSkip: Record<string, number>;\n  private pluginNumFramesSkipped: Record<string, number>;\n  private canvases: Array<CanvasElement>; //array of canvases to store intermediate result\n\n  constructor(track: HMSLocalVideoTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.pluginNumFramesToSkip = {};\n    this.pluginNumFramesSkipped = {};\n    this.analytics = new VideoPluginsAnalytics(eventBus);\n    this.canvases = new Array<CanvasElement>();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  /**\n   * @param plugin\n   * @param pluginFrameRate\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    if (this.pluginAddInProgress) {\n      const name = plugin.getName?.();\n      if (!name || name === '') {\n        HMSLogger.w('no name provided by the plugin');\n        return;\n      }\n\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.VIDEO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.failure(name, err);\n\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin, pluginFrameRate);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  private async addPluginInternal(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    const name = plugin.getName?.();\n    if (!name || name === '') {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginsMap.has(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${plugin.getName()} already added.`);\n      return;\n    }\n    //TODO: assuming this inputFrameRate from getMediaTrackSettings will not change once set\n    //TODO: even if it changes will not have the info/params to know the change\n    const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n\n    let numFramesToSkip = 0;\n    if (pluginFrameRate && pluginFrameRate > 0) {\n      HMSLogger.i(this.TAG, `adding plugin ${plugin.getName()} with framerate ${pluginFrameRate}`);\n      if (pluginFrameRate < inputFrameRate) {\n        numFramesToSkip = Math.ceil(inputFrameRate / pluginFrameRate) - 1;\n      }\n      this.analytics.added(name, inputFrameRate, pluginFrameRate);\n    } else {\n      HMSLogger.i(this.TAG, `adding plugin ${plugin.getName()}`);\n      this.analytics.added(name, inputFrameRate);\n    }\n\n    HMSLogger.i(this.TAG, 'numFrames to skip processing', numFramesToSkip);\n    this.pluginNumFramesToSkip[name] = numFramesToSkip;\n    this.pluginNumFramesSkipped[name] = numFramesToSkip;\n\n    this.validateAndThrow(name, plugin);\n\n    try {\n      await this.analytics.initWithTime(name, async () => await plugin.init());\n      this.pluginsMap.set(name, plugin);\n      // add new canvases according to new added plugins\n      if (this.pluginsMap.size + 1 > this.canvases.length) {\n        for (let i = this.canvases.length; i <= this.pluginsMap.size; i++) {\n          this.canvases[i] = document.createElement('canvas') as CanvasElement;\n        }\n      }\n      await this.startPluginsLoop(plugin.getContextType?.());\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to add plugin', err);\n      await this.removePlugin(plugin);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSVideoPlugin) {\n    return plugin.checkSupport();\n  }\n\n  validateAndThrow(name: string, plugin: HMSVideoPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(this.TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      let error;\n      switch (result.errType) {\n        case HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'platform not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n        case HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'video device not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSVideoPlugin) {\n    const name = plugin.getName();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(this.TAG, `removing plugin ${name}`);\n    this.removePluginEntry(name);\n    if (this.pluginsMap.size === 0) {\n      HMSLogger.i(this.TAG, `No plugins left, stopping plugins loop`);\n      await this.stopPluginsLoop();\n    }\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  removePluginEntry(name: string) {\n    this.pluginsMap.delete(name);\n    if (this.pluginNumFramesToSkip[name]) {\n      delete this.pluginNumFramesToSkip[name];\n    }\n    if (this.pluginNumFramesSkipped[name]) {\n      delete this.pluginNumFramesSkipped[name];\n    }\n  }\n\n  /**\n   * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be\n   * produced. It can await on this function to confirm and tell the new unmuted state.\n   * If this is not awaited on video will freeze with a frame from past run.\n   */\n  async waitForRestart() {\n    if (!this.pluginsLoopRunning || this.pluginsLoopState === 'running') {\n      return;\n    }\n    while (this.pluginsLoopState === 'paused') {\n      await sleep(100);\n    }\n  }\n\n  /**\n   * remove every plugin one by one\n   */\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePlugin(plugin);\n    }\n    // memory cleanup\n    this.outputTrack?.stop();\n  }\n\n  private initElementsAndStream(contextType?: HMSVideoPluginCanvasContextType) {\n    if (!this.inputCanvas) {\n      this.inputCanvas = document.createElement('canvas') as CanvasElement;\n    }\n    this.outputCanvas = document.createElement('canvas') as CanvasElement;\n    if (!this.inputVideo) {\n      this.inputVideo = document.createElement('video');\n    }\n    // FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n    this.inputCanvas.getContext('2d');\n    this.outputCanvas.getContext(contextType || HMSVideoPluginCanvasContextType['2D']);\n    // capture stream automatically uses the framerate at which the output canvas is changing\n    const outputStream = this.outputCanvas.captureStream();\n    this.outputTrack = outputStream.getVideoTracks()[0];\n  }\n\n  private async startPluginsLoop(contextType?: HMSVideoPluginCanvasContextType) {\n    if (this.pluginsLoopRunning) {\n      return;\n    }\n    this.initElementsAndStream(contextType);\n    this.pluginsLoopRunning = true;\n    try {\n      await this.hmsTrack.setProcessedTrack(this.outputTrack);\n    } catch (err) {\n      this.pluginsLoopRunning = false;\n      HMSLogger.e(this.TAG, 'error in setting processed track', err);\n      throw err;\n    }\n    // can't await on pluginsLoop as it'll run for a long long time\n    this.pluginsLoop().then(() => {\n      HMSLogger.d(this.TAG, 'processLoop stopped');\n    });\n  }\n\n  private async stopPluginsLoop() {\n    this.pluginsLoopRunning = false;\n    await this.hmsTrack.setProcessedTrack(undefined);\n    this.resetCanvases();\n    this.outputTrack?.stop();\n    if (this.inputVideo) {\n      this.inputVideo.srcObject = null;\n      this.inputVideo = undefined;\n    }\n  }\n\n  private async pluginsLoop() {\n    while (this.pluginsLoopRunning) {\n      const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n      const sleepTimeMs = Math.floor(1000 / inputFrameRate);\n      if (!this.hmsTrack.enabled || this.hmsTrack.nativeTrack.readyState === 'ended') {\n        if (this.pluginsLoopState === 'running') {\n          // mute just happened, reset canvases to black so even if it is sent to remote, it\n          // is a black screen instead of a stucked frame from previous run\n          this.resetCanvases();\n        }\n        this.pluginsLoopState = 'paused';\n        await sleep(sleepTimeMs);\n        continue;\n      }\n      let processingTime = 0;\n      try {\n        await this.analytics.preProcessWithTime(async () => await this.doPreProcessing());\n        const start = Date.now();\n        await this.processFramesThroughPlugins();\n        processingTime = Math.floor(Date.now() - start);\n        if (processingTime > sleepTimeMs) {\n          processingTime = sleepTimeMs;\n        }\n      } catch (err) {\n        // TODO: handle failures properly, detect which plugin failed, stop it and notify back to the UI\n        HMSLogger.e(this.TAG, 'error in plugins loop', err);\n      }\n      this.pluginsLoopState = 'running';\n      // take into account processing time to decide time to wait for the next loop\n      await sleep(sleepTimeMs - processingTime);\n    }\n  }\n\n  private async doPreProcessing() {\n    await this.addTrackToVideo(); // ensure current native track is playing in video\n    await this.updateInputCanvas(); // put the latest video frame on input canvas\n  }\n\n  /**\n   * pass the input canvas through all plugins in a loop\n   * @private\n   */\n  private async processFramesThroughPlugins() {\n    this.canvases[0] = this.inputCanvas!;\n    let i = 0;\n    for (const plugin of this.pluginsMap.values()) {\n      const name = plugin.getName();\n      if (!plugin) {\n        continue;\n      }\n      try {\n        const skipProcessing = this.checkIfSkipRequired(name);\n\n        if (plugin.getPluginType() === HMSVideoPluginType.TRANSFORM) {\n          const process = async (input: CanvasElement, output: CanvasElement) => {\n            try {\n              await plugin.processVideoFrame(input, output, skipProcessing);\n            } catch (err) {\n              HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n            }\n          };\n          if (!skipProcessing) {\n            const currentCanvas = this.canvases[i];\n            const nextCanvas = this.canvases[i + 1];\n            if (i === this.pluginsMap.size - 1) {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, this.outputCanvas!));\n            } else {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, nextCanvas));\n            }\n          } else {\n            if (i === this.pluginsMap.size - 1) {\n              await process(this.canvases[i], this.outputCanvas!);\n            } else {\n              await process(this.canvases[i], this.canvases[i + 1]);\n            }\n          }\n        } else if (plugin.getPluginType() === HMSVideoPluginType.ANALYZE && !skipProcessing) {\n          // there is no need to await for this case\n          await this.analytics.processWithTime(name, async () => await plugin.processVideoFrame(this.inputCanvas!));\n        }\n      } catch (err) {\n        //TODO error happened on processing of plugin notify UI\n        HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n      i++;\n    }\n  }\n\n  /**\n   * add the current native track to the inputVideoElement if it's not already added.\n   * @private\n   */\n  private async addTrackToVideo() {\n    if (!this.inputVideo) {\n      return;\n    }\n    const srcObject = this.inputVideo.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === this.hmsTrack.nativeTrack.id) {\n        // it's already attached\n        return;\n      }\n    }\n    this.inputVideo.pause();\n    this.inputVideo.srcObject = new MediaStream([this.hmsTrack.nativeTrack]);\n    this.inputVideo.muted = true;\n    this.inputVideo.playsInline = true;\n    await this.inputVideo.play();\n  }\n\n  /**\n   * get the new video frame from input video element and put it on canvas\n   * @private\n   */\n  private async updateInputCanvas() {\n    if (!this.inputCanvas || !this.inputVideo) {\n      return;\n    }\n    const { width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT } = this.hmsTrack.getMediaTrackSettings();\n    // TODO: should we reduce height/width to optimize?\n    if (this.inputCanvas.height !== height) {\n      this.inputCanvas.height = height;\n    }\n    if (this.inputCanvas.width !== width) {\n      this.inputCanvas.width = width;\n    }\n    const ctx = this.inputCanvas.getContext('2d');\n    ctx!.drawImage(this.inputVideo, 0, 0, width, height);\n  }\n\n  private resetCanvases() {\n    if (!this.outputCanvas || !this.inputCanvas) {\n      return;\n    }\n    const inputCtx = this.inputCanvas.getContext('2d');\n    if (inputCtx) {\n      inputCtx.fillStyle = `rgb(0, 0, 0)`;\n      inputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    }\n    this.canvases = [];\n  }\n\n  /**\n    N = ceil(inputFrameRate/pluginFrameRate) - 1\n    N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame\n    all the frames we are skipping are using the previous frame output\n   **/\n  private checkIfSkipRequired(name: string) {\n    let skip = false;\n\n    if (this.pluginNumFramesSkipped[name] < this.pluginNumFramesToSkip[name]) {\n      this.pluginNumFramesSkipped[name]++;\n      skip = true;\n    } else {\n      skip = false;\n      this.pluginNumFramesSkipped[name] = 0;\n    }\n\n    return skip;\n  }\n}\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport { VideoElementManager } from './VideoElementManager';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { EventBus } from '../../events/EventBus';\nimport {\n  HMSFacingMode,\n  HMSSimulcastLayerDefinition,\n  HMSVideoTrackSettings as IHMSVideoTrackSettings,\n  ScreenCaptureHandle,\n} from '../../interfaces';\nimport { HMSPluginSupportResult, HMSVideoPlugin } from '../../plugins';\nimport { HMSVideoPluginsManager } from '../../plugins/video';\nimport { LocalTrackManager } from '../../sdk/LocalTrackManager';\nimport HMSLogger from '../../utils/logger';\nimport { getVideoTrack, isEmptyTrack } from '../../utils/track';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from '../settings';\nimport { HMSLocalStream } from '../streams';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSVideoTrackSettings>, oldSettings: HMSVideoTrackSettings) {\n  return function hasChanged(\n    prop: 'codec' | 'width' | 'height' | 'maxFramerate' | 'maxBitrate' | 'deviceId' | 'advanced' | 'facingMode',\n  ) {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalVideoTrack extends HMSVideoTrack {\n  settings: HMSVideoTrackSettings;\n  private pluginsManager: HMSVideoPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n  private _layerDefinitions: HMSSimulcastLayerDefinition[] = [];\n  private TAG = '[HMSLocalVideoTrack]';\n\n  /**\n   * true if it's screenshare and current tab is what is being shared. Browser dependent, Chromium only\n   * at the point of writing this comment.\n   */\n  isCurrentTab = false;\n\n  /**\n   * @internal\n   * This is required for handling remote mute/unmute as the published track will not necessarily be same as\n   * the first track id or current native track's id.\n   * It won't be same as first track id if the native track was changed after preview started but before join happened,\n   * with device change, or mute/unmute.\n   * It won't be same as native track id, as the native track can change post join(and publish), when the nativetrack\n   * changes, replacetrack is used which doesn't involve republishing which means from server's point of view, the track id\n   * is same as what was initially published.\n   * This will only be available if the track was actually published and won't be set for preview tracks.\n   */\n  publishedTrackId?: string;\n\n  /**\n   * will be false for preview tracks\n   */\n  isPublished = false;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSVideoTrackSettings = new HMSVideoTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n    this.setVideoHandler(new VideoElementManager(this));\n    this.settings = settings;\n    // Replace the 'default' or invalid deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId !== track.getSettings().deviceId && track.enabled) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSVideoPluginsManager(this, eventBus);\n    this.setFirstTrackId(this.trackId);\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: HMSSimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {HMSSimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions(): HMSSimulcastLayerDefinition[] {\n    return this._layerDefinitions;\n  }\n\n  /**\n   * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.\n   * @param value\n   */\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    if (this.source === 'regular') {\n      let track: MediaStreamTrack;\n      if (value) {\n        track = await this.replaceTrackWith(this.settings);\n      } else {\n        track = await this.replaceTrackWithBlank();\n      }\n      await this.replaceSender(track, value);\n      this.nativeTrack?.stop();\n      this.nativeTrack = track;\n      await super.setEnabled(value);\n      if (value) {\n        await this.pluginsManager.waitForRestart();\n        this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n      }\n      this.videoHandler.updateSinks();\n    }\n    this.eventBus.localVideoEnabled.publish({ enabled: value, track: this });\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like degradation\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  /**\n   * @see HMSVideoTrack#addSink()\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.processedTrack || this.nativeTrack);\n  }\n\n  /**\n   * This function can be used to set media track settings. Frequent options -\n   * deviceID: can be used to change to different input source\n   * width, height - can be used to change capture dimensions\n   * maxFramerate - can be used to control the capture framerate\n   * @param settings\n   */\n  async setSettings(settings: Partial<IHMSVideoTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n    await this.handleDeviceChange(newSettings, internal);\n    if (!this.enabled || isEmptyTrack(this.nativeTrack)) {\n      // if track is muted, we just cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin, pluginFrameRate);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async removePlugin(plugin: HMSVideoPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  validatePlugin(plugin: HMSVideoPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async cleanup() {\n    super.cleanup();\n    this.transceiver = undefined;\n    await this.pluginsManager.cleanup();\n    this.processedTrack?.stop();\n    this.isPublished = false;\n  }\n\n  /**\n   * only for screenshare track to crop to a cropTarget\n   * @internal\n   */\n  async cropTo(cropTarget?: object) {\n    if (!cropTarget) {\n      return;\n    }\n    if (this.source !== 'screen') {\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (this.nativeTrack.cropTo) {\n        // @ts-ignore\n        await this.nativeTrack.cropTo(cropTarget);\n      }\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to crop screenshare capture - ', err);\n      throw ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, 'failed to crop screenshare capture');\n    }\n  }\n\n  /**\n   * only for screenshare track to get the captureHandle\n   * TODO: add an API for capturehandlechange event\n   * @internal\n   */\n  getCaptureHandle(): ScreenCaptureHandle | undefined {\n    // @ts-ignore\n    if (this.nativeTrack.getCaptureHandle) {\n      // @ts-ignore\n      return this.nativeTrack.getCaptureHandle();\n    }\n    return undefined;\n  }\n\n  /**\n   * once the plugin manager has done its processing it can set or remove processed track via this method\n   * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is\n   * no point in replacing it. We'll update the processed track variable though so next time unmute happens\n   * it's set properly.\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // required replacement will happen when video is unmuted\n    if (!this.nativeTrack.enabled) {\n      this.processedTrack = processedTrack;\n      return;\n    }\n    await this.removeOrReplaceProcessedTrack(processedTrack);\n    this.videoHandler.updateSinks();\n  }\n\n  /**\n   * @internal\n   * sent track id will be different in case there was some processing done using plugins.\n   * replace track is used to, start sending data from a new track without un publishing the prior one. There\n   * are thus two track ids - the one which was initially published and should be unpublished when required.\n   * The one whose data is currently being sent, which will be used when removing from connection senders.\n   */\n  getTrackIDBeingSent() {\n    return this.getTrackBeingSent().id;\n  }\n\n  getTrackBeingSent() {\n    return this.enabled ? this.processedTrack || this.nativeTrack : this.nativeTrack;\n  }\n\n  /**\n   * will change the facingMode to environment if current facing mode is user or vice versa.\n   * will be useful when on mobile web to toggle between front and back camera's\n   */\n  async switchCamera() {\n    const currentFacingMode = this.getMediaTrackSettings().facingMode;\n    if (!currentFacingMode || this.source !== 'regular') {\n      HMSLogger.d(this.TAG, 'facingMode not supported');\n      return;\n    }\n    const facingMode = currentFacingMode === HMSFacingMode.ENVIRONMENT ? HMSFacingMode.USER : HMSFacingMode.ENVIRONMENT;\n    this.nativeTrack?.stop();\n    const track = await this.replaceTrackWith(this.buildNewSettings({ facingMode: facingMode, deviceId: undefined }));\n    await this.replaceSender(track, this.enabled);\n    this.nativeTrack = track;\n    this.videoHandler.updateSinks();\n    this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId, facingMode });\n    DeviceStorageManager.updateSelection('videoInput', {\n      deviceId: this.settings.deviceId,\n      groupId: this.nativeTrack.getSettings().groupId,\n    });\n  }\n\n  /**\n   * called when the video is unmuted\n   * @private\n   */\n  private async replaceTrackWith(settings: HMSVideoTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    /**\n     * not stopping previous track results in device in use more frequently, as many devices will not allow even if\n     * you are requesting for a new device.\n     * Note: Do not change the order of this.\n     */\n    prevTrack?.stop();\n    const newTrack = await getVideoTrack(settings);\n    HMSLogger.d(this.TAG, 'replaceTrack, Previous track stopped', prevTrack, 'newTrack', newTrack);\n    // Replace deviceId with actual deviceId when it is default\n    if (this.settings.deviceId === 'default') {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    return newTrack;\n  }\n\n  /**\n   * called when the video is muted. A blank track is used to replace the original track. This is in order to\n   * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.\n   * @private\n   */\n  private async replaceTrackWithBlank() {\n    const prevTrack = this.nativeTrack;\n    const newTrack = LocalTrackManager.getEmptyVideoTrack(prevTrack);\n    prevTrack?.stop();\n    HMSLogger.d(this.TAG, 'replaceTrackWithBlank, Previous track stopped', prevTrack, 'newTrack', newTrack);\n    return newTrack;\n  }\n\n  private async replaceSender(newTrack: MediaStreamTrack, enabled: boolean) {\n    const localStream = this.stream as HMSLocalStream;\n    if (enabled) {\n      await localStream.replaceSenderTrack(this.nativeTrack, this.processedTrack || newTrack);\n    } else {\n      await localStream.replaceSenderTrack(this.processedTrack || this.nativeTrack, newTrack);\n    }\n    await localStream.replaceStreamTrack(this.nativeTrack, newTrack);\n  }\n\n  private buildNewSettings = (settings: Partial<HMSVideoTrackSettings>) => {\n    const { width, height, codec, maxFramerate, maxBitrate, deviceId, advanced, facingMode } = {\n      ...this.settings,\n      ...settings,\n    };\n    const newSettings = new HMSVideoTrackSettings(\n      width,\n      height,\n      codec,\n      maxFramerate,\n      deviceId,\n      advanced,\n      maxBitrate,\n      facingMode,\n    );\n    return newSettings;\n  };\n\n  // eslint-disable-next-line complexity\n  private handleSettingsChange = async (settings: HMSVideoTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrateAndFramerate(this);\n    }\n\n    if (hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced')) {\n      if (this.source === 'video') {\n        const track = await this.replaceTrackWith(settings);\n        await this.replaceSender(track, this.enabled);\n        this.nativeTrack = track;\n        this.videoHandler.updateSinks();\n      } else {\n        await this.nativeTrack.applyConstraints(settings.toConstraints());\n      }\n    }\n  };\n\n  /**\n   * Replace video track with new track on device change\n   * @param settings - VideoSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSVideoTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId') && this.source === 'regular') {\n      if (this.enabled) {\n        delete settings.facingMode;\n        const track = await this.replaceTrackWith(settings);\n        await this.replaceSender(track, this.enabled);\n        this.nativeTrack = track;\n        this.videoHandler.updateSinks();\n      }\n      if (!internal) {\n        DeviceStorageManager.updateSelection('videoInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n\n  /**\n   * This will either remove or update the processedTrack value on the class instance.\n   * It will also replace sender if the processedTrack is updated\n   * @param {MediaStreamTrack|undefined}processedTrack\n   */\n  private removeOrReplaceProcessedTrack = async (processedTrack?: MediaStreamTrack) => {\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n    } else if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  };\n}\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport { VideoElementManager } from './VideoElementManager';\nimport { VideoTrackLayerUpdate } from '../../connection/channel-messages';\nimport {\n  HMSPreferredSimulcastLayer,\n  HMSSimulcastLayer,\n  HMSSimulcastLayerDefinition,\n} from '../../interfaces/simulcast-layers';\nimport { MAINTAIN_TRACK_HISTORY } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { isEmptyTrack } from '../../utils/track';\nimport { HMSRemoteStream } from '../streams';\n\nexport class HMSRemoteVideoTrack extends HMSVideoTrack {\n  private _degraded = false;\n  private _degradedAt: Date | null = null;\n  private _layerDefinitions: HMSSimulcastLayerDefinition[] = [];\n  private history = new TrackHistory();\n  private preferredLayer: HMSPreferredSimulcastLayer = HMSSimulcastLayer.HIGH;\n  private bizTrackId!: string;\n\n  constructor(stream: HMSRemoteStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source);\n    this.setVideoHandler(new VideoElementManager(this));\n  }\n\n  setTrackId(trackId: string) {\n    this.bizTrackId = trackId;\n  }\n\n  get trackId(): string {\n    return this.bizTrackId || super.trackId;\n  }\n\n  public get degraded() {\n    return this._degraded;\n  }\n\n  public get degradedAt() {\n    return this._degradedAt;\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n\n    super.setEnabled(value);\n    this.videoHandler.updateSinks(true);\n  }\n\n  async setPreferredLayer(layer: HMSPreferredSimulcastLayer) {\n    //@ts-ignore\n    if (layer === HMSSimulcastLayer.NONE) {\n      HMSLogger.w(`layer ${HMSSimulcastLayer.NONE} will be ignored`);\n      return;\n    }\n    this.preferredLayer = layer;\n    if (!this.shouldSendVideoLayer(layer, 'preferLayer')) {\n      return;\n    }\n    if (!this.hasSinks()) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}\n        streamId=${this.stream.id} \n        trackId=${this.trackId}\n        saving ${layer}, source=${this.source}\n        Track does not have any sink`,\n      );\n      return;\n    }\n    await this.requestLayer(layer, 'preferLayer');\n    this.pushInHistory(`uiPreferLayer-${layer}`);\n  }\n\n  /**\n   * @deprecated\n   * @returns {HMSSimulcastLayer}\n   */\n  getSimulcastLayer() {\n    return (this.stream as HMSRemoteStream).getSimulcastLayer();\n  }\n\n  getLayer() {\n    return (this.stream as HMSRemoteStream).getVideoLayer();\n  }\n\n  getPreferredLayer() {\n    return this.preferredLayer;\n  }\n\n  replaceTrack(track: HMSRemoteVideoTrack) {\n    this.nativeTrack = track.nativeTrack;\n    if (track.transceiver) {\n      this.transceiver = track.transceiver;\n      // replace dummy streamId with actual streamId retaining all other properties\n      this.stream.updateId(track.stream.id);\n    }\n    this.videoHandler.updateSinks();\n  }\n\n  async addSink(videoElement: HTMLVideoElement, shouldSendVideoLayer = true) {\n    // if the native track is empty track, just request the preferred layer else attach it\n    if (isEmptyTrack(this.nativeTrack)) {\n      await this.requestLayer(this.preferredLayer, 'addSink');\n    } else {\n      super.addSink(videoElement);\n      if (shouldSendVideoLayer) {\n        await this.updateLayer('addSink');\n      }\n    }\n    this.pushInHistory(`uiSetLayer-high`);\n  }\n\n  async removeSink(videoElement: HTMLVideoElement, shouldSendVideoLayer = true) {\n    super.removeSink(videoElement);\n    if (shouldSendVideoLayer) {\n      await this.updateLayer('removeSink');\n    }\n    this._degraded = false;\n    this.pushInHistory('uiSetLayer-none');\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {HMSSimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions() {\n    // send a clone to store as it will freeze the object from further updates\n    return [...this._layerDefinitions];\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: HMSSimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /**\n   * @internal\n   * SFU will change track's layer(degrade or restore) and tell the sdk to update\n   * it locally.\n   * @returns {boolean} isDegraded - returns true if degraded\n   * */\n  setLayerFromServer(layerUpdate: VideoTrackLayerUpdate) {\n    this._degraded =\n      this.enabled &&\n      (layerUpdate.publisher_degraded || layerUpdate.subscriber_degraded) &&\n      layerUpdate.current_layer === HMSSimulcastLayer.NONE;\n    this._degradedAt = this._degraded ? new Date() : this._degradedAt;\n    const currentLayer = layerUpdate.current_layer;\n    HMSLogger.d(\n      `[Remote Track] ${this.logIdentifier} \n      streamId=${this.stream.id} \n      trackId=${this.trackId}\n      layer update from sfu\n      currLayer=${layerUpdate.current_layer}\n      preferredLayer=${layerUpdate.expected_layer}\n      sub_degraded=${layerUpdate.subscriber_degraded}\n      pub_degraded=${layerUpdate.publisher_degraded}\n      isDegraded=${this._degraded}`,\n    );\n    // No need to send preferLayer update, as server has done it already\n    (this.stream as HMSRemoteStream).setVideoLayerLocally(currentLayer, this.logIdentifier, 'setLayerFromServer');\n    this.pushInHistory(`sfuLayerUpdate-${currentLayer}`);\n    return this._degraded;\n  }\n\n  private async updateLayer(source: string) {\n    const newLayer = this.degraded || !this.enabled || !this.hasSinks() ? HMSSimulcastLayer.NONE : this.preferredLayer;\n    if (!this.shouldSendVideoLayer(newLayer, source)) {\n      return;\n    }\n    await this.requestLayer(newLayer, source);\n  }\n\n  private pushInHistory(action: string) {\n    if (MAINTAIN_TRACK_HISTORY) {\n      this.history.push({ name: action, layer: this.getLayer(), degraded: this.degraded });\n    }\n  }\n\n  private async requestLayer(layer: HMSSimulcastLayer, source: string) {\n    try {\n      const response = await (this.stream as HMSRemoteStream).setVideoLayer(\n        layer,\n        this.trackId,\n        this.logIdentifier,\n        source,\n      );\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier} \n      streamId=${this.stream.id}\n      trackId=${this.trackId}\n      Requested layer ${layer}, source=${source}`,\n      );\n      return response;\n    } catch (error) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier} \n      streamId=${this.stream.id}\n      trackId=${this.trackId}\n      Failed to set layer ${layer}, source=${source}\n      error=${(error as Error).message}`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * given the new layer, figure out if the update should be sent to server or not.\n   * It won't be sent if the track is already on the targetLayer. If the track is\n   * degraded though and the target layer is none, update will be sent.\n   * If there are tracks degraded on a page and user paginates away to other page,\n   * it's necessary to send the layer none message to SFU so it knows that the app\n   * is no longer interested in the track and doesn't recover degraded tracks on non\n   * visible pages.\n   *\n   * TODO: if track is degraded, send the update if target layer is lower than current layer\n   * @private\n   */\n  private shouldSendVideoLayer(targetLayer: HMSSimulcastLayer, source: string) {\n    const currLayer = this.getLayer();\n    if (this.degraded && targetLayer === HMSSimulcastLayer.NONE) {\n      return true;\n    }\n    if (currLayer === targetLayer) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}`,\n        `Not sending update, already on layer ${targetLayer}, source=${source}`,\n      );\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * to store history of everything that happened to a remote track which decides\n * it's current layer and degraded status.\n */\nclass TrackHistory {\n  history: Record<string, any>[] = [];\n\n  push(action: Record<string, any>) {\n    action.time = new Date().toISOString().split('T')[1];\n    this.history.push(action);\n  }\n}\n", "import { HMSMediaStream } from './HMSMediaStream';\nimport HMSPublishConnection from '../../connection/publish/publishConnection';\nimport { SimulcastLayer } from '../../interfaces';\nimport { stringifyMediaStreamTrack } from '../../utils/json';\nimport HMSLogger from '../../utils/logger';\nimport { isNode } from '../../utils/support';\nimport { HMSLocalTrack, HMSLocalVideoTrack } from '../tracks';\n\nexport class HMSLocalStream extends HMSMediaStream {\n  /** Connection set when publish is called for the first track */\n  private readonly TAG = '[HMSLocalStream]';\n  private connection: HMSPublishConnection | null = null;\n\n  setConnection(connection: HMSPublishConnection) {\n    this.connection = connection;\n  }\n\n  addTransceiver(track: HMSLocalTrack, simulcastLayers: SimulcastLayer[]) {\n    const transceiver = this.connection!.addTransceiver(track.getTrackBeingSent(), {\n      streams: [this.nativeStream],\n      direction: 'sendonly',\n      sendEncodings: this.getTrackEncodings(track, simulcastLayers),\n    });\n    this.setPreferredCodec(transceiver, track.nativeTrack.kind);\n    track.transceiver = transceiver;\n    return transceiver;\n  }\n\n  async setMaxBitrateAndFramerate(track: HMSLocalTrack): Promise<void> {\n    await this.connection?.setMaxBitrateAndFramerate(track);\n  }\n\n  // @ts-ignore\n  setPreferredCodec(_transceiver: RTCRtpTransceiver, _kind: string) {\n    // TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?\n  }\n\n  replaceStreamTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    this.nativeStream.addTrack(withTrack);\n    this.nativeStream.removeTrack(track);\n    HMSLogger.d(\n      this.TAG,\n      'Native stream tracks after replace',\n      this.nativeStream.getAudioTracks().map(stringifyMediaStreamTrack),\n      `prev Track - ${stringifyMediaStreamTrack(track)}`,\n      `new Track - ${stringifyMediaStreamTrack(withTrack)}`,\n    );\n  }\n\n  /**\n   * On mute and unmute of video tracks as well as for changing cameras, we replace the track with new track,\n   * so as to avoid a renegotiation with the backend and reflect changes faster.\n   * In case of video plugins we need to replace the track sent to remote without stopping the original one. As\n   * if the original is stopped, plugin would stop getting input frames to process. So only the track in the\n   * sender needs to be replaced.\n   */\n  async replaceSenderTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    if (!this.connection || this.connection.connectionState === 'closed') {\n      HMSLogger.d(this.TAG, `publish connection is not initialised or closed`);\n      return;\n    }\n    const sender = this.connection.getSenders().find(sender => sender.track && sender.track.id === track.id);\n\n    if (sender === undefined) {\n      HMSLogger.w(this.TAG, `No sender found for trackId=${track.id}`);\n      return;\n    }\n    await sender.replaceTrack(withTrack);\n  }\n\n  removeSender(track: HMSLocalTrack) {\n    if (!this.connection || this.connection.connectionState === 'closed') {\n      HMSLogger.d(this.TAG, `publish connection is not initialised or closed`);\n      return;\n    }\n    const sender = track.transceiver?.sender;\n    if (!sender) {\n      HMSLogger.w(this.TAG, `No sender found for trackId=${track.trackId}`);\n      return;\n    }\n    this.connection?.removeTrack(sender);\n    const toRemoveLocalTrackIdx = this.tracks.indexOf(track);\n    if (toRemoveLocalTrackIdx !== -1) {\n      this.tracks.splice(toRemoveLocalTrackIdx, 1);\n    } else {\n      HMSLogger.w(this.TAG, `Cannot find ${track.trackId} in locally stored tracks`);\n    }\n  }\n\n  private getTrackEncodings(track: HMSLocalTrack, simulcastLayers: SimulcastLayer[]) {\n    const trackEncodings: RTCRtpEncodingParameters[] = [];\n    if (track instanceof HMSLocalVideoTrack) {\n      if (simulcastLayers.length > 0) {\n        HMSLogger.d(this.TAG, 'Simulcast enabled with layers', simulcastLayers);\n        trackEncodings.push(...simulcastLayers);\n      } else {\n        const encodings: RTCRtpEncodingParameters = { active: this.nativeStream.active };\n        if (track.settings.maxBitrate && !isNode) {\n          encodings.maxBitrate = track.settings.maxBitrate;\n        }\n        trackEncodings.push(encodings);\n      }\n    }\n    return trackEncodings;\n  }\n}\n", "import { HMSMediaStream } from './HMSMediaStream';\nimport HMSSubscribeConnection from '../../connection/subscribe/subscribeConnection';\nimport { HMSSimulcastLayer } from '../../interfaces';\nimport HMSLogger from '../../utils/logger';\n\n/** @internal */\nexport class HMSRemoteStream extends HMSMediaStream {\n  private readonly connection: HMSSubscribeConnection;\n  private audio = true;\n  private video = HMSSimulcastLayer.NONE;\n\n  constructor(nativeStream: MediaStream, connection: HMSSubscribeConnection) {\n    super(nativeStream);\n    this.connection = connection;\n  }\n\n  async setAudio(enabled: boolean, trackId: string, identifier?: string) {\n    if (this.audio === enabled) {\n      return;\n    }\n\n    this.audio = enabled;\n    HMSLogger.d(\n      `[Remote stream] ${identifier || ''} \n    streamId=${this.id}\n    trackId=${trackId}\n    subscribing audio - ${this.audio}`,\n    );\n    await this.connection.sendOverApiDataChannelWithResponse({\n      params: {\n        subscribed: this.audio,\n        track_id: trackId,\n      },\n      method: 'prefer-audio-track-state',\n    });\n  }\n\n  /**\n   * Sets the video layer after receiving new state from SFU. This is used when server side subscribe\n   * degradation is ON.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayerLocally(layer: HMSSimulcastLayer, identifier: string, source: string) {\n    this.video = layer;\n    HMSLogger.d(`[Remote stream] ${identifier}\n    streamId=${this.id}\n    source: ${source}\n    Setting layer field to=${layer}`);\n  }\n\n  /**\n   * Sets the video layer and updates the track state to SFU via api datachannel. This is used when client\n   * side subscribe degradation is ON or client unsubscribes the current track.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayer(layer: HMSSimulcastLayer, trackId: string, identifier: string, source: string) {\n    HMSLogger.d(\n      `[Remote stream] ${identifier} \n      streamId=${this.id}\n      trackId=${trackId} \n      source: ${source} request ${layer} layer`,\n    );\n    this.setVideoLayerLocally(layer, identifier, source);\n    return this.connection.sendOverApiDataChannelWithResponse({\n      params: {\n        max_spatial_layer: this.video,\n        track_id: trackId,\n      },\n      method: 'prefer-video-track-state',\n    });\n  }\n\n  /**\n   * @deprecated\n   * @returns {HMSSimulcastLayer}\n   */\n  getSimulcastLayer() {\n    return this.video;\n  }\n\n  getVideoLayer() {\n    return this.video;\n  }\n\n  isAudioSubscribed() {\n    return this.audio;\n  }\n}\n", "import { getLocalStream } from './media';\nimport { getAudioTrack, getVideoTrack } from './track';\nimport { HMSAction } from '../error/HMSAction';\nimport { HMSException } from '../error/HMSException';\nimport { HMSAudioTrackSettingsBuilder } from '../media/settings/HMSAudioTrackSettings';\nimport { HMSVideoTrackSettingsBuilder } from '../media/settings/HMSVideoTrackSettings';\n\n// Errors out when there's any device error, returns false when there are no device errors.\nexport async function validateDeviceAV() {\n  const videoTrackSettings = new HMSVideoTrackSettingsBuilder().build();\n  const audioTrackSettings = new HMSAudioTrackSettingsBuilder().build();\n  /**\n   * Check audio failure.\n   * If audio failure - check AV failure.\n   * If AV failure - throw AV failure.\n   * If AV passed - throw audio failure.\n   *\n   * If audio passed - check video failure.\n   * If video failure - throw video failure.\n   * If video passed - no error - return false.\n   */\n  try {\n    const track = await getAudioTrack(audioTrackSettings);\n    track.stop();\n  } catch (audioError) {\n    if (isHMSDeviceError(audioError)) {\n      const stream = await getLocalStream({ audio: false, video: true });\n      stream.getTracks().forEach(track => track.stop());\n      throw audioError;\n    }\n  }\n\n  const track = await getVideoTrack(videoTrackSettings);\n  track.stop();\n  return false;\n}\n\nfunction isHMSDeviceError(error: any) {\n  return error instanceof HMSException && error.action === HMSAction.TRACK;\n}\n", "import AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { EventBus } from '../events/EventBus';\nimport {\n  HMSPeerStats,\n  HMSTrackStats,\n  MissingInboundStats,\n  PeerConnectionType,\n  RTCRemoteInboundRtpStreamStats,\n} from '../interfaces/webrtc-stats';\nimport { HMSLocalTrack, HMSRemoteTrack } from '../media/tracks';\nimport HMSLogger from '../utils/logger';\nimport { isPresent } from '../utils/validations';\n\nexport const getLocalTrackStats = async (\n  eventBus: EventBus,\n  track: HMSLocalTrack,\n  peerName?: string,\n  prevTrackStats?: Record<string, HMSTrackStats>,\n): Promise<Record<string, HMSTrackStats> | undefined> => {\n  let trackReport: RTCStatsReport | undefined;\n  const trackStats: Record<string, HMSTrackStats> = {};\n  if (!track.transceiver?.sender.track) {\n    return;\n  }\n  try {\n    trackReport = await track.transceiver.sender.getStats();\n    const mimeTypes: { [key: string]: string } = {}; // codecId -> mimeType\n    const outbound: Record<string, RTCOutboundRtpStreamStats> = {};\n    const inbound: Record<string, RTCInboundRtpStreamStats & MissingInboundStats> = {};\n    trackReport?.forEach(stat => {\n      switch (stat.type) {\n        case 'outbound-rtp':\n          outbound[stat.id] = stat;\n          break;\n        case 'remote-inbound-rtp':\n          inbound[stat.ssrc] = stat;\n          break;\n        case 'codec':\n          mimeTypes[stat.id] = stat.mimeType;\n          break;\n        default:\n          break;\n      }\n    });\n\n    Object.keys({ ...outbound }).forEach(stat => {\n      const codecId = outbound[stat]?.codecId;\n      const mimeType = codecId ? mimeTypes[codecId] : undefined;\n      let codec: string | undefined;\n      if (mimeType) {\n        codec = mimeType.substring(mimeType.indexOf('/') + 1);\n      }\n      const out = outbound[stat];\n      const inStats = inbound[out.ssrc];\n      trackStats[stat] = {\n        ...out,\n        bitrate: computeBitrate('bytesSent', out, prevTrackStats?.[stat]),\n        packetsLost: inStats?.packetsLost,\n        jitter: inStats?.jitter,\n        roundTripTime: inStats?.roundTripTime,\n        totalRoundTripTime: inStats?.totalRoundTripTime,\n        peerName,\n        peerID: track.peerId,\n        enabled: track.enabled,\n        codec,\n      };\n    });\n  } catch (err: any) {\n    eventBus.analytics.publish(\n      AnalyticsEventFactory.rtcStatsFailed(\n        ErrorFactory.WebrtcErrors.StatsFailed(\n          HMSAction.TRACK,\n          `Error getting local track stats ${track.trackId} - ${err.message}`,\n        ),\n      ),\n    );\n    HMSLogger.w('[HMSWebrtcStats]', 'Error in getting local track stats', track, err, (err as Error).name);\n  }\n  return trackStats;\n};\n\nexport const getTrackStats = async (\n  eventBus: EventBus,\n  track: HMSRemoteTrack,\n  peerName?: string,\n  prevTrackStats?: HMSTrackStats,\n): Promise<HMSTrackStats | undefined> => {\n  let trackReport: RTCStatsReport | undefined;\n  try {\n    trackReport = await track.transceiver?.receiver.getStats();\n  } catch (err: any) {\n    eventBus.analytics.publish(\n      AnalyticsEventFactory.rtcStatsFailed(\n        ErrorFactory.WebrtcErrors.StatsFailed(\n          HMSAction.TRACK,\n          `Error getting remote track stats ${track.trackId} - ${err.message}`,\n        ),\n      ),\n    );\n    HMSLogger.w('[HMSWebrtcStats]', 'Error in getting remote track stats', track, err);\n  }\n  const trackStats = getRelevantStatsFromTrackReport(trackReport);\n\n  const bitrate = computeBitrate('bytesReceived', trackStats, prevTrackStats);\n\n  const packetsLostRate = computeStatRate('packetsLost', trackStats, prevTrackStats);\n\n  if (trackStats?.remote) {\n    Object.assign(trackStats.remote, {\n      packetsLostRate: computeStatRate('packetsLost', trackStats.remote, prevTrackStats?.remote),\n    });\n  }\n\n  return (\n    trackStats &&\n    Object.assign(trackStats, {\n      bitrate,\n      packetsLostRate,\n      peerId: track.peerId,\n      enabled: track.enabled,\n      peerName,\n      codec: trackStats.codec,\n    })\n  );\n};\n\nconst getRelevantStatsFromTrackReport = (trackReport?: RTCStatsReport) => {\n  let streamStats: RTCInboundRtpStreamStats | RTCOutboundRtpStreamStats | undefined;\n  // Valid by Webrtc spec, not in TS\n  // let remoteStreamStats: RTCRemoteInboundRtpStreamStats | RTCRemoteOutboundRtpStreamStats;\n  let remoteStreamStats: RTCRemoteInboundRtpStreamStats | undefined;\n\n  const mimeTypes: { [key: string]: string } = {}; // codecId -> mimeType\n  trackReport?.forEach(stat => {\n    switch (stat.type) {\n      case 'inbound-rtp':\n        streamStats = stat;\n        break;\n      case 'outbound-rtp':\n        streamStats = stat;\n        break;\n      case 'remote-inbound-rtp':\n        remoteStreamStats = stat;\n        break;\n      case 'codec':\n        mimeTypes[stat.id] = stat.mimeType;\n        break;\n      default:\n        break;\n    }\n  });\n\n  const mimeType = streamStats?.codecId ? mimeTypes[streamStats.codecId] : undefined;\n  let codec: string | undefined;\n  if (mimeType) {\n    codec = mimeType.substring(mimeType.indexOf('/') + 1);\n  }\n\n  return (\n    streamStats &&\n    Object.assign(streamStats, {\n      remote: remoteStreamStats,\n      codec: codec,\n    })\n  );\n};\n\nexport const getLocalPeerStatsFromReport = (\n  type: PeerConnectionType,\n  report?: RTCStatsReport,\n  prevStats?: HMSPeerStats,\n): (RTCIceCandidatePairStats & { bitrate: number }) | undefined => {\n  const activeCandidatePair = getActiveCandidatePairFromReport(report);\n  const bitrate = computeBitrate(\n    (type === 'publish' ? 'bytesSent' : 'bytesReceived') as any,\n    activeCandidatePair,\n    prevStats && prevStats[type],\n  );\n\n  return activeCandidatePair && Object.assign(activeCandidatePair, { bitrate });\n};\n\nexport const getActiveCandidatePairFromReport = (report?: RTCStatsReport): RTCIceCandidatePairStats | undefined => {\n  let activeCandidatePair: RTCIceCandidatePairStats | undefined;\n  report?.forEach(stat => {\n    if (stat.type === 'transport') {\n      // TS doesn't have correct types for RTCStatsReports\n      // @ts-expect-error\n      activeCandidatePair = report?.get(stat.selectedCandidatePairId);\n    }\n  });\n\n  // Fallback for Firefox.\n  if (!activeCandidatePair) {\n    report?.forEach(stat => {\n      if (stat.type === 'candidate-pair' && stat.selected) {\n        activeCandidatePair = stat;\n      }\n    });\n  }\n\n  return activeCandidatePair;\n};\n\nexport const getPacketsLostAndJitterFromReport = (report?: RTCStatsReport): { packetsLost: number; jitter: number } => {\n  const result = { packetsLost: 0, jitter: 0 };\n  report?.forEach(stat => {\n    if (stat.packetsLost) {\n      result.packetsLost += stat.packetsLost;\n    }\n    if (stat.jitter > result.jitter) {\n      result.jitter = stat.jitter;\n    }\n  });\n\n  return result;\n};\n\nexport const union = <T>(arr1: T[], arr2: T[]): T[] => {\n  return Array.from(new Set(arr1.concat(arr2)));\n};\n\n/**\n * Ref: https://github.dev/peermetrics/webrtc-stats/blob/b5c1fed68325543e6f563c6d3f4450a4b51e12b7/src/utils.ts#L62\n */\nexport const computeBitrate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => computeStatRate(statName, newReport, oldReport) * 8; // Bytes to bits\n\nconst computeStatRate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => {\n  const newVal = newReport && newReport[statName];\n  const oldVal = oldReport ? oldReport[statName] : null;\n  const conditions = [newReport, oldReport, isPresent(newVal), isPresent(oldVal)];\n  if (conditions.every(condition => !!condition)) {\n    // Type not null checked in `isPresent`\n    // * 1000 - ms to s\n    return (\n      computeNumberRate(\n        newVal as unknown as number,\n        oldVal as unknown as number,\n        newReport?.timestamp,\n        oldReport?.timestamp,\n      ) * 1000\n    );\n  } else {\n    return 0;\n  }\n};\n\nexport const computeNumberRate = (newVal?: number, oldVal?: number, newTimestamp?: number, oldTimestamp?: number) => {\n  if (isPresent(newVal) && isPresent(oldVal) && newTimestamp && oldTimestamp) {\n    return ((newVal as number) - (oldVal as number)) / (newTimestamp - oldTimestamp);\n  } else {\n    return 0;\n  }\n};\n", "import {\n  computeNumberRate,\n  getLocalPeerStatsFromReport,\n  getLocalTrackStats,\n  getPacketsLostAndJitterFromReport,\n  getTrackStats,\n  union,\n} from './utils';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { EventBus } from '../events/EventBus';\nimport { HMSPeerStats, HMSTrackStats, PeerConnectionType } from '../interfaces/webrtc-stats';\nimport { HMSLocalTrack, HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\n\nexport class HMSWebrtcStats {\n  private readonly TAG = '[HMSWebrtcStats]';\n  private localPeerID?: string;\n  private peerStats: Record<string, HMSPeerStats> = {};\n  private remoteTrackStats: Record<string, HMSTrackStats> = {};\n  private localTrackStats: Record<string, Record<string, HMSTrackStats>> = {};\n\n  /**\n   * Removed localPeerID check in other places as it will be present before\n   * this is initialized\n   */\n  constructor(\n    private getStats: Record<PeerConnectionType, RTCPeerConnection['getStats'] | undefined>,\n    private store: IStore,\n    private readonly eventBus: EventBus,\n  ) {\n    this.localPeerID = this.store.getLocalPeer()?.peerId;\n  }\n\n  getLocalPeerStats = (): HMSPeerStats | undefined => {\n    return this.peerStats[this.localPeerID!];\n  };\n\n  getRemoteTrackStats = (trackId: string): HMSTrackStats | undefined => {\n    return this.remoteTrackStats[trackId];\n  };\n\n  getLocalTrackStats = () => {\n    return this.localTrackStats;\n  };\n\n  /**\n   * @internal\n   */\n  updateStats = async () => {\n    await this.updateLocalPeerStats();\n    await this.updateLocalTrackStats();\n    await this.updateRemoteTrackStats();\n  };\n\n  private updateLocalPeerStats = async () => {\n    const prevLocalPeerStats = this.getLocalPeerStats();\n    let publishReport: RTCStatsReport | undefined;\n    try {\n      publishReport = await this.getStats.publish?.();\n    } catch (err: any) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.rtcStatsFailed(ErrorFactory.WebrtcErrors.StatsFailed(HMSAction.PUBLISH, err.message)),\n      );\n      HMSLogger.w(this.TAG, 'Error in getting publish stats', err);\n    }\n    const publishStats: HMSPeerStats['publish'] | undefined =\n      publishReport && getLocalPeerStatsFromReport('publish', publishReport, prevLocalPeerStats);\n\n    let subscribeReport: RTCStatsReport | undefined;\n    try {\n      subscribeReport = await this.getStats.subscribe?.();\n    } catch (err: any) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.rtcStatsFailed(ErrorFactory.WebrtcErrors.StatsFailed(HMSAction.SUBSCRIBE, err.message)),\n      );\n      HMSLogger.w(this.TAG, 'Error in getting subscribe stats', err);\n    }\n    const baseSubscribeStats =\n      subscribeReport && getLocalPeerStatsFromReport('subscribe', subscribeReport, prevLocalPeerStats);\n    const { packetsLost, jitter } = getPacketsLostAndJitterFromReport(subscribeReport);\n    const packetsLostRate = computeNumberRate(\n      packetsLost,\n      prevLocalPeerStats?.subscribe?.packetsLost,\n      baseSubscribeStats?.timestamp,\n      prevLocalPeerStats?.subscribe?.timestamp,\n    );\n\n    const subscribeStats: HMSPeerStats['subscribe'] =\n      baseSubscribeStats && Object.assign(baseSubscribeStats, { packetsLostRate, jitter, packetsLost });\n\n    this.peerStats[this.localPeerID!] = { publish: publishStats, subscribe: subscribeStats };\n  };\n\n  private updateRemoteTrackStats = async () => {\n    const tracks = Array.from(this.store.getTracksMap().values()).filter(\n      track => track instanceof HMSRemoteVideoTrack || track instanceof HMSRemoteAudioTrack,\n    );\n    const trackIds = tracks.map(track => track.trackId);\n    Object.keys(this.remoteTrackStats).forEach(trackId => {\n      if (!trackIds.includes(trackId)) {\n        delete this.remoteTrackStats[trackId];\n      }\n    });\n    for (const track of tracks) {\n      const peerName = track.peerId && this.store.getPeerById(track.peerId)?.name;\n      const prevTrackStats = this.getRemoteTrackStats(track.trackId);\n      const trackStats = await getTrackStats(this.eventBus, track as HMSRemoteTrack, peerName, prevTrackStats);\n      if (trackStats) {\n        this.remoteTrackStats[track.trackId] = trackStats;\n      }\n    }\n  };\n\n  private updateLocalTrackStats = async () => {\n    const tracks = this.store.getLocalPeerTracks().reduce<Record<string, HMSLocalTrack>>((res, track) => {\n      res[track.getTrackIDBeingSent()] = track;\n      return res;\n    }, {});\n    const trackIDs = union(Object.keys(this.localTrackStats), Object.keys(tracks));\n    for (const trackID of trackIDs) {\n      const track = tracks[trackID] as HMSLocalTrack;\n      if (track) {\n        const peerName = this.store.getLocalPeer()?.name;\n        const trackStats = await getLocalTrackStats(this.eventBus, track, peerName, this.localTrackStats[trackID]);\n        if (trackStats) {\n          this.localTrackStats[trackID] = trackStats;\n        }\n      } else {\n        delete this.localTrackStats[trackID];\n      }\n    }\n  };\n}\n", "import { HMSWebrtcStats } from './HMSWebrtcStats';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { EventBus } from '../events/EventBus';\nimport { IStore } from '../sdk/store';\nimport { RTC_STATS_MONITOR_INTERVAL } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\n\nexport class HMSWebrtcInternals {\n  private readonly TAG = '[HMSWebrtcInternals]';\n  private readonly interval = RTC_STATS_MONITOR_INTERVAL;\n  private isMonitored = false;\n  private hmsStats?: HMSWebrtcStats;\n\n  constructor(\n    private readonly store: IStore,\n    private readonly eventBus: EventBus,\n    private publishConnection?: RTCPeerConnection,\n    private subscribeConnection?: RTCPeerConnection,\n  ) {}\n\n  getPublishPeerConnection() {\n    return this.publishConnection;\n  }\n\n  getSubscribePeerConnection() {\n    return this.subscribeConnection;\n  }\n\n  getCurrentStats() {\n    return this.hmsStats;\n  }\n\n  onStatsChange(statsChangeCb: (stats: HMSWebrtcStats) => void) {\n    this.eventBus.statsUpdate.subscribe(statsChangeCb);\n    return () => {\n      this.eventBus.statsUpdate.unsubscribe(statsChangeCb);\n    };\n  }\n\n  private handleStatsUpdate = async () => {\n    await this.hmsStats?.updateStats();\n    this.eventBus.statsUpdate.publish(this.hmsStats);\n  };\n\n  /**\n   *\n   * @internal\n   */\n  setPeerConnections({ publish, subscribe }: { publish?: RTCPeerConnection; subscribe?: RTCPeerConnection }) {\n    this.publishConnection = publish;\n    this.subscribeConnection = subscribe;\n\n    this.hmsStats = new HMSWebrtcStats(\n      {\n        publish: this.publishConnection?.getStats.bind(this.publishConnection),\n        subscribe: this.subscribeConnection?.getStats.bind(this.subscribeConnection),\n      },\n      this.store,\n      this.eventBus,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  async start() {\n    if (this.isMonitored) {\n      HMSLogger.d(this.TAG, 'Already started');\n      return;\n    }\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting Webrtc Stats Monitor');\n    this.startLoop()\n      .then(() => HMSLogger.d(this.TAG, 'Stopping Webrtc Stats Monitor'))\n      .catch(e => {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.rtcStatsFailed(ErrorFactory.WebrtcErrors.StatsFailed(HMSAction.PUBLISH, e.message)),\n        );\n        HMSLogger.e(this.TAG, e.message);\n      });\n  }\n\n  private stop() {\n    this.isMonitored = false;\n  }\n\n  private async startLoop() {\n    while (this.isMonitored) {\n      await this.handleStatsUpdate();\n      await sleep(this.interval);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  cleanup() {\n    this.stop();\n    this.eventBus.statsUpdate.removeAllListeners();\n  }\n}\n", "import AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { EventBus } from '../events/EventBus';\nimport { HMSUpdateListener } from '../interfaces';\nimport { NetworkHealth, ScoreMap } from '../signal/init/models';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\n\nexport class NetworkTestManager {\n  private readonly TAG = '[NetworkTestManager]';\n  private controller = new AbortController();\n  private score?: number;\n  constructor(private eventBus: EventBus, private listener?: HMSUpdateListener) {}\n\n  start = async (networkHealth: NetworkHealth) => {\n    if (!networkHealth) {\n      return;\n    }\n    const { url, timeout, scoreMap } = networkHealth;\n    const signal = this.controller.signal;\n\n    const startTime = Date.now();\n    let downloadedSize = 0;\n    const timeoutPromise = sleep(timeout).then(() => {\n      this.controller.abort();\n    });\n    try {\n      const res = await fetch(`${url}?${Date.now()}`, { signal });\n      const reader = res.body?.getReader();\n      if (!reader) {\n        throw Error('unable to process request');\n      }\n      const readData = async () => {\n        if (!reader) {\n          return;\n        }\n        try {\n          let completed = false;\n          while (!completed) {\n            const { value, done } = await reader.read();\n            completed = done;\n            if (value) {\n              downloadedSize += value.byteLength;\n              this.sendScore({ scoreMap, downloadedSize, startTime });\n            }\n          }\n        } catch (error) {\n          if ((error as Error).name !== 'AbortError') {\n            HMSLogger.d(this.TAG, error);\n          }\n        }\n      };\n\n      return Promise.race([readData(), timeoutPromise])\n        .then(() => {\n          this.sendScore({ scoreMap, downloadedSize, startTime, finished: true });\n        })\n        .catch(error => {\n          HMSLogger.d(this.TAG, error);\n          this.updateScoreToListener(0);\n          this.eventBus.analytics.publish(\n            AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n          );\n        });\n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        HMSLogger.d(this.TAG, error);\n        this.updateScoreToListener(0);\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n        );\n      } else {\n        HMSLogger.d(this.TAG, error);\n      }\n    }\n  };\n\n  stop = () => {\n    if (!this.controller.signal.aborted) {\n      this.controller.abort();\n    }\n  };\n\n  private sendScore = ({\n    scoreMap,\n    downloadedSize,\n    startTime,\n    finished = false,\n  }: {\n    scoreMap: ScoreMap;\n    downloadedSize: number;\n    startTime: number;\n    finished?: boolean;\n  }) => {\n    const totalTimeInSecs = (Date.now() - startTime) / 1000;\n    const sizeInKB = downloadedSize / 1024;\n    const bitrate = (sizeInKB / totalTimeInSecs) * 8;\n    let calculatedScore = -1;\n    for (const score in scoreMap) {\n      const thresholds = scoreMap[score];\n      if (bitrate >= thresholds.low && (!thresholds.high || bitrate <= thresholds.high)) {\n        calculatedScore = Number(score);\n      }\n    }\n    this.updateScoreToListener(calculatedScore);\n    if (finished) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.previewNetworkQuality({ score: calculatedScore, downLink: bitrate.toFixed(2) }),\n      );\n    }\n  };\n\n  private updateScoreToListener(newQualityScore: number) {\n    if (newQualityScore === this.score) {\n      return;\n    }\n    this.score = newQualityScore;\n    this.listener?.onNetworkQuality?.(newQualityScore);\n  }\n}\n", "import { IStore } from './store';\nimport { DeviceManager } from '../device-manager';\nimport { HMSRole } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport { SimulcastLayers } from '../interfaces/simulcast-layers';\nimport { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport { HMSLocalTrack } from '../media/tracks';\nimport ITransport from '../transport/ITransport';\n\nexport default class RoleChangeManager {\n  constructor(\n    private store: IStore,\n    private transport: ITransport,\n    private deviceManager: DeviceManager,\n    private publish: (settings: InitialSettings) => Promise<void>,\n    private removeAuxiliaryTrack: (trackId: string) => void,\n    private listener?: HMSUpdateListener,\n  ) {}\n\n  handleLocalPeerRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const localPeer = this.store.getLocalPeer();\n\n    if (!localPeer) {\n      return;\n    }\n\n    await this.diffRolesAndPublishTracks({ oldRole, newRole });\n    this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, localPeer);\n  };\n\n  diffRolesAndPublishTracks = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const wasPublishing = new Set(oldRole.publishParams.allowed);\n    const isPublishing = new Set(newRole.publishParams.allowed);\n\n    const removeVideo = this.removeTrack(wasPublishing, isPublishing, 'video');\n\n    const removeAudio = this.removeTrack(wasPublishing, isPublishing, 'audio');\n    const removeScreen = this.removeTrack(wasPublishing, isPublishing, 'screen');\n\n    const videoHasSimulcastDifference = this.hasSimulcastDifference(\n      oldRole.publishParams.simulcast?.video,\n      newRole.publishParams.simulcast?.video,\n    );\n    const screenHasSimulcastDifference = this.hasSimulcastDifference(\n      oldRole.publishParams.simulcast?.screen,\n      newRole.publishParams.simulcast?.screen,\n    );\n\n    const prevVideoEnabled = this.store.getLocalPeer()?.videoTrack?.enabled;\n\n    await this.removeAudioTrack(removeAudio);\n    await this.removeVideoTracks(removeVideo || videoHasSimulcastDifference);\n    await this.removeScreenTracks(removeScreen || screenHasSimulcastDifference);\n\n    const initialSettings = this.store.getConfig()?.settings || {\n      isAudioMuted: true,\n      isVideoMuted: true,\n      audioInputDeviceId: 'default',\n      videoDeviceId: 'default',\n      audioOutputDeviceId: 'default',\n    };\n\n    if (videoHasSimulcastDifference) {\n      initialSettings.isVideoMuted = !prevVideoEnabled;\n    }\n\n    // call publish with new settings, local track manager will diff policies\n    await this.publish(initialSettings);\n    await this.syncDevices(initialSettings, newRole);\n  };\n\n  private async syncDevices(initialSettings: InitialSettings, newRole: HMSRole) {\n    if ((!initialSettings.isAudioMuted || !initialSettings.isVideoMuted) && newRole.publishParams.allowed.length > 0) {\n      await this.deviceManager.init(true);\n    }\n  }\n  private async removeVideoTracks(removeVideo: boolean) {\n    if (!removeVideo) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    // TODO check auxillary tracks for regular audio and video too\n    if (localPeer?.videoTrack) {\n      // TODO: stop processed track and cleanup plugins loop non async\n      // vb can throw change role off otherwise\n      if (localPeer.videoTrack.isPublished) {\n        await this.transport.unpublish([localPeer.videoTrack]);\n      } else {\n        await localPeer.videoTrack.cleanup();\n      }\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.videoTrack, localPeer);\n      localPeer.videoTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'video');\n  }\n\n  private async removeAudioTrack(removeAudio: boolean) {\n    if (!removeAudio) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.audioTrack) {\n      if (localPeer.audioTrack.isPublished) {\n        await this.transport.unpublish([localPeer.audioTrack]);\n      } else {\n        await localPeer.audioTrack.cleanup();\n      }\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.audioTrack, localPeer);\n      localPeer.audioTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'audio');\n  }\n\n  private async removeScreenTracks(removeScreen: boolean) {\n    if (!removeScreen) {\n      return;\n    }\n    await this.removeAuxTracks(track => track.source === 'screen');\n  }\n\n  private async removeAuxTracks(predicate: (track: HMSLocalTrack) => boolean) {\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.auxiliaryTracks) {\n      const localAuxTracks = [...localPeer.auxiliaryTracks];\n      for (const track of localAuxTracks) {\n        if (predicate(track)) {\n          await this.removeAuxiliaryTrack(track.trackId);\n        }\n      }\n    }\n  }\n\n  private removeTrack(wasPublishing: Set<string>, isPublishing: Set<string>, type: string) {\n    return wasPublishing.has(type) && !isPublishing.has(type);\n  }\n\n  private hasSimulcastDifference(oldLayers?: SimulcastLayers, newLayers?: SimulcastLayers) {\n    if (!oldLayers && !newLayers) {\n      return false;\n    }\n    if (oldLayers?.layers?.length !== newLayers?.layers?.length) {\n      return true;\n    }\n\n    // return true if anyone layer has different maxBitrate/maxFramerate\n    return !!oldLayers?.layers?.some(layer => {\n      const newLayer = newLayers?.layers?.find(newLayer => newLayer.rid === layer.rid);\n      return newLayer?.maxBitrate !== layer.maxBitrate || newLayer?.maxFramerate !== layer.maxFramerate;\n    });\n  }\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\nimport {\n  CLIENT_ANAYLTICS_PROD_ENDPOINT,\n  CLIENT_ANAYLTICS_QA_ENDPOINT,\n  CLIENT_ANAYLTICS_STORAGE_LIMIT,\n} from '../utils/constants';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\nimport { ENV } from '../utils/support';\n\ninterface ClientEventBody {\n  event: string;\n  event_id: string;\n  peer: {\n    peer_id?: string;\n    role?: string;\n    joined_at?: number;\n    left_at?: number;\n    room_id?: string;\n    room_name?: string;\n    session_started_at?: number;\n    user_data?: string;\n    user_name?: string;\n    template_id?: string;\n    session_id?: string;\n  };\n  timestamp: number;\n  cluster: {\n    websocket_url: string;\n  };\n  payload: Record<string, any>;\n  device_id: string;\n}\n\nclass ClientAnalyticsTransport implements IAnalyticsTransportProvider {\n  readonly TAG = '[HTTPAnalyticsTransport]';\n  private failedEvents = new LocalStorage<AnalyticsEvent[]>('client-events');\n  isConnected = true;\n  private env: null | ENV = null;\n  private websocketURL = '';\n\n  setEnv(env: ENV) {\n    this.env = env;\n    this.flushFailedEvents();\n  }\n\n  setWebsocketEndpoint(ws: string) {\n    this.websocketURL = ws;\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.env || !this.websocketURL) {\n      this.addEventToStorage(event);\n      return;\n    }\n    const requestBody: ClientEventBody = {\n      event: event.name,\n      payload: event.properties,\n      event_id: String(event.timestamp),\n      peer: event.metadata.peer,\n      timestamp: event.timestamp,\n      device_id: event.device_id,\n      cluster: {\n        websocket_url: this.websocketURL,\n      },\n    };\n    const url = this.env === ENV.PROD ? CLIENT_ANAYLTICS_PROD_ENDPOINT : CLIENT_ANAYLTICS_QA_ENDPOINT;\n    fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${event.metadata.token}`,\n        user_agent_v2: event.metadata.userAgent,\n      },\n      body: JSON.stringify(requestBody),\n    })\n      .then(response => {\n        // Ignore invalid token or expired token messages\n        if (response.status === 401) {\n          this.removeFromStorage(event);\n          return;\n        }\n        if (response.status !== 200) {\n          throw Error(response.statusText);\n        }\n        this.removeFromStorage(event);\n      })\n      .catch(error => {\n        HMSLogger.v(this.TAG, 'Failed to send event', error, event);\n        this.addEventToStorage(event);\n      });\n  }\n  flushFailedEvents() {\n    const events = this.failedEvents.get();\n    events?.forEach(event => this.sendEvent(event));\n  }\n\n  private addEventToStorage(event: AnalyticsEvent): void {\n    const existingEvents = this.failedEvents.get() || [];\n    if (!existingEvents.find(existingEvent => existingEvent.timestamp === event.timestamp)) {\n      if (existingEvents.length === CLIENT_ANAYLTICS_STORAGE_LIMIT) {\n        existingEvents.shift();\n      }\n      existingEvents.push(event);\n      this.failedEvents.set(existingEvents);\n    }\n  }\n\n  private removeFromStorage(event: AnalyticsEvent): void {\n    const events = this.failedEvents.get() || [];\n    const index = events.findIndex(storageEvent => storageEvent.timestamp === event.timestamp);\n    if (index > -1) {\n      events.splice(index, 1);\n      this.failedEvents.set(events);\n    }\n  }\n}\n\nexport const HTTPAnalyticsTransport = new ClientAnalyticsTransport();\n", "import { IStore, KnownRoles, TrackStateEntry } from './IStore';\nimport { HTTPAnalyticsTransport } from '../../analytics/HTTPAnalyticsTransport';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { HMSConfig, HMSFrameworkInfo, HMSPoll, HMSSpeaker } from '../../interfaces';\nimport { SelectedDevices } from '../../interfaces/devices';\nimport { IErrorListener } from '../../interfaces/error-listener';\nimport {\n  HMSSimulcastLayerDefinition,\n  RID,\n  SimulcastLayer,\n  SimulcastLayers,\n  simulcastMapping,\n} from '../../interfaces/simulcast-layers';\nimport {\n  HMSAudioTrack,\n  HMSLocalTrack,\n  HMSRemoteAudioTrack,\n  HMSRemoteVideoTrack,\n  HMSTrack,\n  HMSTrackSource,\n  HMSTrackType,\n  HMSVideoTrack,\n} from '../../media/tracks';\nimport { PolicyParams } from '../../notification-manager';\nimport { ENV } from '../../utils/support';\nimport { createUserAgent } from '../../utils/user-agent';\nimport HMSRoom from '../models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from '../models/peer';\n\nclass Store implements IStore {\n  private room?: HMSRoom;\n  private knownRoles: KnownRoles = {};\n  private localPeerId?: string;\n  private peers: Record<string, HMSPeer> = {};\n  private tracks = new Map<HMSTrack, HMSTrack>();\n  private templateAppData?: Record<string, string>;\n  // Not used currently. Will be used exclusively for preview tracks.\n  // private previewTracks: Record<string, HMSTrack> = {};\n  private peerTrackStates: Record<string, TrackStateEntry> = {};\n  private speakers: HMSSpeaker[] = [];\n  private videoLayers?: SimulcastLayers;\n  // private screenshareLayers?: SimulcastLayers;\n  private config?: HMSConfig;\n  private errorListener?: IErrorListener;\n  private roleDetailsArrived = false;\n  private env: ENV = ENV.PROD;\n  private simulcastEnabled = false;\n  private userAgent: string = createUserAgent(this.env);\n  private polls = new Map<string, HMSPoll>();\n\n  getConfig() {\n    return this.config;\n  }\n\n  setSimulcastEnabled(enabled: boolean) {\n    this.simulcastEnabled = enabled;\n  }\n\n  getEnv() {\n    return this.env;\n  }\n\n  getPublishParams() {\n    const peer = this.getLocalPeer();\n    const role = peer?.asRole || peer?.role;\n    return role?.publishParams;\n  }\n\n  getRoom() {\n    return this.room;\n  }\n\n  getPolicyForRole(role: string) {\n    return this.knownRoles[role];\n  }\n\n  getKnownRoles() {\n    return this.knownRoles;\n  }\n\n  getTemplateAppData() {\n    return this.templateAppData;\n  }\n\n  getLocalPeer() {\n    if (this.localPeerId && this.peers[this.localPeerId]) {\n      return this.peers[this.localPeerId] as HMSLocalPeer;\n    }\n    return undefined;\n  }\n\n  getRemotePeers() {\n    return Object.values(this.peers).filter(peer => !peer.isLocal) as HMSRemotePeer[];\n  }\n\n  getPeers(): HMSPeer[] {\n    return Object.values(this.peers);\n  }\n\n  getPeerMap() {\n    return this.peers;\n  }\n\n  getPeerById(peerId: string) {\n    if (this.peers[peerId]) {\n      return this.peers[peerId];\n    }\n    return undefined;\n  }\n\n  getTracksMap() {\n    return this.tracks;\n  }\n\n  getTracks() {\n    return Array.from(this.tracks.values());\n  }\n\n  getVideoTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.VIDEO) as HMSVideoTrack[];\n  }\n\n  getRemoteVideoTracks() {\n    return this.getTracks().filter(track => track instanceof HMSRemoteVideoTrack) as HMSRemoteVideoTrack[];\n  }\n\n  getAudioTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.AUDIO) as HMSAudioTrack[];\n  }\n\n  getPeerTracks(peerId?: string) {\n    const peer = peerId ? this.peers[peerId] : undefined;\n    const tracks: HMSTrack[] = [];\n    peer?.videoTrack && tracks.push(peer.videoTrack);\n    peer?.audioTrack && tracks.push(peer.audioTrack);\n    return tracks.concat(peer?.auxiliaryTracks || []);\n  }\n\n  getLocalPeerTracks() {\n    return this.getPeerTracks(this.localPeerId) as HMSLocalTrack[];\n  }\n\n  hasTrack(track: HMSTrack) {\n    return this.tracks.has(track);\n  }\n\n  getTrackById(trackId: string) {\n    const track = Array.from(this.tracks.values()).find(track => track.trackId === trackId);\n    if (track) {\n      return track;\n    }\n    const localPeer = this.getLocalPeer();\n    /**\n     * handle case of audio level coming from server for local peer's track where local peer\n     * didn't initially gave audio permission. So track.firstTrackId is that of dummy track and\n     * this.tracks[trackId] doesn't exist.\n     * Example repro which this solves -\n     * - call preview with audio muted, unmute audio in preview then join the room, now initial\n     * track id is that from dummy track but the track id which server knows will be different\n     */\n    if (localPeer) {\n      if (localPeer.audioTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.audioTrack;\n      } else if (localPeer.videoTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.videoTrack;\n      }\n    }\n    return undefined;\n  }\n\n  getPeerByTrackId(trackId: string) {\n    const track = Array.from(this.tracks.values()).find(track => track.trackId === trackId);\n    return track?.peerId ? this.peers[track.peerId] : undefined;\n  }\n\n  getSpeakers() {\n    return this.speakers;\n  }\n\n  getSpeakerPeers() {\n    return this.speakers.map(speaker => speaker.peer);\n  }\n\n  getUserAgent() {\n    return this.userAgent;\n  }\n\n  createAndSetUserAgent(frameworkInfo?: HMSFrameworkInfo) {\n    this.userAgent = createUserAgent(this.env, frameworkInfo);\n  }\n\n  setRoom(room: HMSRoom) {\n    this.room = room;\n  }\n\n  setKnownRoles(params: PolicyParams) {\n    this.knownRoles = params.known_roles;\n    this.roleDetailsArrived = true;\n    this.templateAppData = params.app_data;\n    if (!this.simulcastEnabled) {\n      return;\n    }\n    const publishParams = this.knownRoles[params.name]?.publishParams;\n    this.videoLayers = this.convertSimulcastLayers(publishParams.simulcast?.video);\n    // this.screenshareLayers = this.convertSimulcastLayers(publishParams.simulcast?.screen);\n    this.updatePeersPolicy();\n  }\n\n  hasRoleDetailsArrived(): boolean {\n    return this.roleDetailsArrived;\n  }\n\n  // eslint-disable-next-line complexity\n  setConfig(config: HMSConfig) {\n    DeviceStorageManager.rememberDevices(Boolean(config.rememberDeviceSelection));\n    if (config.rememberDeviceSelection) {\n      const devices: SelectedDevices | undefined = DeviceStorageManager.getSelection();\n      if (devices) {\n        if (!config.settings) {\n          config.settings = {};\n        }\n        if (devices.audioInput?.deviceId) {\n          config.settings.audioInputDeviceId = config.settings.audioInputDeviceId || devices.audioInput.deviceId;\n        }\n        if (devices.audioOutput?.deviceId) {\n          config.settings.audioOutputDeviceId = config.settings.audioOutputDeviceId || devices.audioOutput.deviceId;\n        }\n        if (devices.videoInput?.deviceId) {\n          config.settings.videoDeviceId = config.settings.videoDeviceId || devices.videoInput.deviceId;\n        }\n      }\n    }\n    config.autoManageVideo = config.autoManageVideo !== false;\n    config.autoManageWakeLock = config.autoManageWakeLock !== false;\n    this.config = config;\n    this.setEnv();\n  }\n\n  addPeer(peer: HMSPeer) {\n    this.peers[peer.peerId] = peer;\n    if (peer.isLocal) {\n      this.localPeerId = peer.peerId;\n    }\n  }\n\n  /**\n   * @param {HMSTrack} track the published track that has to be added\n   *\n   * Note: Only use this method to add published tracks not preview traks\n   */\n  addTrack(track: HMSTrack) {\n    this.tracks.set(track, track);\n  }\n\n  getTrackState(trackId: string) {\n    return this.peerTrackStates[trackId];\n  }\n\n  setTrackState(trackStateEntry: TrackStateEntry) {\n    this.peerTrackStates[trackStateEntry.trackInfo.track_id] = trackStateEntry;\n  }\n\n  removePeer(peerId: string) {\n    if (this.localPeerId === peerId) {\n      this.localPeerId = undefined;\n    }\n    delete this.peers[peerId];\n  }\n\n  removeTrack(track: HMSTrack) {\n    this.tracks.delete(track);\n  }\n\n  updateSpeakers(speakers: HMSSpeaker[]) {\n    this.speakers = speakers;\n  }\n\n  async updateAudioOutputVolume(value: number) {\n    for (const track of this.getAudioTracks()) {\n      await track.setVolume(value);\n    }\n  }\n\n  async updateAudioOutputDevice(device: MediaDeviceInfo) {\n    const promises: Promise<void>[] = [];\n    this.getAudioTracks().forEach(track => {\n      if (track instanceof HMSRemoteAudioTrack) {\n        promises.push(track.setOutputDevice(device));\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  getSimulcastLayers(source: HMSTrackSource): SimulcastLayer[] {\n    // Enable only when backend enables and source is video or screen. ignore videoplaylist\n    if (!this.simulcastEnabled || !['screen', 'regular'].includes(source)) {\n      return [];\n    }\n    if (source === 'screen') {\n      return []; //this.screenshareLayers?.layers || []; uncomment this when screenshare simulcast supported\n    }\n    return this.videoLayers?.layers || [];\n  }\n\n  /**\n   * Convert maxBitrate from kbps to bps\n   * @internal\n   * @param simulcastLayers\n   * @returns {SimulcastLayers}\n   */\n  private convertSimulcastLayers(simulcastLayers?: SimulcastLayers) {\n    if (!simulcastLayers) {\n      return;\n    }\n    return {\n      ...simulcastLayers,\n      layers: (simulcastLayers.layers || []).map(layer => {\n        return {\n          ...layer,\n          maxBitrate: layer.maxBitrate * 1000,\n        };\n      }),\n    };\n  }\n\n  getSimulcastDefinitionsForPeer(peer: HMSPeer, source: HMSTrackSource) {\n    // TODO: remove screen check when screenshare simulcast is supported\n    if ([!peer || !peer.role, source === 'screen', !this.simulcastEnabled].some(value => !!value)) {\n      return [];\n    }\n\n    const publishParams = this.getPolicyForRole(peer.role!.name).publishParams;\n    let simulcastLayers: SimulcastLayers | undefined;\n    let width: number;\n    let height: number;\n    if (source === 'regular') {\n      simulcastLayers = publishParams.simulcast?.video;\n      width = publishParams.video.width;\n      height = publishParams.video.height;\n    } else if (source === 'screen') {\n      simulcastLayers = publishParams.simulcast?.screen;\n      width = publishParams.screen.width;\n      height = publishParams.screen.height;\n    }\n    return (\n      simulcastLayers?.layers?.map(value => {\n        const layer = simulcastMapping[value.rid as RID];\n        const resolution = {\n          width: Math.floor(width / value.scaleResolutionDownBy),\n          height: Math.floor(height / value.scaleResolutionDownBy),\n        };\n        return {\n          layer,\n          resolution,\n        } as HMSSimulcastLayerDefinition;\n      }) || []\n    );\n  }\n\n  setPoll(poll: HMSPoll) {\n    this.polls.set(poll.id, poll);\n  }\n\n  getPoll(id: string): HMSPoll | undefined {\n    return this.polls.get(id);\n  }\n\n  getErrorListener() {\n    return this.errorListener;\n  }\n\n  cleanup() {\n    const tracks = this.getTracks();\n    for (const track of tracks) {\n      track.cleanup();\n    }\n    this.room = undefined;\n    this.config = undefined;\n    this.localPeerId = undefined;\n    this.roleDetailsArrived = false;\n  }\n\n  setErrorListener(listener: IErrorListener) {\n    this.errorListener = listener;\n  }\n\n  private updatePeersPolicy() {\n    this.getPeers().forEach(peer => {\n      if (!peer.role) {\n        this.errorListener?.onError(ErrorFactory.GenericErrors.InvalidRole(HMSAction.VALIDATION, ''));\n        return;\n      }\n      peer.role = this.getPolicyForRole(peer.role.name);\n    });\n  }\n\n  private setEnv() {\n    const endPoint = this.config?.initEndpoint!;\n    const url = endPoint.split('https://')[1];\n    let env: ENV = ENV.PROD;\n    if (url.startsWith(ENV.PROD)) {\n      env = ENV.PROD;\n    } else if (url.startsWith(ENV.QA)) {\n      env = ENV.QA;\n    } else if (url.startsWith(ENV.DEV)) {\n      env = ENV.DEV;\n    }\n    this.env = env;\n    HTTPAnalyticsTransport.setEnv(env);\n  }\n}\n\nexport { Store };\n", "import HMSLogger from '../utils/logger';\n\nexport class WakeLockManager {\n  private readonly TAG = '[WakeLockManager]';\n  private wakeLock: WakeLockSentinel | null = null;\n\n  acquireLock = async () => {\n    await this.requestWakeLock();\n    document?.addEventListener('visibilitychange', this.visibilityHandler);\n  };\n\n  cleanup = async () => {\n    if (this.wakeLock && !this.wakeLock.released) {\n      try {\n        await this.wakeLock.release();\n        HMSLogger.d(this.TAG, 'Wake lock released');\n      } catch (err) {\n        const error = err as Error;\n        HMSLogger.w(this.TAG, 'Error while releasing wake lock', `name=${error.name}, message=${error.message}`);\n      }\n    }\n    this.wakeLock = null;\n  };\n\n  private visibilityHandler = async () => {\n    if (document?.visibilityState === 'visible' && (!this.wakeLock || this.wakeLock.released)) {\n      HMSLogger.d(this.TAG, 'Re-acquiring wake lock due to visibility change');\n      await this.requestWakeLock();\n    }\n  };\n\n  // Function that attempts to request a screen wake lock.\n  private requestWakeLock = async () => {\n    try {\n      if (!('wakeLock' in navigator)) {\n        HMSLogger.d(this.TAG, 'Wake lock feature not supported');\n        return;\n      }\n      this.wakeLock = await navigator.wakeLock.request('screen');\n      HMSLogger.d(this.TAG, 'Wake lock acquired');\n    } catch (err) {\n      const error = err as Error;\n      HMSLogger.w(this.TAG, 'Error acquiring wake lock', `name=${error.name}, message=${error.message}`);\n    }\n  };\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { HMSAnalyticsLevel } from './AnalyticsEventLevel';\nimport { AnalyticsTransport } from './AnalyticsTransport';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\nimport { IStore } from '../sdk/store';\nimport { ANALYTICS_BUFFER_SIZE } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\n\nexport class AnalyticsEventsService {\n  private bufferSize = ANALYTICS_BUFFER_SIZE;\n  private readonly TAG = '[AnalyticsEventsService]';\n\n  private transport: AnalyticsTransport | null = null;\n  private pendingEvents: AnalyticsEvent[] = [];\n\n  level: HMSAnalyticsLevel = HMSAnalyticsLevel.INFO;\n\n  constructor(private store: IStore) {}\n\n  setTransport(transport: AnalyticsTransport) {\n    this.transport = transport;\n  }\n\n  reset() {\n    this.transport = null;\n    this.pendingEvents = [];\n  }\n\n  queue(event: AnalyticsEvent) {\n    if (event.level >= this.level) {\n      this.pendingEvents.push(event);\n\n      if (this.pendingEvents.length > this.bufferSize) {\n        const removedEvent = this.pendingEvents.shift();\n        HMSLogger.d(this.TAG, 'Max buffer size reached', 'Removed event to accommodate new events', removedEvent);\n      }\n    }\n    return this;\n  }\n\n  flushFailedClientEvents() {\n    HTTPAnalyticsTransport.flushFailedEvents();\n  }\n\n  flush() {\n    try {\n      while (this.pendingEvents.length > 0) {\n        const event = this.pendingEvents.shift();\n        if (event) {\n          event.metadata.peer.peer_id = this.store.getLocalPeer()?.peerId;\n          event.metadata.userAgent = this.store.getUserAgent();\n          if (this.transport && this.transport.transportProvider.isConnected) {\n            this.transport.sendEvent(event);\n          } else {\n            this.sendClientEventOnHTTP(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'Flush Failed', error);\n    }\n  }\n\n  private sendClientEventOnHTTP(event: AnalyticsEvent) {\n    const room = this.store.getRoom();\n    const localPeer = this.store.getLocalPeer();\n    event.metadata.token = this.store.getConfig()?.authToken;\n    event.metadata.peer = {\n      session_id: room?.sessionId,\n      room_id: room?.id,\n      room_name: room?.name,\n      template_id: room?.templateId,\n      joined_at: room?.joinedAt?.getTime(),\n      session_started_at: room?.startedAt?.getTime(),\n      role: localPeer?.role?.name,\n      user_name: localPeer?.name,\n      user_data: localPeer?.metadata,\n    };\n    HTTPAnalyticsTransport.sendEvent(event);\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { EventBus } from '../events/EventBus';\nimport { HMSDeviceChangeEvent, HMSTrackUpdate, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteAudioTrack } from '../media/tracks';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { isMobile } from '../utils/support';\nimport { sleep } from '../utils/timer-utils';\n\n/**\n * Following are the errors thrown when autoplay is blocked in different browsers\n * Firefox - DOMException: The play method is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Safari - NotAllowedError: The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Chrome - DOMException: play() failed because the user didn't interact with the document first.\n * Brave - DOMException: play() can only be initiated by a user gesture.\n */\ntype AudioSinkState = {\n  autoplayFailed?: boolean;\n  initialized: boolean;\n  // this promise will be set for the first track. remaining tracks will be processed once it's know whether\n  // autoplay is allowed or not\n  autoplayCheckPromise?: Promise<void>;\n};\n\nconst INITIAL_STATE: AudioSinkState = {\n  autoplayFailed: undefined,\n  initialized: false,\n  autoplayCheckPromise: undefined,\n};\n\nexport class AudioSinkManager {\n  private audioSink?: HTMLElement;\n  private autoPausedTracks: Set<HMSRemoteAudioTrack> = new Set();\n  private readonly TAG = '[AudioSinkManager]:';\n  private volume = 100;\n  private state = { ...INITIAL_STATE };\n  private listener?: HMSUpdateListener;\n\n  constructor(private store: IStore, private deviceManager: DeviceManager, private eventBus: EventBus) {\n    this.eventBus.audioTrackAdded.subscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.subscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.subscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.subscribe(this.handleAudioDeviceChange);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n  }\n\n  private get outputDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  getVolume() {\n    return this.volume;\n  }\n\n  async setVolume(value: number) {\n    await this.store.updateAudioOutputVolume(value);\n    this.volume = value;\n  }\n\n  /**\n   *  This function is to be called only on user interaction when\n   *  autoplay error is received.\n   */\n  async unblockAutoplay() {\n    if (this.autoPausedTracks.size > 0) {\n      this.unpauseAudioTracks();\n    }\n  }\n\n  init(elementId?: string) {\n    if (this.state.initialized || this.audioSink) {\n      return;\n    }\n    this.state.initialized = true;\n    const audioSink = document.createElement('div');\n    audioSink.id = `HMS-SDK-audio-sink-${uuid()}`;\n    const userElement = elementId && document.getElementById(elementId);\n    const audioSinkParent = userElement || document.body;\n    audioSinkParent.append(audioSink);\n\n    this.audioSink = audioSink;\n    HMSLogger.d(this.TAG, 'audio sink created', this.audioSink);\n  }\n\n  cleanup() {\n    this.audioSink?.remove();\n    this.audioSink = undefined;\n    this.eventBus.audioTrackAdded.unsubscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.unsubscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.unsubscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.unsubscribe(this.handleAudioDeviceChange);\n    this.autoPausedTracks = new Set();\n    this.state = { ...INITIAL_STATE };\n  }\n\n  private handleAudioPaused = async (event: any) => {\n    const audioEl = event.target as HTMLAudioElement;\n    //@ts-ignore\n    const track = audioEl.srcObject?.getAudioTracks()[0];\n    if (!track?.enabled) {\n      // No need to play if already disabled\n      return;\n    }\n    // this means the audio paused because of external factors(headset removal)\n    HMSLogger.d(this.TAG, 'Audio Paused', event.target.id);\n    const audioTrack = this.store.getTrackById(event.target.id);\n    if (audioTrack) {\n      if (isMobile()) {\n        // Play after a delay since mobile devices don't call onDevice change event\n        await sleep(500);\n        this.playAudioFor(audioTrack as HMSRemoteAudioTrack);\n      } else {\n        this.autoPausedTracks.add(audioTrack as HMSRemoteAudioTrack);\n      }\n    }\n  };\n\n  private handleTrackUpdate = ({ track }: { track: HMSRemoteAudioTrack; enabled: boolean }) => {\n    HMSLogger.d(this.TAG, 'Track updated', `${track}`);\n  };\n\n  private handleTrackAdd = async ({\n    track,\n    peer,\n    callListener = true,\n  }: {\n    track: HMSRemoteAudioTrack;\n    peer: HMSRemotePeer;\n    callListener?: boolean;\n  }) => {\n    const audioEl = document.createElement('audio');\n    audioEl.style.display = 'none';\n    audioEl.id = track.trackId;\n    audioEl.addEventListener('pause', this.handleAudioPaused);\n\n    audioEl.onerror = async () => {\n      HMSLogger.e(this.TAG, 'error on audio element', audioEl.error);\n      const ex = ErrorFactory.TracksErrors.AudioPlaybackError(\n        `Audio playback error for track - ${track.trackId} code - ${audioEl?.error?.code}`,\n      );\n      this.eventBus.analytics.publish(AnalyticsEventFactory.audioPlaybackError(ex));\n      if (audioEl?.error?.code === MediaError.MEDIA_ERR_DECODE) {\n        this.removeAudioElement(audioEl, track);\n        await sleep(500);\n        await this.handleTrackAdd({ track, peer, callListener: false });\n      }\n    };\n    track.setAudioElement(audioEl);\n    track.setVolume(this.volume);\n    HMSLogger.d(this.TAG, 'Audio track added', `${track}`);\n    this.init(); // call to create sink element if not already created\n    this.audioSink?.append(audioEl);\n    this.outputDevice && (await track.setOutputDevice(this.outputDevice));\n    audioEl.srcObject = new MediaStream([track.nativeTrack]);\n    callListener && this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, peer);\n    await this.handleAutoplayError(track);\n  };\n\n  private handleAutoplayError = async (track: HMSRemoteAudioTrack) => {\n    /**\n     * if it's not known whether autoplay will succeed, wait for it to be known\n     */\n    if (this.state.autoplayFailed === undefined) {\n      if (!this.state.autoplayCheckPromise) {\n        // it's the first track, try to play it, that'll tell us whether autoplay is allowed\n        this.state.autoplayCheckPromise = new Promise<void>(resolve => {\n          this.playAudioFor(track).then(resolve);\n        });\n      }\n      // and wait for the result to be known\n      await this.state.autoplayCheckPromise;\n    }\n    /**\n     * Don't play the track if autoplay failed, add to paused list\n     */\n    if (this.state.autoplayFailed) {\n      this.autoPausedTracks.add(track);\n      return;\n    }\n    await this.playAudioFor(track);\n  };\n\n  private handleAudioDeviceChange = (event: HMSDeviceChangeEvent) => {\n    // if there is no selection that means this is an init request. No need to do anything\n    if (event.error || !event.selection || event.type === 'video') {\n      return;\n    }\n    this.unpauseAudioTracks();\n  };\n\n  /**\n   * try to play audio for the passed in track, assume autoplay error happened if play fails\n   * @param track\n   * @private\n   */\n  private async playAudioFor(track: HMSRemoteAudioTrack) {\n    const audioEl = track.getAudioElement();\n    if (!audioEl) {\n      HMSLogger.w(this.TAG, 'No audio element found on track', track.trackId);\n      return;\n    }\n    try {\n      await audioEl.play();\n      this.state.autoplayFailed = false;\n      this.autoPausedTracks.delete(track);\n      HMSLogger.d(this.TAG, 'Played track', `${track}`);\n    } catch (err) {\n      this.autoPausedTracks.add(track);\n      HMSLogger.w(this.TAG, 'Failed to play track', `${track}`, err as Error);\n      const error = err as Error;\n      if (!this.state.autoplayFailed && error.name === 'NotAllowedError') {\n        this.state.autoplayFailed = true;\n        const ex = ErrorFactory.TracksErrors.AutoplayBlocked(HMSAction.AUTOPLAY, '');\n        ex.addNativeError(error);\n        this.eventBus.analytics.publish(AnalyticsEventFactory.autoplayError());\n        this.eventBus.autoplayError.publish(ex);\n      }\n    }\n  }\n\n  private handleTrackRemove = (track: HMSRemoteAudioTrack) => {\n    this.autoPausedTracks.delete(track);\n    const audioEl = document.getElementById(track.trackId) as HTMLAudioElement;\n    if (audioEl) {\n      this.removeAudioElement(audioEl, track);\n    }\n    // Reset autoplay error thrown because if all tracks are removed and a new track is added\n    // Autoplay error is thrown in safari\n    if (this.audioSink && this.audioSink.childElementCount === 0) {\n      this.state.autoplayCheckPromise = undefined;\n      this.state.autoplayFailed = undefined;\n    }\n    HMSLogger.d(this.TAG, 'Audio track removed', `${track}`);\n  };\n\n  private unpauseAudioTracks = async () => {\n    const promises: Promise<void>[] = [];\n    this.autoPausedTracks.forEach(track => {\n      promises.push(this.playAudioFor(track));\n    });\n    // Return after all pending tracks are played\n    await Promise.all(promises);\n  };\n\n  private removeAudioElement = (audioEl: HTMLAudioElement, track: HMSRemoteAudioTrack) => {\n    if (audioEl) {\n      HMSLogger.d(this.TAG, 'removing audio element', `${track}`);\n      audioEl.removeEventListener('pause', this.handleAudioPaused);\n      audioEl.srcObject = null;\n      audioEl.remove();\n      track.setAudioElement(null);\n    }\n  };\n}\n", "import { DeviceStorageManager } from './DeviceStorage';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport { DeviceMap, HMSDeviceChangeEvent, SelectedDevices } from '../interfaces';\nimport { HMSAudioTrackSettingsBuilder, HMSVideoTrackSettingsBuilder } from '../media/settings';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { debounce } from '../utils/timer-utils';\n\ntype DeviceAndGroup = Partial<MediaTrackSettings>;\n\ninterface HMSDeviceManager extends DeviceMap {\n  outputDevice?: MediaDeviceInfo;\n  hasWebcamPermission: boolean;\n  hasMicrophonePermission: boolean;\n}\n\nexport class DeviceManager implements HMSDeviceManager {\n  audioInput: MediaDeviceInfo[] = [];\n  audioOutput: MediaDeviceInfo[] = [];\n  videoInput: MediaDeviceInfo[] = [];\n  outputDevice?: MediaDeviceInfo;\n  // true if user has allowed the permission\n  // false if user has denied the permission or prompt was never shown or ignored\n  // or if the camera/mic is not available in the device\n  hasWebcamPermission = false;\n  hasMicrophonePermission = false;\n\n  private readonly TAG = '[Device Manager]:';\n  private initialized = false;\n  private videoInputChanged = false;\n  private audioInputChanged = false;\n\n  constructor(private store: IStore, private eventBus: EventBus) {\n    const isLocalTrackEnabled = ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) =>\n      enabled && track.source === 'regular';\n    this.eventBus.localVideoEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.videoInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n    this.eventBus.localAudioEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.audioInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n  }\n\n  updateOutputDevice = async (deviceId?: string) => {\n    const newDevice = this.audioOutput.find(device => device.deviceId === deviceId);\n    if (newDevice) {\n      this.outputDevice = newDevice;\n      await this.store.updateAudioOutputDevice(newDevice);\n      DeviceStorageManager.updateSelection('audioOutput', { deviceId: newDevice.deviceId, groupId: newDevice.groupId });\n    }\n    return newDevice;\n  };\n\n  async init(force = false) {\n    if (this.initialized && !force) {\n      return;\n    }\n    !this.initialized && navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);\n    this.initialized = true;\n    await this.enumerateDevices();\n    this.logDevices('Init');\n    await this.setOutputDevice();\n    this.eventBus.deviceChange.publish({\n      devices: this.getDevices(),\n    } as HMSDeviceChangeEvent);\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'list',\n        devices: this.getDevices(),\n      }),\n    );\n  }\n\n  getDevices(): DeviceMap {\n    return {\n      audioInput: this.audioInput,\n      audioOutput: this.audioOutput,\n      videoInput: this.videoInput,\n    };\n  }\n\n  cleanup() {\n    this.initialized = false;\n    this.audioInput = [];\n    this.audioOutput = [];\n    this.videoInput = [];\n    this.outputDevice = undefined;\n    navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);\n  }\n\n  getCurrentSelection = (): SelectedDevices => {\n    const localPeer = this.store.getLocalPeer();\n    const audioDevice = this.createIdentifier(localPeer?.audioTrack?.getMediaTrackSettings());\n    const videoDevice = this.createIdentifier(localPeer?.videoTrack?.getMediaTrackSettings());\n    const audioSelection = this.audioInput.find(device => {\n      const id = this.createIdentifier(device);\n      return id === audioDevice;\n    });\n    const videoSelection = this.videoInput.find(device => this.createIdentifier(device) === videoDevice);\n    return {\n      audioInput: audioSelection,\n      videoInput: videoSelection,\n      audioOutput: this.outputDevice,\n    };\n  };\n\n  private createIdentifier(deviceInfo?: DeviceAndGroup) {\n    if (!deviceInfo) {\n      return '';\n    }\n    return `${deviceInfo.deviceId}${deviceInfo.groupId}`;\n  }\n\n  private computeChange = (prevDevices: string[], currentDevices: MediaDeviceInfo[]) => {\n    if (prevDevices.length !== currentDevices.length) {\n      return true;\n    }\n    return currentDevices.some(device => !prevDevices.includes(this.createIdentifier(device)));\n  };\n\n  private enumerateDevices = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const prevVideoInput = this.videoInput.map(this.createIdentifier);\n      const prevAudioInput = this.audioInput.map(this.createIdentifier);\n      this.audioInput = [];\n      this.audioOutput = [];\n      this.videoInput = [];\n      devices.forEach(device => {\n        if (device.kind === 'audioinput' && device.label) {\n          this.hasMicrophonePermission = true;\n          this.audioInput.push(device as MediaDeviceInfo);\n        } else if (device.kind === 'audiooutput') {\n          this.audioOutput.push(device);\n        } else if (device.kind === 'videoinput' && device.label) {\n          this.hasWebcamPermission = true;\n          this.videoInput.push(device as MediaDeviceInfo);\n        }\n      });\n      this.videoInputChanged = this.computeChange(prevVideoInput, this.videoInput);\n      this.audioInputChanged = this.computeChange(prevAudioInput, this.audioInput);\n      DeviceStorageManager.setDevices({\n        videoInput: [...this.videoInput],\n        audioInput: [...this.audioInput],\n        audioOutput: [...this.audioOutput],\n      });\n      this.logDevices('Enumerate Devices');\n    } catch (error) {\n      HMSLogger.e(this.TAG, 'Failed enumerating devices', error);\n    }\n  };\n\n  private handleDeviceChange = debounce(async () => {\n    await this.enumerateDevices();\n    this.logDevices('After Device Change');\n    const localPeer = this.store.getLocalPeer();\n    await this.setOutputDevice(true);\n    await this.handleAudioInputDeviceChange(localPeer?.audioTrack);\n    await this.handleVideoInputDeviceChange(localPeer?.videoTrack);\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'change',\n        devices: this.getDevices(),\n      }),\n    );\n  }, 500).bind(this);\n\n  /**\n   * Function to get the device after device change\n   * Chrome and Edge provide a default device from which we select the actual device\n   * Firefox and safari give 0th device as system default\n   * @returns {MediaDeviceInfo}\n   */\n  getNewAudioInputDevice() {\n    const defaultDevice = this.audioInput.find(device => device.deviceId === 'default');\n    if (defaultDevice) {\n      // Selecting a non-default device so that the deviceId comparision does not give\n      // false positives when device is removed, because the other available device\n      // get's the deviceId as default once this device is removed\n      const nextDevice = this.audioInput.find(device => {\n        return device.deviceId !== 'default' && defaultDevice.label.includes(device.label);\n      });\n      return nextDevice;\n    }\n    return this.audioInput[0];\n  }\n\n  /**\n   * This method is to select the input/output from same group\n   * same group meaning both input/output are of same device\n   * This method might override the default coming from browser and system so as to select options from same\n   * device type. This is required in certain cases where browser's default is not correct.\n   * Algo:\n   * 1. find the non default input device if selected one is default by matching device label\n   * 2. find the corresponding output device which has the same group id or same label\n   * 3. select the previous selected device if nothing was found\n   * 4. select the default one if no matching device was found and previous device doesn't exist anymore\n   * 5. select the first option if there is no default\n   */\n  async setOutputDevice(deviceChange = false) {\n    const inputDevice = this.getNewAudioInputDevice();\n    const prevSelection = this.createIdentifier(this.outputDevice);\n    this.outputDevice = this.getAudioOutputDeviceMatchingInput(inputDevice);\n    if (!this.outputDevice) {\n      // there is no matching device, let's revert back to the prev selected device\n      this.outputDevice = this.audioOutput.find(device => this.createIdentifier(device) === prevSelection);\n      if (!this.outputDevice) {\n        // prev device doesn't exist as well, select default deviceId device if available, otherwise select 0th device\n        this.outputDevice = this.audioOutput.find(device => device.deviceId === 'default') || this.audioOutput[0];\n      }\n    }\n    await this.store.updateAudioOutputDevice(this.outputDevice);\n    // send event only on device change and device is not same as previous\n    if (deviceChange && prevSelection !== this.createIdentifier(this.outputDevice)) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioOutput: this.outputDevice },\n          devices: this.getDevices(),\n          type: 'audioOutput',\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        selection: this.outputDevice,\n        type: 'audioOutput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  }\n\n  private handleAudioInputDeviceChange = async (audioTrack?: HMSLocalAudioTrack) => {\n    if (!audioTrack) {\n      HMSLogger.d(this.TAG, 'No Audio track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.audioInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in AudioInput Device');\n      return;\n    }\n    const newSelection = this.getNewAudioInputDevice();\n    if (!newSelection || !newSelection.deviceId) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioInput: newSelection },\n          error: new Error('Audio device not found') as HMSException,\n          devices: this.getDevices(),\n          type: 'audioInput',\n        }),\n      );\n      HMSLogger.w(this.TAG, 'Audio device not found');\n      return;\n    }\n    const { settings } = audioTrack;\n    const newAudioTrackSettings = new HMSAudioTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await audioTrack.setSettings(newAudioTrackSettings, true);\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'audioInput',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Audio Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Audio Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioInput: newSelection },\n          devices: this.getDevices(),\n          type: 'audioInput',\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error,\n        selection: newSelection,\n        type: 'audioInput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private handleVideoInputDeviceChange = async (videoTrack?: HMSLocalVideoTrack) => {\n    if (!videoTrack) {\n      HMSLogger.d(this.TAG, 'No video track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.videoInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in VideoInput Device');\n      return;\n    }\n    const newSelection = this.videoInput[0];\n    if (!newSelection || !newSelection.deviceId) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { videoInput: newSelection },\n          error: new Error('Video device not found') as HMSException,\n          devices: this.getDevices(),\n          type: 'video',\n        }),\n      );\n      HMSLogger.w(this.TAG, 'Video device not found');\n      return;\n    }\n    const { settings } = videoTrack;\n    const newVideoTrackSettings = new HMSVideoTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .maxFramerate(settings.maxFramerate)\n      .setWidth(settings.width)\n      .setHeight(settings.height)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await (videoTrack as HMSLocalVideoTrack).setSettings(newVideoTrackSettings, true);\n      // On replace track, enabled will be true. Need to be set to previous state\n      // videoTrack.setEnabled(enabled); // TODO: remove this once verified on qa.\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'video',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Video Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Video Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { videoInput: newSelection },\n          devices: this.getDevices(),\n          type: 'video',\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error: error as Error,\n        type: 'video',\n        selection: newSelection,\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private getAudioOutputDeviceMatchingInput(inputDevice?: MediaDeviceInfo) {\n    const blacklist = this.store.getConfig()?.settings?.speakerAutoSelectionBlacklist || [];\n    if (blacklist === 'all') {\n      return;\n    }\n\n    const inputLabel = inputDevice?.label.toLowerCase() || '';\n    if (blacklist.some(label => inputLabel.includes(label.toLowerCase()))) {\n      return;\n    }\n\n    if (inputDevice?.groupId) {\n      // only check for label because if groupId check is added it will select speaker\n      // when an external earphone without microphone is added\n      return this.audioOutput.find(device => inputDevice.deviceId !== 'default' && device.label === inputDevice.label);\n    }\n\n    return;\n  }\n\n  private logDevices(label = '') {\n    HMSLogger.d(\n      this.TAG,\n      label,\n      JSON.stringify(\n        {\n          videoInput: [...this.videoInput],\n          audioInput: [...this.audioInput],\n          audioOutput: [...this.audioOutput],\n          selected: this.getCurrentSelection(),\n        },\n        null,\n        4,\n      ),\n    );\n  }\n}\n", "import { DeviceManager } from './DeviceManager';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { HMSAudioContextHandler } from '../utils/media';\n\nexport interface IAudioOutputManager {\n  getDevice(): MediaDeviceInfo | undefined;\n  setDevice(deviceId: string): Promise<MediaDeviceInfo | undefined>;\n  getVolume(): number;\n  setVolume(value: number): void;\n}\n\nexport class AudioOutputManager implements IAudioOutputManager {\n  constructor(private deviceManager: DeviceManager, private audioSinkManager: AudioSinkManager) {}\n\n  getVolume() {\n    return this.audioSinkManager.getVolume();\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    this.audioSinkManager.setVolume(value);\n  }\n\n  getDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  setDevice(deviceId?: string) {\n    return this.deviceManager.updateOutputDevice(deviceId);\n  }\n\n  async unblockAutoplay() {\n    await this.audioSinkManager.unblockAutoplay();\n    /**\n     * similar to autoplay error when there's no user interaction,\n     * audio context is paused due to which empty audio tracks do not send any data and therefore it doesn't reach SFU.\n     * resume audio context on user interaction to enable empty audio tracks to send data and be forwarded to remote peers\n     */\n    await HMSAudioContextHandler.resumeContext();\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport { HMSInternalEvent } from './HMSInternalEvent';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport { HMSException } from '../error/HMSException';\nimport { HMSDeviceChangeEvent, HMSRole } from '../interfaces';\nimport {\n  HMSLocalAudioTrack,\n  HMSLocalVideoTrack,\n  HMSRemoteAudioTrack,\n  HMSRemoteVideoTrack,\n  HMSWebrtcStats,\n} from '../internal';\nimport { PolicyParams } from '../notification-manager/HMSNotifications';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { HMSEvents } from '../utils/constants';\nimport { ITrackAudioLevelUpdate } from '../utils/track-audio-level-monitor';\n\nexport class EventBus {\n  private eventEmitter: EventEmitter = new EventEmitter();\n  readonly deviceChange = new HMSInternalEvent<HMSDeviceChangeEvent>(HMSEvents.DEVICE_CHANGE, this.eventEmitter);\n  readonly localAudioEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_ENABLED,\n    this.eventEmitter,\n  );\n  readonly localVideoEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalVideoTrack }>(\n    HMSEvents.LOCAL_VIDEO_ENABLED,\n    this.eventEmitter,\n  );\n\n  /**\n   * Emitter which processes raw RTC stats from rtcStatsUpdate and calls client callback\n   */\n  readonly statsUpdate = new HMSInternalEvent<HMSWebrtcStats>(HMSEvents.STATS_UPDATE, this.eventEmitter);\n\n  readonly trackDegraded = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_DEGRADED, this.eventEmitter);\n  readonly trackRestored = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_RESTORED, this.eventEmitter);\n\n  /**\n   * Emits audio level updates for audio tracks(used with local track in preview)\n   */\n  readonly trackAudioLevelUpdate = new HMSInternalEvent<ITrackAudioLevelUpdate>(\n    HMSEvents.TRACK_AUDIO_LEVEL_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioPluginFailed = new HMSInternalEvent<HMSException>(HMSEvents.AUDIO_PLUGIN_FAILED, this.eventEmitter);\n\n  readonly localAudioSilence = new HMSInternalEvent<{ track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_SILENCE,\n    this.eventEmitter,\n  );\n\n  readonly analytics = new HMSInternalEvent<AnalyticsEvent>(HMSEvents.ANALYTICS, this.eventEmitter);\n\n  readonly policyChange = new HMSInternalEvent<PolicyParams>(HMSEvents.POLICY_CHANGE, this.eventEmitter);\n\n  readonly localRoleUpdate = new HMSInternalEvent<{ oldRole: HMSRole; newRole: HMSRole }>(\n    HMSEvents.LOCAL_ROLE_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackUpdate = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; enabled: boolean }>(\n    HMSEvents.AUDIO_TRACK_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackAdded = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; peer: HMSRemotePeer }>(\n    HMSEvents.AUDIO_TRACK_ADDED,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackRemoved = new HMSInternalEvent<HMSRemoteAudioTrack>(\n    HMSEvents.AUDIO_TRACK_REMOVED,\n    this.eventEmitter,\n  );\n\n  readonly autoplayError = new HMSInternalEvent<HMSException>(HMSEvents.AUTOPLAY_ERROR, this.eventEmitter);\n\n  readonly leave = new HMSInternalEvent<HMSException | undefined>(HMSEvents.LEAVE, this.eventEmitter);\n}\n", "import type { WaitForFilter, WaitForOptions } from 'eventemitter2';\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2';\n\nexport class HMSInternalEvent<T> {\n  constructor(private eventName: string, private eventEmitter: EventEmitter) {}\n\n  publish = (event?: T) => {\n    this.eventEmitter.emit(this.eventName, event);\n  };\n  subscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.on(this.eventName, fn);\n  };\n  subscribeOnce = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.once(this.eventName, fn);\n  };\n  unsubscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.off(this.eventName, fn);\n  };\n  waitFor = (predicate: WaitForFilter) => {\n    return this.eventEmitter.waitFor(this.eventName, {\n      filter: predicate,\n    } as WaitForOptions);\n  };\n  removeAllListeners = () => {\n    this.eventEmitter.removeAllListeners(this.eventName);\n  };\n}\n", "import { VideoTrackLayerUpdate } from '../connection/channel-messages';\nimport { HMSRole } from '../interfaces/role';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { HMSTrack, HMSTrackSource } from '../media/tracks/HMSTrack';\nimport { PollInfoParams, PollResult, Track } from '../signal/interfaces';\n\n/**\n * Interfaces for message received from BIZ Signal through Websocket.\n * These messages are handled by NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport interface ServerError {\n  code: number;\n  message?: string;\n}\n\nexport interface TrackStateNotification {\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  peer: PeerNotificationInfo;\n}\n\nexport interface OnTrackLayerUpdateNotification {\n  tracks: {\n    [track_id: string]: VideoTrackLayerUpdate;\n  };\n}\n\nexport interface PeerNotificationInfo {\n  peer_id: string;\n  role: string;\n  groups: string[];\n  info: Info;\n}\n\nexport interface Info {\n  name: string;\n  data: string;\n  user_id: string;\n}\n\nexport interface PolicyParams {\n  name: string;\n  known_roles: {\n    [role: string]: HMSRole;\n  };\n  template_id: string;\n  app_data?: Record<string, string>;\n}\n\n/**\n * This is in a format biz sends/received the track metadata\n */\nexport class TrackState implements Track {\n  mute: boolean;\n  type: 'audio' | 'video';\n  source: HMSTrackSource;\n  description: string;\n  track_id: string;\n  stream_id: string;\n\n  constructor(track: HMSLocalTrack | Track) {\n    this.type = track.type;\n    this.source = track.source || 'regular';\n    this.description = '';\n    if (track instanceof HMSTrack) {\n      this.mute = !track.enabled;\n      this.track_id = track.publishedTrackId!;\n      this.stream_id = track.stream.id;\n    } else {\n      this.mute = track.mute;\n      this.track_id = track.track_id;\n      this.stream_id = track.stream_id;\n    }\n  }\n}\n\nexport interface PeerNotification {\n  peer_id: string;\n  info: Info;\n  role: string;\n  joined_at?: number;\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  groups: string[];\n  realtime?: boolean;\n  is_from_room_state?: boolean;\n}\n\nexport interface RoomState {\n  name: string;\n  session_id?: string;\n  started_at?: number;\n  recording?: {\n    sfu: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    browser: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    hls: {\n      started_at?: number;\n      enabled: boolean;\n      config?: {\n        hls_vod: boolean;\n        single_file_per_layer: boolean;\n      };\n    };\n  };\n  streaming?: {\n    enabled: boolean;\n    rtmp: { enabled: boolean; started_at?: number };\n    hls: HLSNotification;\n  };\n}\n\nexport interface PeerListNotification {\n  peers: {\n    [peer_id: string]: PeerNotification;\n  };\n  room: RoomState;\n}\n\nexport interface PeriodicRoomState {\n  peer_count: number;\n  room: RoomState;\n  peers?: {\n    [peer_id: string]: PeerNotification;\n  };\n}\n\ninterface Speaker {\n  peer_id: string;\n  track_id: string;\n  level: number;\n}\n\nexport interface SpeakerList {\n  'speaker-list': Speaker[];\n}\n\ninterface ConnectionQuality {\n  peer_id: string;\n  downlink_score: number;\n}\n\nexport interface ConnectionQualityList {\n  peers: ConnectionQuality[];\n}\n\n/**\n * Represents the role change request received from the server\n */\nexport interface RoleChangeRequestParams {\n  requested_by?: string;\n  role: string;\n  token: string;\n}\n\nexport interface TrackUpdateRequestNotification {\n  requested_by?: string;\n  track_id: string;\n  stream_id: string;\n  mute: boolean;\n}\n\nexport interface ChangeTrackMuteStateNotification {\n  requested_by?: string;\n  roles?: string[];\n  type?: 'audio' | 'video';\n  source?: HMSTrackSource;\n  value: boolean;\n}\n\nexport interface PeerLeaveRequestNotification {\n  requested_by?: string;\n  reason: string;\n  room_end: boolean;\n}\n\nexport interface MessageNotification {\n  peer?: {\n    peer_id: string;\n    groups: string[];\n    role: string;\n    info: {\n      name: string;\n      data: any;\n      user_id: string;\n    };\n  };\n  roles?: string[];\n  message_id: string;\n  private: boolean;\n  timestamp: number;\n  info: MessageNotificationInfo;\n}\n\nexport interface SendMessage {\n  info: MessageNotificationInfo;\n  roles?: string[];\n  peer_id?: string;\n}\n\nexport interface MessageNotificationInfo {\n  message: any;\n  type: string;\n}\n\nexport interface RecordingNotification {\n  type: 'sfu' | 'Browser';\n  started_at?: number;\n  peer?: PeerNotificationInfo;\n  error?: ServerError;\n}\n\nexport interface RTMPNotification {\n  peer?: PeerNotificationInfo;\n  started_at?: number;\n  error?: ServerError;\n}\n\nexport interface HLSNotification {\n  enabled: boolean;\n  variants?: Array<HLSVariantInfo>;\n  error?: ServerError;\n  hls_recording?: {\n    hls_vod: boolean;\n    single_file_per_layer: boolean;\n  };\n}\n\nexport interface HLSVariantInfo {\n  url: string;\n  meeting_url?: string;\n  metadata?: string;\n  started_at?: number;\n}\n\nexport interface MetadataChangeNotification {\n  values: {\n    change_version?: number;\n    updated_by?: string;\n    data: any;\n    key: string;\n    updated_at?: number;\n  }[];\n}\n\nexport interface PollStartNotification {\n  polls: PollInfoParams[];\n}\n\nexport type PollStopNotification = PollStartNotification;\n\nexport interface PollStats extends PollResult {\n  poll_id: string;\n}\nexport interface PollStatsNotification {\n  polls: PollStats[];\n}\n\nexport interface RoomInfo {\n  room_id: string;\n  name: string;\n  description: string;\n  max_size: number;\n  large_room_optimization: boolean;\n}\n\nexport interface SessionInfo {\n  session_id: string;\n  room_id: string;\n  peer_count: number;\n  track_count: number;\n}\n", "import { HMSAudioListener, HMSPeerUpdate, HMSSpeaker, HMSUpdateListener } from '../../interfaces';\nimport { HMSAudioTrack } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { SpeakerList } from '../HMSNotifications';\n\nexport class ActiveSpeakerManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener, public audioListener?: HMSAudioListener) {}\n\n  handleActiveSpeakers(speakerList: SpeakerList) {\n    const speakers = speakerList['speaker-list'];\n    const hmsSpeakers: HMSSpeaker[] = speakers.map(speaker => ({\n      audioLevel: speaker.level,\n      peer: this.store.getPeerById(speaker.peer_id)!,\n      track: this.store.getTrackById(speaker.track_id) as HMSAudioTrack,\n    }));\n\n    this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    this.store.updateSpeakers(hmsSpeakers);\n    const dominantSpeaker = speakers[0];\n\n    if (dominantSpeaker) {\n      const dominantSpeakerPeer = this.store.getPeerById(dominantSpeaker.peer_id);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer!);\n    } else {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);\n    }\n  }\n}\n", "import { HMSUpdateListener } from '../../interfaces';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { MessageNotification } from '../HMSNotifications';\n\nexport class BroadcastManager {\n  private readonly TAG = '[BroadcastManager]';\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    if (method !== HMSNotificationMethod.BROADCAST) {\n      return;\n    }\n    this.handleBroadcast(notification);\n  }\n\n  private handleBroadcast(messageNotification: MessageNotification) {\n    const notifPeer = messageNotification.peer;\n    const notifMessage = messageNotification.info;\n    const notifRoles = messageNotification.roles;\n\n    const sender = this.getSender(notifPeer);\n    const recipientPeer = messageNotification.private ? this.store.getLocalPeer() : undefined;\n    const recipientRoles = [];\n\n    if (notifRoles?.length) {\n      const knownRoles = this.store.getKnownRoles();\n      for (const role of notifRoles) {\n        knownRoles[role] && recipientRoles.push(knownRoles[role]);\n      }\n    }\n\n    const hmsMessage = new Message({\n      ...notifMessage,\n      sender,\n      recipientRoles,\n      recipientPeer,\n      time: new Date(messageNotification.timestamp),\n      id: messageNotification.message_id,\n    });\n    HMSLogger.d(this.TAG, `Received Message from sender=${notifPeer?.peer_id}: ${hmsMessage}`);\n    this.listener?.onMessageReceived(hmsMessage);\n  }\n\n  private getSender(notifPeer?: MessageNotification['peer']) {\n    // If sender peerId is available in store, use that peer.\n    let sender = notifPeer ? this.store.getPeerById(notifPeer.peer_id) : undefined;\n    // If not available in store, use peer data from received broadcast message from Biz\n    // notifPeer can be undefined when message is sent via api\n    if (!sender && notifPeer) {\n      sender = new HMSPeer({\n        peerId: notifPeer.peer_id,\n        name: notifPeer.info.name,\n        isLocal: false,\n        role: this.store.getPolicyForRole(notifPeer.role),\n        customerUserId: notifPeer.info.user_id,\n        metadata: notifPeer.info.data,\n        groups: notifPeer.groups,\n      });\n    }\n    return sender;\n  }\n}\n", "import { HMSConnectionQuality, HMSConnectionQualityListener } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport { ConnectionQualityList } from '../HMSNotifications';\n\nexport class ConnectionQualityManager {\n  constructor(private store: IStore, public listener?: HMSConnectionQualityListener) {}\n\n  handleQualityUpdate(qualityList: ConnectionQualityList) {\n    const peers = qualityList.peers;\n    const hmsPeers: HMSConnectionQuality[] = peers.map(peer => {\n      const storePeer = this.store.getPeerById(peer.peer_id);\n      if (storePeer) {\n        storePeer.updateNetworkQuality(peer.downlink_score);\n      }\n      return {\n        peerID: peer.peer_id,\n        downlinkQuality: peer.downlink_score,\n      };\n    });\n    this.listener?.onConnectionQualityUpdate(hmsPeers);\n  }\n}\n", "import { VideoTrackLayerUpdate } from '../../connection/channel-messages';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSRemotePeer, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack, HMSTrackType } from '../../media/tracks';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { OnTrackLayerUpdateNotification, TrackState, TrackStateNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Incoming track meta-data from BIZ(signal) to match a track to a peer.\n * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.\n * - Mute/unmute track meta-data updates from BIZ.\n *\n * Since track meta-data and RTC tracks come in asynchronously,\n * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.\n *\n * Once we have both TrackState and track,\n * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.\n *\n * Gotchas:\n * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n */\nexport class TrackManager {\n  public TAG = '[TrackManager]';\n  private tracksToProcess: Map<string, HMSRemoteTrack> = new Map();\n\n  constructor(public store: IStore, public eventBus: EventBus, public listener?: HMSUpdateListener) {}\n\n  /**\n   * Add event from biz on track-add\n   * @param params TrackStateNotification\n   */\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    HMSLogger.d(this.TAG, `TRACK_METADATA_ADD`, JSON.stringify(params, null, 2));\n\n    for (const trackId in params.tracks) {\n      const trackInfo = params.tracks[trackId];\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo,\n      });\n    }\n    this.processPendingTracks();\n  }\n\n  /**\n   * Sets the tracks to peer and returns the peer\n   */\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKADD`, `${track}`);\n    this.tracksToProcess.set(track.trackId, track);\n    this.processPendingTracks();\n  };\n\n  handleTrackRemovedPermanently = (notification: TrackStateNotification) => {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, notification);\n    const trackIds = Object.keys(notification.tracks);\n\n    trackIds.forEach(trackId => {\n      const trackStateEntry = this.store.getTrackState(trackId);\n\n      if (!trackStateEntry) {\n        return;\n      }\n\n      const track = this.store.getTrackById(trackId);\n      if (!track) {\n        HMSLogger.d(this.TAG, 'Track not found in store');\n        return;\n      }\n\n      // emit this event here as peer will already be removed(if left the room) by the time this event is received\n      track.type === HMSTrackType.AUDIO && this.eventBus.audioTrackRemoved.publish(track as HMSRemoteAudioTrack);\n      this.store.removeTrack(track);\n      const hmsPeer = this.store.getPeerById(trackStateEntry.peerId);\n      if (!hmsPeer) {\n        return;\n      }\n      this.removePeerTracks(hmsPeer, track as HMSRemoteTrack);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    });\n  };\n\n  /**\n   * Sets the track of corresponding peer to null and returns the peer\n   */\n  handleTrackRemove(track: HMSRemoteTrack, remove = true) {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, `${track}`);\n\n    const trackStateEntry = this.store.getTrackState(track.trackId);\n\n    if (!trackStateEntry) {\n      return;\n    }\n\n    const storeHasTrack = this.store.hasTrack(track);\n    if (!storeHasTrack) {\n      HMSLogger.d(this.TAG, 'Track not found in store');\n      return;\n    }\n\n    // remove tracks only when onDemandTracks flag is false\n    if (remove) {\n      this.store.removeTrack(track);\n      const hmsPeer = this.store.getPeerById(trackStateEntry.peerId);\n      if (!hmsPeer) {\n        return;\n      }\n      this.removePeerTracks(hmsPeer, track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n\n      // emit this event here as peer will already be removed(if left the room) by the time this event is received\n      track.type === HMSTrackType.AUDIO && this.eventBus.audioTrackRemoved.publish(track as HMSRemoteAudioTrack);\n    }\n  }\n\n  handleTrackLayerUpdate = (params: OnTrackLayerUpdateNotification) => {\n    for (const trackId in params.tracks) {\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n      if (!track) {\n        continue;\n      }\n\n      const peer = this.store.getPeerByTrackId(trackId)!;\n      if (!peer) {\n        continue;\n      }\n\n      if (track instanceof HMSRemoteVideoTrack) {\n        this.setLayer(track, trackEntry);\n      }\n    }\n  };\n\n  // eslint-disable-next-line complexity\n  handleTrackUpdate = (params: TrackStateNotification, callListener = true) => {\n    let hmsPeer = this.store.getPeerById(params.peer.peer_id);\n    const notifPeer = params.peer;\n    if (!hmsPeer && !notifPeer) {\n      HMSLogger.d(this.TAG, 'Track Update ignored - Peer not added to store');\n      return;\n    }\n    if (!hmsPeer) {\n      hmsPeer = new HMSPeer({\n        peerId: notifPeer.peer_id,\n        name: notifPeer.info.name,\n        isLocal: false,\n        role: this.store.getPolicyForRole(notifPeer.role),\n        customerUserId: notifPeer.info.user_id,\n        metadata: notifPeer.info.data,\n        groups: notifPeer.groups,\n      });\n      this.store.addPeer(hmsPeer);\n    }\n\n    for (const trackId in params.tracks) {\n      const currentTrackStateInfo = Object.assign({}, this.store.getTrackState(trackId)?.trackInfo);\n\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: { ...currentTrackStateInfo, ...trackEntry },\n      });\n\n      // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n      if (!track || this.tracksToProcess.has(trackId)) {\n        this.processTrackInfo(trackEntry, params.peer.peer_id, callListener);\n        this.processPendingTracks();\n      } else {\n        track.setEnabled(!trackEntry.mute);\n        const eventType = this.processTrackUpdate(track as HMSRemoteTrack, currentTrackStateInfo, trackEntry);\n        if (eventType) {\n          this.listener?.onTrackUpdate(eventType, track, hmsPeer);\n        }\n      }\n    }\n  };\n\n  processTrackInfo = (_trackInfo: TrackState, _peerId: string, _callListener?: boolean) => {};\n\n  processPendingTracks = () => {\n    const tracksCopy = new Map(this.tracksToProcess);\n    tracksCopy.forEach(track => {\n      const state = this.store.getTrackState(track.trackId);\n      if (!state) {\n        HMSLogger.d(this.TAG, 'TrackState not added to store', `peerId - ${track.peerId}`, `trackId -${track.trackId}`);\n        return;\n      }\n\n      const hmsPeer = this.store.getPeerById(state.peerId);\n      if (!hmsPeer) {\n        HMSLogger.d(this.TAG, 'Peer not added to store, peerId', state.peerId);\n        return;\n      }\n\n      track.source = state.trackInfo.source;\n      track.peerId = hmsPeer.peerId;\n      // set log identifier to initial name of the peer\n      track.logIdentifier = hmsPeer.name;\n      track.setEnabled(!state.trackInfo.mute);\n      this.addAudioTrack(hmsPeer, track);\n      this.addVideoTrack(hmsPeer, track);\n      /**\n       * Don't call onTrackUpdate for audio elements immediately because the operations(eg: setVolume) performed\n       * on onTrackUpdate can be overriden in AudioSinkManager when audio element is created\n       **/\n      track.type === HMSTrackType.AUDIO\n        ? this.eventBus.audioTrackAdded.publish({ track: track as HMSRemoteAudioTrack, peer: hmsPeer as HMSRemotePeer })\n        : this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);\n      this.tracksToProcess.delete(track.trackId);\n    });\n  };\n\n  private setLayer(track: HMSRemoteVideoTrack, layerUpdate: VideoTrackLayerUpdate) {\n    const peer = this.store.getPeerByTrackId(track.trackId);\n    if (!peer) {\n      return;\n    }\n    const isDegraded = track.setLayerFromServer(layerUpdate);\n    if (isDegraded) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DEGRADED, track, peer);\n    } else {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_RESTORED, track, peer);\n    }\n  }\n\n  removePeerTracks(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    const auxiliaryTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);\n    if (auxiliaryTrackIndex > -1) {\n      hmsPeer.auxiliaryTracks.splice(auxiliaryTrackIndex, 1);\n      HMSLogger.d(this.TAG, 'auxiliary track removed', `${track}`);\n    } else {\n      if (track.type === HMSTrackType.AUDIO && hmsPeer.audioTrack === track) {\n        hmsPeer.audioTrack = undefined;\n        HMSLogger.d(this.TAG, 'audio track removed', `${track}`);\n      } else if (track.type === HMSTrackType.VIDEO && hmsPeer.videoTrack === track) {\n        hmsPeer.videoTrack = undefined;\n        HMSLogger.d(this.TAG, 'video track removed', `${track}`);\n      }\n    }\n  }\n\n  private addAudioTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.AUDIO) {\n      return;\n    }\n    if (track.source === 'regular' && (!hmsPeer.audioTrack || hmsPeer.audioTrack?.trackId === track.trackId)) {\n      hmsPeer.audioTrack = track as HMSRemoteAudioTrack;\n    } else {\n      hmsPeer.auxiliaryTracks.push(track);\n    }\n    this.store.addTrack(track);\n    HMSLogger.d(this.TAG, 'audio track added', `${track}`);\n  }\n\n  addVideoTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.VIDEO) {\n      return;\n    }\n    const remoteTrack = track as HMSRemoteVideoTrack;\n    const simulcastDefinitions = this.store.getSimulcastDefinitionsForPeer(hmsPeer, remoteTrack.source!);\n    remoteTrack.setSimulcastDefinitons(simulcastDefinitions);\n    if (this.addAsPrimaryVideoTrack(hmsPeer, remoteTrack)) {\n      if (!hmsPeer.videoTrack) {\n        hmsPeer.videoTrack = remoteTrack;\n      } else {\n        (hmsPeer.videoTrack as HMSRemoteVideoTrack).replaceTrack(remoteTrack);\n      }\n      this.store.addTrack(hmsPeer.videoTrack);\n    } else {\n      const index = hmsPeer.auxiliaryTracks.findIndex(track => track.trackId === remoteTrack.trackId);\n      if (index === -1) {\n        hmsPeer.auxiliaryTracks.push(remoteTrack);\n        this.store.addTrack(remoteTrack);\n      } else {\n        (hmsPeer.auxiliaryTracks[index] as HMSRemoteVideoTrack).replaceTrack(remoteTrack);\n        this.store.addTrack(hmsPeer.auxiliaryTracks[index]);\n      }\n    }\n    HMSLogger.d(this.TAG, 'video track added', `${track}`);\n  }\n\n  addAsPrimaryVideoTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    return track.source === 'regular' && (!hmsPeer.videoTrack || hmsPeer.videoTrack?.trackId === track.trackId);\n  }\n\n  private processTrackUpdate(track: HMSRemoteTrack, currentTrackState: TrackState, trackState: TrackState) {\n    let eventType;\n    if (currentTrackState.mute !== trackState.mute) {\n      eventType = trackState.mute ? HMSTrackUpdate.TRACK_MUTED : HMSTrackUpdate.TRACK_UNMUTED;\n      track.type === HMSTrackType.AUDIO &&\n        this.eventBus.audioTrackUpdate.publish({ track: track as HMSRemoteAudioTrack, enabled: !trackState.mute });\n    } else if (currentTrackState.description !== trackState.description) {\n      eventType = HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED;\n    }\n    return eventType;\n  }\n}\n", "import { TrackManager } from './TrackManager';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSPeer, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteStream } from '../../media/streams/HMSRemoteStream';\nimport { HMSRemoteTrack, HMSRemoteVideoTrack } from '../../media/tracks';\nimport { LocalTrackManager } from '../../sdk/LocalTrackManager';\nimport { IStore } from '../../sdk/store';\nimport HMSTransport from '../../transport';\nimport HMSLogger from '../../utils/logger';\nimport { isEmptyTrack } from '../../utils/track';\nimport { TrackState, TrackStateNotification } from '../HMSNotifications';\n\nexport class OnDemandTrackManager extends TrackManager {\n  TAG = '[OnDemandTrackManager]';\n\n  constructor(store: IStore, eventBus: EventBus, private transport: HMSTransport, listener?: HMSUpdateListener) {\n    super(store, eventBus, listener);\n  }\n\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    super.handleTrackMetadataAdd(params);\n    for (const trackId in params.tracks) {\n      if (params.tracks[trackId].type === 'video') {\n        this.processTrackInfo(params.tracks[trackId], params.peer.peer_id);\n      }\n    }\n  }\n\n  handleTrackRemove(track: HMSRemoteTrack) {\n    const isRegularVideo = track.type === 'video' && track.source === 'regular';\n    super.handleTrackRemove(track, !isRegularVideo);\n    if (isRegularVideo) {\n      this.processTrackInfo(\n        {\n          track_id: track.trackId,\n          mute: !track.enabled,\n          type: track.type,\n          source: track.source,\n          stream_id: track.stream.id,\n        } as TrackState,\n        track.peerId!,\n        false,\n      );\n    }\n  }\n\n  /**\n   * Add a blank track for the track received from biz so that the UI can render and show video element\n   * which will trigger the prefer-video-track-state request which results in the actual track being\n   * received from the sfu.\n   * This will also be called when track is removed, as it can be removed when none is sent to sfu to\n   * reduce the overall offer size\n   * @param {TrackState} trackInfo\n   * @param {string} peerId\n   * @param {boolean} callListener\n   * @returns\n   */\n  processTrackInfo = (trackInfo: TrackState, peerId: string, callListener = true) => {\n    if (trackInfo.type !== 'video') {\n      return;\n    }\n    const hmsPeer = this.store.getPeerById(peerId);\n    if (!hmsPeer || !this.isPeerRoleSubscribed(peerId)) {\n      HMSLogger.d(this.TAG, `no peer in store for peerId: ${peerId}`);\n      return;\n    }\n    const remoteStream = new HMSRemoteStream(new MediaStream(), this.transport.getSubscribeConnection()!);\n    const emptyTrack = LocalTrackManager.getEmptyVideoTrack();\n    emptyTrack.enabled = !trackInfo.mute;\n    const track = new HMSRemoteVideoTrack(remoteStream, emptyTrack, trackInfo.source);\n    track.setTrackId(trackInfo.track_id);\n    track.peerId = hmsPeer.peerId;\n    track.logIdentifier = hmsPeer.name;\n    this.addVideoTrack(hmsPeer, track);\n    if (callListener) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsPeer.videoTrack!, hmsPeer);\n    }\n  };\n\n  addAsPrimaryVideoTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.source !== 'regular') {\n      return false;\n    }\n    if (!hmsPeer.videoTrack) {\n      return true;\n    }\n    if (hmsPeer.videoTrack.trackId === track.trackId) {\n      return true;\n    }\n    return hmsPeer.videoTrack.enabled && isEmptyTrack(hmsPeer.videoTrack.nativeTrack);\n  }\n\n  private isPeerRoleSubscribed(peerId?: string) {\n    if (!peerId) {\n      return true;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const peer = this.store.getPeerById(peerId);\n    return peer && localPeer?.role?.subscribeParams?.subscribeToRoles?.includes(peer.role?.name!);\n  }\n}\n", "import { PeerManager } from './PeerManager';\nimport { TrackManager } from './TrackManager';\nimport { HMSUpdateListener } from '../..';\nimport { HMSTrackUpdate } from '../../interfaces';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { PeerListNotification, PeerNotification, PeriodicRoomState } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Initial Peer List - get peer and track meta-data for peers who are already in the room when you join\n * - Reconnect Peer List - Handle peer and track changes in the room missed out due to reconnection\n *\n * Cases to handle in reconnect peer list:\n * - Add additional peers as peer join\n * - Remove missing peers as peer leave\n * - For existing peers:\n *    - Add new tracks as track add\n *    - Remove missing tracks as track remove\n *    - Track state change(enabled) as track update\n */\nexport class PeerListManager {\n  private readonly TAG = '[PeerListManager]';\n  constructor(\n    private store: IStore,\n    private peerManager: PeerManager,\n    private trackManager: TrackManager,\n    public listener?: HMSUpdateListener,\n  ) {}\n\n  handleNotification(method: string, notification: any, isReconnecting: boolean) {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      const peerList = notification as PeerListNotification;\n      if (isReconnecting) {\n        HMSLogger.d(this.TAG, `RECONNECT_PEER_LIST event`, JSON.stringify(peerList, null, 2));\n        this.handleReconnectPeerList(peerList);\n      } else {\n        // TODO: Don't call initial peerlist if atleast 1room state had happen\n        HMSLogger.d(this.TAG, `PEER_LIST event`, JSON.stringify(peerList, null, 2));\n        this.handleInitialPeerList(peerList);\n      }\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      const roomState = notification as PeriodicRoomState;\n      this.handlePreviewRoomState(roomState);\n    }\n  }\n\n  private handleInitialPeerList = (peerList: PeerListNotification) => {\n    const peers = Object.values(peerList.peers);\n    this.peerManager.handlePeerList(peers);\n  };\n\n  private handleReconnectPeerList = (peerList: PeerListNotification) => {\n    this.handleRepeatedPeerList(peerList.peers);\n  };\n\n  private handlePreviewRoomState = (roomState: PeriodicRoomState) => {\n    if (!this.store.hasRoleDetailsArrived()) {\n      // we can't process the peers yet we don't know enough about them(role info)\n      return;\n    }\n    const roomPeers = roomState.peers;\n    if (roomPeers === null || roomPeers === undefined) {\n      // in this case, room state doesn't say anything about the peers,\n      // there can be optimisations in place to not send this field when it's unchanged from previously sent value.\n      // If there are no peers either roomState.peers will be empty object\n      // or peer_count will be 0(handled below)\n      if (roomState.peer_count === 0) {\n        this.handleRepeatedPeerList({});\n      }\n      return;\n    }\n    // we don't get tracks inside the peer object in room state, we're adding\n    // an empty value here so rest of the code flow can ignore this change, the below\n    // can be changed when tracks will be sent as a separate object in future\n    Object.keys(roomPeers).forEach(peer => {\n      roomPeers[peer].tracks = {};\n      roomPeers[peer].is_from_room_state = true;\n    });\n    this.handleRepeatedPeerList(roomPeers);\n  };\n\n  private handleRepeatedPeerList = (peersMap: Record<string, PeerNotification>) => {\n    const currentPeerList = this.store.getRemotePeers();\n    const peers = Object.values(peersMap);\n    const peersToRemove = currentPeerList.filter(hmsPeer => !peersMap[hmsPeer.peerId]);\n    if (peersToRemove.length > 0) {\n      HMSLogger.d(this.TAG, `${peersToRemove}`);\n    }\n\n    // Send peer-leave updates to all the missing peers\n    peersToRemove.forEach(peer => {\n      const peerNotification: PeerNotification = {\n        peer_id: peer.peerId,\n        role: peer.role?.name || '',\n        info: {\n          name: peer.name,\n          data: peer.metadata || '',\n          user_id: peer.customerUserId || '',\n        },\n        tracks: {},\n        groups: [],\n        realtime: peer.realtime,\n      };\n\n      this.peerManager.handlePeerLeave(peerNotification);\n    });\n\n    const peerList: PeerNotification[] = [];\n    // Check for any tracks which are added/removed\n    peers.forEach(newPeerNotification => {\n      const oldPeer = this.store.getPeerById(newPeerNotification.peer_id);\n      const newPeerTrackStates = Object.values(newPeerNotification.tracks);\n\n      if (oldPeer) {\n        // Peer already present in room, we take diff between the tracks\n        const tracks = this.store.getPeerTracks(oldPeer.peerId);\n\n        // Remove all the tracks which are not present in the peer.tracks\n        tracks.forEach(track => {\n          if (!newPeerNotification.tracks[track.trackId]) {\n            this.removePeerTrack(oldPeer, track.trackId);\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, oldPeer);\n          }\n        });\n\n        // Add track-metadata for all the new tracks\n        newPeerTrackStates.forEach(trackData => {\n          if (!this.store.getTrackById(trackData.track_id)) {\n            // NOTE: We assume that, once the connection is re-established,\n            //  transport layer will send a native onTrackAdd\n            this.store.setTrackState({\n              peerId: oldPeer.peerId,\n              trackInfo: trackData,\n            });\n          }\n        });\n\n        // Handle RTC track add and track state change.\n        this.trackManager.handleTrackUpdate(\n          {\n            peer: newPeerNotification,\n            tracks: newPeerNotification.tracks,\n          },\n          false,\n        );\n\n        // Update peer's role locally, new role is received from the reconnect peer-list\n        this.peerManager.handlePeerUpdate(newPeerNotification);\n        peerList.push(newPeerNotification);\n      } else {\n        // New peer joined while reconnecting\n        peerList.push(newPeerNotification);\n      }\n    });\n    if (peerList.length > 0) {\n      this.peerManager.handlePeerList(peerList);\n    }\n  };\n\n  private removePeerTrack(peer: HMSPeer, trackId: string) {\n    HMSLogger.d(this.TAG, `removing track - ${trackId} from ${peer}`);\n    if (peer.audioTrack?.trackId === trackId) {\n      peer.audioTrack = undefined;\n    } else if (peer.videoTrack?.trackId === trackId) {\n      peer.videoTrack = undefined;\n    } else {\n      const trackIndex = peer.auxiliaryTracks.findIndex(track => track.trackId === trackId);\n      trackIndex >= 0 && peer.auxiliaryTracks.splice(trackIndex, 1);\n    }\n  }\n}\n", "export const convertDateNumToDate = (dateNum?: number): Date | undefined => {\n  return dateNum ? new Date(dateNum) : undefined;\n};\n", "import { TrackManager } from './TrackManager';\nimport { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteVideoTrack } from '../../media/tracks';\nimport { HMSPeer, HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport { HAND_RAISE_GROUP_NAME } from '../../utils/constants';\nimport { convertDateNumToDate } from '../../utils/date';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { PeerNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - New peer join\n * - Peer Leave\n * - Role update for peer\n *\n * Notes:\n * - Peer join comes with track meta-data,\n * we add it to the store and call TrackManager to process it when RTC Track comes in.\n */\nexport class PeerManager {\n  private readonly TAG = '[PeerManager]';\n  constructor(private store: IStore, private trackManager: TrackManager, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        this.handlePeerJoin(peer);\n        break;\n      }\n\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        this.handlePeerLeave(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_UPDATE:\n        this.handlePeerUpdate(notification as PeerNotification);\n        break;\n      default:\n        break;\n    }\n  }\n\n  handlePeerList = (peers: PeerNotification[]) => {\n    if (peers.length === 0) {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, []);\n      return;\n    }\n    const hmsPeers: HMSRemotePeer[] = [];\n    const newPeers = new Set(peers.map(peer => peer.peer_id));\n    this.store.getRemotePeers().forEach(({ peerId, fromRoomState }) => {\n      /**\n       * Remove only if the peer join happened from preview roomstate update. This will prevent the peer joined\n       * from peer-join event post join from being removed from the store.\n       */\n      if (!newPeers.has(peerId) && fromRoomState) {\n        this.store.removePeer(peerId);\n      }\n    });\n    for (const peer of peers) {\n      hmsPeers.push(this.makePeer(peer));\n    }\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, hmsPeers);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerJoin = (peer: PeerNotification) => {\n    const hmsPeer = this.makePeer(peer);\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_JOINED, hmsPeer);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerLeave = (peer: PeerNotification) => {\n    const hmsPeer = this.store.getPeerById(peer.peer_id);\n    this.store.removePeer(peer.peer_id);\n    HMSLogger.d(this.TAG, `PEER_LEAVE`, peer.peer_id, `remainingPeers=${this.store.getPeers().length}`);\n\n    if (!hmsPeer) {\n      return;\n    }\n\n    if (hmsPeer.audioTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);\n    }\n\n    if (hmsPeer.videoTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);\n    }\n\n    hmsPeer.auxiliaryTracks?.forEach(track => {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LEFT, hmsPeer);\n  };\n\n  // eslint-disable-next-line complexity\n  handlePeerUpdate(notification: PeerNotification) {\n    let peer = this.store.getPeerById(notification.peer_id);\n    if (!peer && notification.realtime) {\n      // create peer if not already created in store\n      peer = this.makePeer(notification);\n      this.listener?.onPeerUpdate(\n        peer.isHandRaised ? HMSPeerUpdate.HAND_RAISE_CHANGED : HMSPeerUpdate.PEER_ADDED,\n        peer,\n      );\n      return;\n    }\n\n    // if peer is present but not realtime now, remove it from store\n    if (peer && !peer.isLocal && !notification.realtime) {\n      this.store.removePeer(peer.peerId);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_REMOVED, peer);\n      return;\n    }\n\n    if (!peer) {\n      HMSLogger.d(this.TAG, `peer ${notification.peer_id} not found`);\n      return;\n    }\n\n    if (peer.role && peer.role.name !== notification.role) {\n      const newRole = this.store.getPolicyForRole(notification.role);\n      peer.updateRole(newRole);\n      this.updateSimulcastLayersForPeer(peer);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, peer);\n    }\n    const wasHandRaised = peer.isHandRaised;\n    peer.updateGroups(notification.groups);\n    const isHandRaised = notification.groups?.includes(HAND_RAISE_GROUP_NAME);\n    if (wasHandRaised !== isHandRaised) {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.HAND_RAISE_CHANGED, peer);\n    }\n    this.handlePeerInfoUpdate({ peer, ...notification.info });\n  }\n\n  handlePeerInfoUpdate({ peer, name, data }: { peer?: HMSPeer; name?: string; data?: string }) {\n    if (!peer) {\n      return;\n    }\n    if (name && peer.name !== name) {\n      peer.updateName(name);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.NAME_UPDATED, peer);\n    }\n    if (data && peer.metadata !== data) {\n      peer.updateMetadata(data);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.METADATA_UPDATED, peer);\n    }\n  }\n\n  private makePeer(peer: PeerNotification) {\n    let hmsPeer = this.store.getPeerById(peer.peer_id) as HMSRemotePeer;\n    if (!hmsPeer) {\n      hmsPeer = new HMSRemotePeer({\n        peerId: peer.peer_id,\n        name: peer.info.name,\n        customerUserId: peer.info.user_id,\n        metadata: peer.info.data,\n        role: this.store.getPolicyForRole(peer.role),\n        joinedAt: convertDateNumToDate(peer.joined_at),\n        fromRoomState: !!peer.is_from_room_state,\n        groups: peer.groups,\n        realtime: peer.realtime,\n      });\n      this.store.addPeer(hmsPeer);\n      HMSLogger.d(this.TAG, `adding to the peerList`, `${hmsPeer}`);\n    }\n\n    for (const trackId in peer.tracks) {\n      const trackInfo = peer.tracks[trackId];\n      this.store.setTrackState({\n        peerId: peer.peer_id,\n        trackInfo,\n      });\n      if (trackInfo.type === 'video') {\n        this.trackManager.processTrackInfo(trackInfo, peer.peer_id, false);\n      }\n    }\n    return hmsPeer;\n  }\n\n  private updateSimulcastLayersForPeer(peer: HMSPeer) {\n    this.store.getPeerTracks(peer.peerId).forEach(track => {\n      if (track.type === 'video' && ['regular', 'screen'].includes(track.source!)) {\n        const remoteTrack = track as HMSRemoteVideoTrack;\n        const simulcastDefinitions = this.store.getSimulcastDefinitionsForPeer(peer, remoteTrack.source!);\n        remoteTrack.setSimulcastDefinitons(simulcastDefinitions);\n      }\n    });\n  }\n}\n", "import { EventBus } from '../../events/EventBus';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { PolicyParams } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Set policy with publishParams, simulcast layers to store\n * - Emit 'local-peer-role-update' to trigger RoleChangeManager to publish/unpublish local tracks\n * - Emit 'policy-change' to finish preview before calling listener.onPreview\n */\nexport class PolicyChangeManager {\n  constructor(private store: IStore, private eventBus: EventBus) {}\n\n  handlePolicyChange(params: PolicyParams) {\n    const localPeer = this.store.getLocalPeer();\n\n    if (localPeer && !localPeer.role) {\n      const newRole = params.known_roles[params.name];\n      localPeer.updateRole(newRole);\n    }\n\n    this.store.setKnownRoles(params);\n    const room = this.store.getRoom();\n    if (room) {\n      room.templateId = params.template_id;\n    } else {\n      HMSLogger.w('[PolicyChangeManager]', 'on policy change - room not present');\n    }\n    // handle when role is not present in known_roles\n    // const publishParams = params.known_roles[params.name]?.publishParams;\n    // this.store.setPublishParams(publishParams);\n\n    this.updateLocalPeerRole(params);\n    this.eventBus.policyChange.publish(params);\n  }\n\n  private updateLocalPeerRole(params: PolicyParams) {\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.role && localPeer.role.name !== params.name) {\n      const newRole = this.store.getPolicyForRole(params.name);\n      const oldRole = localPeer.role;\n      localPeer.updateRole(newRole);\n      if (newRole.name === localPeer.asRole?.name) {\n        delete localPeer.asRole;\n      }\n      this.eventBus.localRoleUpdate.publish({ oldRole, newRole });\n    }\n  }\n}\n", "import { HMSPoll, HMSPollQuestionResponse, HMSPollsUpdate, HMSUpdateListener } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport { PollResult } from '../../signal/interfaces';\nimport HMSTransport from '../../transport';\nimport { convertDateNumToDate } from '../../utils/date';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { PollStartNotification, PollStatsNotification, PollStopNotification } from '../HMSNotifications';\n\nexport class PollsManager {\n  constructor(private store: IStore, private transport: HMSTransport, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.POLL_START: {\n        this.handlePollStart(notification as PollStartNotification);\n        break;\n      }\n\n      case HMSNotificationMethod.POLL_STOP: {\n        this.handlePollStop(notification as PollStopNotification);\n        break;\n      }\n      case HMSNotificationMethod.POLL_STATS:\n        this.handlePollStats(notification as PollStatsNotification);\n\n        break;\n      default:\n        break;\n    }\n  }\n\n  private async handlePollStart(notification: PollStartNotification) {\n    const polls: HMSPoll[] = [];\n    for (const pollParams of notification.polls) {\n      if (this.store.getPoll(pollParams.poll_id)) {\n        return;\n      }\n\n      const questions = await this.transport.getPollQuestions({ poll_id: pollParams.poll_id, index: 0, count: 50 });\n      const poll: HMSPoll = {\n        id: pollParams.poll_id,\n        title: pollParams.title,\n        startedBy: pollParams.started_by,\n        createdBy: pollParams.created_by,\n        anonymous: pollParams.anonymous,\n        type: pollParams.type,\n        duration: pollParams.duration,\n        locked: pollParams.locked, // poll is locked automatically when it starts\n        mode: pollParams.mode as HMSPoll['mode'],\n        visibility: pollParams.visibility,\n        rolesThatCanVote: pollParams.vote || [],\n        rolesThatCanViewResponses: pollParams.responses || [],\n        state: pollParams.state,\n        stoppedBy: pollParams.stopped_by,\n        startedAt: convertDateNumToDate(pollParams.started_at),\n        stoppedAt: convertDateNumToDate(pollParams.stopped_at),\n        createdAt: convertDateNumToDate(pollParams.created_at),\n\n        questions: questions.questions.map(({ question, options, answer }) => ({ ...question, options, answer })),\n      };\n\n      polls.push(poll);\n      this.store.setPoll(poll);\n    }\n    this.listener?.onPollsUpdate(HMSPollsUpdate.POLL_STARTED, polls);\n  }\n\n  private async handlePollStop(notification: PollStopNotification) {\n    const stoppedPolls: HMSPoll[] = [];\n\n    for (const poll of notification.polls) {\n      const savedPoll = this.store.getPoll(poll.poll_id);\n      if (savedPoll) {\n        savedPoll.state = 'stopped';\n        savedPoll.stoppedAt = convertDateNumToDate(poll.stopped_at);\n        savedPoll.stoppedBy = poll.stopped_by;\n\n        const pollResult = await this.transport.getPollResult({ poll_id: poll.poll_id });\n        this.updatePollResult(savedPoll, pollResult);\n        stoppedPolls.push(savedPoll);\n      }\n    }\n\n    if (stoppedPolls.length > 0) {\n      this.listener?.onPollsUpdate(HMSPollsUpdate.POLL_STOPPED, stoppedPolls);\n    }\n  }\n\n  private async handlePollStats(notification: PollStatsNotification) {\n    const updatedPolls: HMSPoll[] = [];\n    for (const updatedPoll of notification.polls) {\n      const savedPoll = this.store.getPoll(updatedPoll.poll_id);\n      if (!savedPoll) {\n        return;\n      }\n\n      this.updatePollResult(savedPoll, updatedPoll);\n\n      const serverResponseParams = await this.transport.getPollResponses({\n        poll_id: updatedPoll.poll_id,\n        index: 0,\n        count: 50,\n        self: false,\n      });\n\n      serverResponseParams.responses?.forEach(({ response, peer, final }) => {\n        const question = savedPoll?.questions?.find(question => question.index === response.question);\n        if (!question) {\n          return;\n        }\n        const pollResponse: HMSPollQuestionResponse = {\n          id: response.response_id,\n          questionIndex: response.question,\n          option: response.option,\n          options: response.options,\n          text: response.text,\n          responseFinal: final,\n          peer: { peerid: peer.peerid, userHash: peer.hash, userid: peer.userid, username: peer.username },\n          skipped: response.skipped,\n          type: response.type,\n          update: response.update,\n        };\n\n        if (Array.isArray(question.responses) && question.responses.length > 0) {\n          if (!question.responses.find(({ id }) => id === pollResponse.id)) {\n            question.responses.push(pollResponse);\n          }\n        } else {\n          question.responses = [pollResponse];\n        }\n      });\n\n      updatedPolls.push(savedPoll);\n    }\n\n    if (updatedPolls.length > 0) {\n      this.listener?.onPollsUpdate(HMSPollsUpdate.POLL_STATS_UPDATED, updatedPolls);\n    }\n  }\n\n  private updatePollResult(savedPoll: HMSPoll, pollResult: PollResult) {\n    savedPoll.result = { ...savedPoll.result };\n    savedPoll.result.totalUsers = pollResult.user_count;\n    savedPoll.result.maxUsers = pollResult.max_user;\n    savedPoll.result.totalResponses = pollResult.total_response;\n\n    pollResult.questions?.forEach(updatedQuestion => {\n      const savedQuestion = savedPoll.questions?.find(question => question.index === updatedQuestion.question);\n      if (!savedQuestion) {\n        return;\n      }\n      savedQuestion.result = { ...savedQuestion.result };\n      savedQuestion.result.correctResponses = updatedQuestion.correct;\n      savedQuestion.result.skippedCount = updatedQuestion.skipped;\n      savedQuestion.result.totalResponses = updatedQuestion.total;\n\n      updatedQuestion.options?.forEach((updatedVoteCount, index) => {\n        const savedOption = savedQuestion.options?.[index];\n        if (savedOption && savedOption.voteCount !== updatedVoteCount) {\n          savedOption.voteCount = updatedVoteCount;\n        }\n      });\n    });\n  }\n}\n", "import { HMSRemotePeer, HMSRoleChangeRequest, HMSUpdateListener } from '../../interfaces';\nimport { HMSLocalTrack, HMSTrackSource } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport {\n  ChangeTrackMuteStateNotification,\n  RoleChangeRequestParams,\n  TrackUpdateRequestNotification,\n} from '../HMSNotifications';\n\n/**\n * Handles request from remote peers to change something on the local side. For eg. role change, track mute/unmute.\n */\nexport class RequestManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.ROLE_CHANGE_REQUEST:\n        this.handleRoleChangeRequest(notification as RoleChangeRequestParams);\n        break;\n\n      case HMSNotificationMethod.TRACK_UPDATE_REQUEST:\n        this.handleTrackUpdateRequest(notification as TrackUpdateRequestNotification);\n        break;\n\n      case HMSNotificationMethod.CHANGE_TRACK_MUTE_STATE_UPDATE:\n        this.handleChangeTrackStateRequest(notification as ChangeTrackMuteStateNotification);\n        break;\n      default:\n        return;\n    }\n  }\n\n  private handleRoleChangeRequest(notification: RoleChangeRequestParams) {\n    const request: HMSRoleChangeRequest = {\n      requestedBy: notification.requested_by\n        ? (this.store.getPeerById(notification.requested_by) as HMSRemotePeer)\n        : undefined,\n      role: this.store.getPolicyForRole(notification.role),\n      token: notification.token,\n    };\n\n    this.listener?.onRoleChangeRequest(request);\n  }\n\n  // eslint-disable-next-line complexity\n  private handleTrackUpdateRequest(trackUpdateRequest: TrackUpdateRequestNotification) {\n    const { requested_by, track_id, mute } = trackUpdateRequest;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n    const track = this.store.getLocalPeerTracks().find(track => track.publishedTrackId === track_id);\n\n    if (!track) {\n      return;\n    }\n\n    const sendNotification = () => {\n      this.listener?.onChangeTrackStateRequest({ requestedBy: peer as HMSRemotePeer, track, enabled: !mute });\n    };\n\n    if (mute) {\n      // if track is already in the same state as change state, do nothing\n      if (track.enabled === !mute) {\n        return;\n      }\n      /**\n       * Directly mute track when request arrives\n       */\n      track.setEnabled(!mute).then(sendNotification);\n    } else {\n      /**\n       * Notify UI to unmute for requesting consent\n       */\n      sendNotification();\n    }\n  }\n\n  private handleChangeTrackStateRequest(request: ChangeTrackMuteStateNotification) {\n    const { type, source, value, requested_by } = request;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n\n    // value true means the track has to be muted\n    const enabled = !value;\n    const tracksToBeUpdated = this.getTracksToBeUpdated({ type, source, enabled });\n    //Do nothing if all tracks are already in same state as the request\n    if (tracksToBeUpdated.length === 0) {\n      return;\n    }\n    // if track is to be muted, mute and send the notification, otherwise send notification\n    if (!enabled) {\n      const promises: Promise<void>[] = [];\n\n      for (const track of tracksToBeUpdated) {\n        promises.push(track.setEnabled(false));\n      }\n      Promise.all(promises).then(() => {\n        this.listener?.onChangeMultiTrackStateRequest({\n          requestedBy: peer as HMSRemotePeer,\n          tracks: tracksToBeUpdated,\n          enabled: false,\n        });\n      });\n    } else {\n      this.listener?.onChangeMultiTrackStateRequest({\n        requestedBy: peer as HMSRemotePeer,\n        tracks: tracksToBeUpdated,\n        type,\n        source,\n        enabled: true,\n      });\n    }\n  }\n\n  /**\n   * Filter the local tracks based on type, source and enabled state\n   * @returns {HMSLocalTrack[]}\n   */\n  private getTracksToBeUpdated({\n    type,\n    source,\n    enabled,\n  }: {\n    type?: 'audio' | 'video';\n    source?: HMSTrackSource;\n    enabled: boolean;\n  }) {\n    const localPeerTracks = this.store.getLocalPeerTracks();\n    let tracks: HMSLocalTrack[] = localPeerTracks;\n    if (type) {\n      tracks = tracks.filter(track => track.type === type);\n    }\n    if (source) {\n      tracks = tracks.filter(track => track.source === source);\n    }\n    // filter out tracks which are already in the desired state\n    return tracks.filter(track => track.enabled !== enabled);\n  }\n}\n", "import { HMSAction } from '../../error/HMSAction';\nimport { HMSException } from '../../error/HMSException';\nimport { HMSHLS, HMSHLSRecording, HMSRoomUpdate, HMSUpdateListener } from '../../interfaces';\nimport { ServerError } from '../../interfaces/internal';\nimport { IStore } from '../../sdk/store';\nimport { convertDateNumToDate } from '../../utils/date';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport {\n  HLSNotification,\n  PeerListNotification,\n  PeriodicRoomState,\n  RecordingNotification,\n  RoomInfo,\n  RoomState,\n  RTMPNotification,\n  SessionInfo,\n} from '../HMSNotifications';\n\nexport class RoomUpdateManager {\n  private readonly TAG = '[RoomUpdateManager]';\n\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  // eslint-disable-next-line complexity\n  handleNotification(method: HMSNotificationMethod, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_LIST:\n        this.onRoomState((notification as PeerListNotification).room);\n        break;\n      case HMSNotificationMethod.RTMP_START:\n        this.onRTMPStart(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RTMP_STOP:\n        this.onRTMPStop(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_START:\n        this.onRecordingStart(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_STOP:\n        this.onRecordingStop(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.ROOM_STATE:\n        this.handlePreviewRoomState(notification as PeriodicRoomState);\n        break;\n      case HMSNotificationMethod.ROOM_INFO:\n        this.handleRoomInfo(notification as RoomInfo);\n        break;\n      case HMSNotificationMethod.SESSION_INFO:\n        this.handleSessionInfo(notification as SessionInfo);\n        break;\n      default:\n        this.onHLS(method, notification as HLSNotification);\n        break;\n    }\n  }\n\n  private handleRoomInfo(notification: RoomInfo) {\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'on session info - room not present');\n      return;\n    }\n    room.description = notification.description;\n    room.large_room_optimization = notification.large_room_optimization;\n    room.max_size = notification.max_size;\n    room.name = notification.name;\n  }\n\n  private handleSessionInfo(notification: SessionInfo) {\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'on session info - room not present');\n      return;\n    }\n    room.sessionId = notification.session_id;\n    if (room.peerCount !== notification.peer_count) {\n      room.peerCount = notification.peer_count;\n      this.listener?.onRoomUpdate(HMSRoomUpdate.ROOM_PEER_COUNT_UPDATED, room);\n    }\n  }\n\n  private handlePreviewRoomState(notification: PeriodicRoomState) {\n    const { room } = notification;\n    this.onRoomState(room, notification.peer_count);\n  }\n\n  private onRoomState(roomNotification: RoomState, peerCount?: number) {\n    const { recording, streaming, session_id, started_at, name } = roomNotification;\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'on room state - room not present');\n      return;\n    }\n\n    room.peerCount = peerCount;\n    room.name = name;\n    room.recording.server.running = !!recording?.sfu.enabled;\n    room.recording.browser.running = !!recording?.browser.enabled;\n    room.rtmp.running = !!streaming?.rtmp?.enabled;\n    room.rtmp.startedAt = convertDateNumToDate(streaming?.rtmp?.started_at);\n    room.recording.server.startedAt = convertDateNumToDate(recording?.sfu.started_at);\n    room.recording.browser.startedAt = convertDateNumToDate(recording?.browser.started_at);\n    room.recording.hls = this.getPeerListHLSRecording(recording);\n    room.hls = this.convertHls(streaming?.hls);\n    room.sessionId = session_id;\n    room.startedAt = convertDateNumToDate(started_at);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RECORDING_STATE_UPDATED, room);\n  }\n\n  private onRTMPStart(notification: RTMPNotification) {\n    this.setRTMPStatus(!notification.error?.code, notification);\n  }\n\n  private onRTMPStop(notification: RTMPNotification) {\n    this.setRTMPStatus(false, notification);\n  }\n\n  private onRecordingStart(notification: RecordingNotification) {\n    this.setRecordingStatus(!notification.error?.code, notification);\n  }\n\n  private onRecordingStop(notification: RecordingNotification) {\n    this.setRecordingStatus(false, notification);\n  }\n\n  private onHLS(method: string, notification: HLSNotification) {\n    if (![HMSNotificationMethod.HLS_START, HMSNotificationMethod.HLS_STOP].includes(method as HMSNotificationMethod)) {\n      return;\n    }\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'on hls - room not present');\n      return;\n    }\n\n    notification.enabled = method === HMSNotificationMethod.HLS_START && !notification.error?.code;\n    room.hls = this.convertHls(notification);\n    room.recording.hls = this.getHLSRecording(notification);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.HLS_STREAMING_STATE_UPDATED, room);\n  }\n\n  private convertHls(hlsNotification?: HLSNotification) {\n    const hls: HMSHLS = {\n      running: !!hlsNotification?.enabled,\n      variants: [],\n      error: this.toSdkError(hlsNotification?.error),\n    };\n    hlsNotification?.variants?.forEach(variant => {\n      hls.variants.push({\n        meetingURL: variant.meeting_url,\n        url: variant.url,\n        metadata: variant.metadata,\n        startedAt: convertDateNumToDate(variant.started_at),\n      });\n    });\n    return hls;\n  }\n\n  private getHLSRecording(hlsNotification?: HLSNotification): HMSHLSRecording {\n    let hlsRecording: HMSHLSRecording = { running: false };\n    if (hlsNotification?.hls_recording) {\n      hlsRecording = {\n        running: !!hlsNotification?.enabled,\n        singleFilePerLayer: !!hlsNotification.hls_recording?.single_file_per_layer,\n        hlsVod: !!hlsNotification.hls_recording?.hls_vod,\n        startedAt: convertDateNumToDate(hlsNotification?.variants?.[0].started_at),\n        error: this.toSdkError(hlsNotification.error),\n      };\n    }\n    return hlsRecording;\n  }\n\n  private getPeerListHLSRecording(recording?: RoomState['recording']): HMSHLSRecording {\n    const hlsNotification = recording?.hls;\n    return {\n      running: !!hlsNotification?.enabled,\n      startedAt: convertDateNumToDate(hlsNotification?.started_at),\n      singleFilePerLayer: !!hlsNotification?.config?.single_file_per_layer,\n      hlsVod: !!hlsNotification?.config?.hls_vod,\n    };\n  }\n\n  private setRecordingStatus(running: boolean, notification: RecordingNotification) {\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, `set recording status running=${running} - room not present`);\n      return;\n    }\n\n    let action: HMSRoomUpdate;\n    if (notification.type === 'sfu') {\n      room.recording.server = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.SERVER_RECORDING_STATE_UPDATED;\n    } else {\n      room.recording.browser = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.BROWSER_RECORDING_STATE_UPDATED;\n    }\n    this.listener?.onRoomUpdate(action, room);\n  }\n\n  private setRTMPStatus(running: boolean, notification: RTMPNotification) {\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'on policy change - room not present');\n      return;\n    }\n\n    room.rtmp = {\n      running,\n      startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n      error: this.toSdkError(notification.error),\n    };\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RTMP_STREAMING_STATE_UPDATED, room);\n  }\n\n  private toSdkError(error?: ServerError): HMSException | undefined {\n    if (!error?.code) {\n      return undefined;\n    }\n    const errMsg = error.message || 'error in streaming/recording';\n    const sdkError = new HMSException(error.code, 'ServerErrors', HMSAction.NONE, errMsg, errMsg);\n    HMSLogger.e(this.TAG, 'error in streaming/recording', sdkError);\n    return sdkError;\n  }\n}\n", "import { HMSUpdateListener, SessionStoreUpdate } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport { convertDateNumToDate } from '../../utils/date';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { MetadataChangeNotification } from '../HMSNotifications';\n\nexport class SessionMetadataManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    if (method !== HMSNotificationMethod.METADATA_CHANGE) {\n      return;\n    }\n    this.handleMetadataChange(notification);\n  }\n\n  private handleMetadataChange(notification: MetadataChangeNotification) {\n    const updates: SessionStoreUpdate[] = notification.values.map(update => ({\n      key: update.key,\n      value: update.data,\n      updatedAt: convertDateNumToDate(update.updated_at),\n      updatedBy: update.updated_by ? this.store.getPeerById(update.updated_by) : undefined,\n    }));\n    this.listener?.onSessionStoreUpdate(updates);\n  }\n}\n", "import { ActiveSpeakerManager } from './managers/ActiveSpeakerManager';\nimport { BroadcastManager } from './managers/BroadcastManager';\nimport { ConnectionQualityManager } from './managers/ConnectionQualityManager';\nimport { OnDemandTrackManager } from './managers/onDemandTrackManager';\nimport { PeerListManager } from './managers/PeerListManager';\nimport { PeerManager } from './managers/PeerManager';\nimport { PolicyChangeManager } from './managers/PolicyChangeManager';\nimport { PollsManager } from './managers/PollsManager';\nimport { RequestManager } from './managers/RequestManager';\nimport { RoomUpdateManager } from './managers/RoomUpdateManager';\nimport { SessionMetadataManager } from './managers/SessionMetadataManager';\nimport { TrackManager } from './managers/TrackManager';\nimport { HMSNotificationMethod } from './HMSNotificationMethod';\nimport {\n  ConnectionQualityList,\n  OnTrackLayerUpdateNotification,\n  PolicyParams,\n  SpeakerList,\n  TrackStateNotification,\n} from './HMSNotifications';\nimport { EventBus } from '../events/EventBus';\nimport { HMSAudioListener, HMSConnectionQualityListener, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport { InitFlags } from '../signal/init/models';\nimport HMSTransport from '../transport';\nimport HMSLogger from '../utils/logger';\n\nexport class NotificationManager {\n  private readonly TAG = '[HMSNotificationManager]';\n  private trackManager: TrackManager;\n  private peerManager: PeerManager;\n  private peerListManager: PeerListManager;\n  private activeSpeakerManager: ActiveSpeakerManager;\n  private connectionQualityManager: ConnectionQualityManager;\n  private broadcastManager: BroadcastManager;\n  private policyChangeManager: PolicyChangeManager;\n  private requestManager: RequestManager;\n  private roomUpdateManager: RoomUpdateManager;\n  private sessionMetadataManager: SessionMetadataManager;\n  private pollsManager: PollsManager;\n  /**\n   * room state can be sent before join in preview stage as well but that is outdated, based on\n   * eventual consistency and doesn't have all data. If we get at least one consistent room update\n   * from that point onwards we can rely on live server updates and ignore periodic room state messages\n   */\n  private hasConsistentRoomStateArrived = false;\n\n  constructor(\n    private store: IStore,\n    eventBus: EventBus,\n    private transport: HMSTransport,\n    private listener?: HMSUpdateListener,\n    private audioListener?: HMSAudioListener,\n    private connectionQualityListener?: HMSConnectionQualityListener,\n  ) {\n    const isOnDemandTracksEnabled = this.transport.isFlagEnabled(InitFlags.FLAG_ON_DEMAND_TRACKS);\n    this.trackManager = isOnDemandTracksEnabled\n      ? new OnDemandTrackManager(this.store, eventBus, this.transport, this.listener)\n      : new TrackManager(this.store, eventBus, this.listener);\n\n    this.peerManager = new PeerManager(this.store, this.trackManager, this.listener);\n    this.peerListManager = new PeerListManager(this.store, this.peerManager, this.trackManager, this.listener);\n    this.broadcastManager = new BroadcastManager(this.store, this.listener);\n    this.policyChangeManager = new PolicyChangeManager(this.store, eventBus);\n    this.requestManager = new RequestManager(this.store, this.listener);\n    this.activeSpeakerManager = new ActiveSpeakerManager(this.store, this.listener, this.audioListener);\n    this.connectionQualityManager = new ConnectionQualityManager(this.store, this.connectionQualityListener);\n    this.roomUpdateManager = new RoomUpdateManager(this.store, this.listener);\n    this.sessionMetadataManager = new SessionMetadataManager(this.store, this.listener);\n    this.pollsManager = new PollsManager(this.store, this.transport, this.listener);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n    this.trackManager.listener = listener;\n    this.peerManager.listener = listener;\n    this.peerListManager.listener = listener;\n    this.broadcastManager.listener = listener;\n    this.requestManager.listener = listener;\n    this.activeSpeakerManager.listener = listener;\n    this.roomUpdateManager.listener = listener;\n    this.sessionMetadataManager.listener = listener;\n    this.pollsManager.listener = listener;\n  }\n\n  setAudioListener(audioListener?: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.activeSpeakerManager.audioListener = audioListener;\n  }\n\n  setConnectionQualityListener(qualityListener?: HMSConnectionQualityListener) {\n    this.connectionQualityListener = qualityListener;\n    this.connectionQualityManager.listener = qualityListener;\n  }\n\n  handleNotification(message: { method: string; params: any }, isReconnecting = false) {\n    const method = message.method as HMSNotificationMethod;\n    const notification = message.params;\n\n    if (\n      ![\n        HMSNotificationMethod.ACTIVE_SPEAKERS,\n        HMSNotificationMethod.SFU_STATS,\n        HMSNotificationMethod.CONNECTION_QUALITY,\n        undefined, // this is is to ignore notifications without any method\n      ].includes(method)\n    ) {\n      HMSLogger.d(this.TAG, `Received notification - ${method}`, { notification });\n    }\n    if (method === HMSNotificationMethod.SFU_STATS) {\n      if (window.HMS?.ON_SFU_STATS && typeof window.HMS?.ON_SFU_STATS === 'function') {\n        window.HMS.ON_SFU_STATS(message.params);\n      }\n    }\n\n    if (this.ignoreNotification(method)) {\n      return;\n    }\n\n    this.roomUpdateManager.handleNotification(method, notification);\n    this.peerManager.handleNotification(method, notification);\n    this.requestManager.handleNotification(method, notification);\n    this.peerListManager.handleNotification(method, notification, isReconnecting);\n    this.broadcastManager.handleNotification(method, notification);\n    this.sessionMetadataManager.handleNotification(method, notification);\n    this.pollsManager.handleNotification(method, notification);\n    this.handleIsolatedMethods(method, notification);\n  }\n\n  // eslint-disable-next-line complexity\n  handleIsolatedMethods(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.TRACK_METADATA_ADD: {\n        this.trackManager.handleTrackMetadataAdd(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_UPDATE: {\n        this.trackManager.handleTrackUpdate(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_REMOVE: {\n        if (!notification.peer) {\n          HMSLogger.d(this.TAG, `Ignoring sfu notification - ${method}`, { notification });\n          return;\n        }\n        this.trackManager.handleTrackRemovedPermanently(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ON_SFU_TRACK_LAYER_UPDATE: {\n        this.trackManager.handleTrackLayerUpdate(notification as OnTrackLayerUpdateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        this.activeSpeakerManager.handleActiveSpeakers(notification as SpeakerList);\n        break;\n\n      case HMSNotificationMethod.CONNECTION_QUALITY:\n        this.connectionQualityManager.handleQualityUpdate(notification as ConnectionQualityList);\n        break;\n\n      case HMSNotificationMethod.POLICY_CHANGE:\n        this.policyChangeManager.handlePolicyChange(notification as PolicyParams);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  ignoreNotification = (method: string): boolean => {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      this.hasConsistentRoomStateArrived = true;\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      // ignore periodic inconsistent room state if consistent one has arrived at least once\n      return this.hasConsistentRoomStateArrived;\n    }\n    return false;\n  };\n\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackAdd(track);\n  };\n\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackRemove(track);\n  };\n\n  updateLocalPeer = ({ name, metadata }: { name?: string; metadata?: string }) => {\n    const peer = this.store.getLocalPeer();\n    this.peerManager.handlePeerInfoUpdate({ peer, name, data: metadata });\n  };\n}\n", "import HMSLogger from '../utils/logger';\n\nexport class AudioContextManager {\n  private audioContext: AudioContext;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private source: MediaElementAudioSourceNode;\n  private readonly TAG = '[AudioContextManager]';\n\n  constructor(element: HTMLMediaElement) {\n    this.audioContext = new AudioContext();\n    this.source = this.audioContext.createMediaElementSource(element);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Resume AudioContext if it is suspended\n   * Note: when the browser tab is muted by default, AudioContext will be in suspended state\n   * It has to be resumed for the video/audio to be played.\n   */\n  async resumeContext() {\n    if (this.audioContext.state === 'suspended') {\n      await this.audioContext.resume();\n      HMSLogger.d(this.TAG, 'AudioContext is resumed');\n    }\n  }\n\n  getAudioTrack() {\n    // Always create a destinationNode to get new audio track id\n    if (this.destinationNode) {\n      this.source.disconnect(this.destinationNode);\n    }\n    this.destinationNode = this.audioContext.createMediaStreamDestination();\n    this.source.connect(this.destinationNode);\n    return this.destinationNode.stream.getAudioTracks()[0];\n  }\n\n  cleanup() {\n    if (this.audioContext.state !== 'closed') {\n      this.audioContext.close().catch(e => {\n        HMSLogger.d(this.TAG, 'AudioContext close error', e.message);\n      });\n    }\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\n\n/**\n * Typed Event Emitter Reference:\n * https://rjzaworski.com/2019/10/event-emitters-in-typescript#a-typescript-event-emitter-interface\n */\n\nexport type EventMap = Record<string, any>;\n\nexport type EventKey<T extends EventMap> = string & keyof T;\nexport type EventReceiver<T> = (params: T) => void;\n\n// interface Emitter<T extends EventMap> {\n//   on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n// }\n\nexport abstract class TypedEventEmitter<T extends EventMap> extends EventEmitter {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.on(eventName, fn);\n  }\n\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.off(eventName, fn);\n  }\n\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]) {\n    return super.emit(eventName, params);\n  }\n\n  listeners<K extends EventKey<T>>(eventName: K): EventReceiver<T[K]>[] {\n    return super.listeners(eventName) as EventReceiver<T[K]>[];\n  }\n}\n", "import { AudioContextManager } from './AudioContextManager';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\n/**\n * This class handles audio playlist management\n * - An audio element and audio context which processes audio from audio element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the audio element created in the constructor\n *  - oncanplaythrough event of the audio element\n *    - resume the audio context if it is suspended\n *    - play the audio element\n *    - Get audio track from the audio context manager\n *    - The track is passed to playlist manager to publish\n */\nexport class PlaylistAudioManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private audioElement: HTMLAudioElement | null = null;\n  private track?: MediaStreamTrack;\n  private audioContextManager!: AudioContextManager;\n  private readonly TAG = '[PlaylistAudioManager]';\n  // This is to handle audio playing when seekTo is called when audio is paused\n  private seeked = false;\n\n  async play(url: string) {\n    this.audioElement = this.getAudioElement();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.audioElement = this.getAudioElement();\n      this.audioElement.src = url;\n      this.seeked = false;\n      this.audioElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user seeks jumps to any mid track timestamp\n      this.audioElement.oncanplaythrough = async () => {\n        try {\n          if (!this.audioElement) {\n            return;\n          }\n          this.audioContextManager.resumeContext();\n          // Create audio track only once and reuse, it will be updated with current content\n          if (!this.track) {\n            await this.audioElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            this.track = audioTrack;\n            resolve([audioTrack]);\n          } else {\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.audioElement.play();\n              resolve([this.track]);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing audio', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.audioElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.track ? [this.track.id] : [];\n  }\n\n  getElement() {\n    if (!this.audioElement) {\n      this.audioElement = this.getAudioElement();\n    }\n    return this.audioElement;\n  }\n\n  stop() {\n    this.audioElement?.pause();\n    this.audioElement?.removeAttribute('src');\n    this.audioElement = null;\n    this.audioContextManager?.cleanup();\n    this.track = undefined;\n  }\n\n  private getAudioElement() {\n    if (this.audioElement) {\n      return this.audioElement;\n    }\n    const audioElement = document.createElement('audio');\n    audioElement.crossOrigin = 'anonymous';\n    audioElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    audioElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(audioElement);\n    return audioElement;\n  }\n}\n", "import { AudioContextManager } from './AudioContextManager';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\n/**\n * This class handles video playlist management\n * - An video element, canvas and audio context which processes audio from video element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the video element created in the constructor\n *  - oncanplaythrough event of the video element\n *    - resume the audio context if it is suspended\n *    - set width/height on canvas\n *    - captureStream on canvas element if not already captured\n *    - play the video element\n *    - on video element is played, it is drawn to canvas\n *    - Get audio track from the audio context manager\n *    - add audioTrack to canvas stream\n *    - The audio and video tracks are passed to playlist manager to publish\n */\nexport class PlaylistVideoManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private readonly TAG = '[PlaylistVideoManager]';\n  private videoElement: HTMLVideoElement | null = null;\n  private canvasContext: CanvasRenderingContext2D | null = null;\n  private canvas!: HTMLCanvasElement;\n  private timer: any;\n  private tracks: MediaStreamTrack[] = [];\n  private audioContextManager!: AudioContextManager;\n  private DEFAUL_FPS = 24;\n  // This is to handle video playing when seekTo is called when video is paused\n  private seeked = false;\n\n  play(url: string) {\n    this.videoElement = this.getVideoElement();\n    this.createCanvas();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.videoElement = this.getVideoElement();\n      this.videoElement.src = url;\n      this.seeked = false;\n      this.videoElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user jumps to any mid track timestamp using seekTo\n      this.videoElement.oncanplaythrough = async () => {\n        try {\n          if (!this.videoElement) {\n            return;\n          }\n          this.canvas.width = this.videoElement.videoWidth;\n          this.canvas.height = this.videoElement.videoHeight;\n          // Capture stream only once and reuse the same tracks. it will be autoupdated with the selected video\n          if (this.tracks.length === 0) {\n            this.clearCanvasAndTracks();\n            //@ts-ignore\n            const stream = this.canvas.captureStream();\n            if (!stream) {\n              HMSLogger.e(this.TAG, 'Browser does not support captureStream');\n              return;\n            }\n            this.videoElement.onplay = this.drawImage;\n            await this.audioContextManager.resumeContext();\n            await this.videoElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            stream.addTrack(audioTrack);\n            stream.getTracks().forEach((track: MediaStreamTrack) => {\n              this.tracks.push(track);\n            });\n            resolve(this.tracks);\n          } else {\n            // No need to capture canvas stream/get audio track. They wull be auto updated\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.videoElement.play();\n              resolve(this.tracks);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n              // This event will be called on seekTo when paused. Just draw the one frame on canvas.\n              this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing video', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.videoElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.tracks.map(track => track.id);\n  }\n\n  getElement() {\n    if (!this.videoElement) {\n      this.videoElement = this.getVideoElement();\n    }\n    return this.videoElement;\n  }\n\n  stop() {\n    this.videoElement?.pause();\n    this.videoElement?.removeAttribute('src');\n    this.videoElement = null;\n    this.audioContextManager?.cleanup();\n    this.clearCanvasAndTracks();\n  }\n\n  private clearCanvasAndTracks() {\n    this.tracks = [];\n    // clear canvas before playing new video\n    this.canvasContext?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    clearTimeout(this.timer);\n  }\n\n  private drawImage = () => {\n    if (this.videoElement && !this.videoElement.paused && !this.videoElement.ended) {\n      this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n      this.timer = setTimeout(() => {\n        this.drawImage();\n      }, 1000 / this.DEFAUL_FPS);\n    }\n  };\n\n  private getVideoElement() {\n    if (this.videoElement) {\n      return this.videoElement;\n    }\n    const videoElement = document.createElement('video');\n    videoElement.crossOrigin = 'anonymous';\n    videoElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    videoElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(videoElement);\n    return videoElement;\n  }\n\n  private createCanvas() {\n    if (!this.canvas) {\n      this.canvas = document.createElement('canvas');\n      this.canvasContext = this.canvas.getContext('2d');\n    }\n  }\n}\n", "import { PlaylistAudioManager } from './PlaylistAudioManager';\nimport { PlaylistVideoManager } from './PlaylistVideoManager';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { EventBus } from '../events/EventBus';\nimport { HMSSdk } from '../index';\nimport { HMSPlaylistItem, HMSPlaylistManager, HMSPlaylistProgressEvent, HMSPlaylistType } from '../interfaces';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { stringifyMediaStreamTrack } from '../utils/json';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\ntype PlaylistManagerState<T> = {\n  audio: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n  video: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n};\n\nconst INITIAL_STATE: PlaylistManagerState<any> = {\n  audio: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n  video: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n};\n\nexport class PlaylistManager\n  extends TypedEventEmitter<{\n    newTrackStart: HMSPlaylistItem<any>;\n    playlistEnded: HMSPlaylistType;\n    currentTrackEnded: HMSPlaylistItem<any>;\n  }>\n  implements HMSPlaylistManager\n{\n  private state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n  private audioManager: PlaylistAudioManager;\n  private videoManager: PlaylistVideoManager;\n  private readonly TAG = '[PlaylistManager]';\n\n  constructor(private sdk: HMSSdk, private eventBus: EventBus) {\n    super();\n    this.audioManager = new PlaylistAudioManager();\n    this.videoManager = new PlaylistVideoManager();\n    this.addListeners();\n  }\n\n  getList<T>(type: HMSPlaylistType = HMSPlaylistType.audio): HMSPlaylistItem<T>[] {\n    return this.state[type].list;\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    if (!list || list.length === 0) {\n      HMSLogger.w(this.TAG, `Please pass in a list of HMSPlaylistItem's`);\n      return;\n    }\n    list.forEach((item: HMSPlaylistItem<T>) => {\n      if (!this.state[item.type].list.find(_item => _item.id === item.id)) {\n        this.state[item.type].list.push(item);\n      }\n    });\n  }\n\n  async clearList(type: HMSPlaylistType): Promise<void> {\n    if (this.isPlaying(type)) {\n      await this.stop(type);\n    }\n    this.state[type].list = [];\n  }\n\n  async removeItem(id: string, type: HMSPlaylistType): Promise<boolean> {\n    const { list, currentIndex } = this.state[type];\n    const index = list.findIndex(playItem => id === playItem.id);\n    if (index > -1) {\n      // stop if the item is playing\n      if (currentIndex === index && this.isPlaying(type)) {\n        await this.stop(type);\n      }\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  seek(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      const updatedValue = Math.max(element.currentTime + value, 0);\n      element.currentTime = Math.min(updatedValue, element.duration);\n    }\n  }\n\n  seekTo(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    if (value < 0) {\n      throw Error('value cannot be negative');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.currentTime = Math.min(value, element.duration);\n    }\n  }\n\n  setVolume(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.volume = value * 0.01;\n    }\n  }\n\n  getVolume(type: HMSPlaylistType = HMSPlaylistType.audio): number {\n    const element = this.getElement(type);\n    if (element) {\n      return Math.floor(element.volume * 100);\n    }\n    return 0;\n  }\n\n  getCurrentTime(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element?.currentTime || 0;\n  }\n\n  getCurrentIndex(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return this.state[type].currentIndex;\n  }\n\n  getCurrentProgress(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    const activeUrl = list[currentIndex]?.url;\n    const element = this.getElement(type);\n    if (!activeUrl || !element) {\n      return 0;\n    }\n    return Math.floor(100 * (element.currentTime / element.duration));\n  }\n\n  getCurrentSelection(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      return undefined;\n    }\n    return list[currentIndex];\n  }\n\n  isPlaying(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return !!element && !element.paused;\n  }\n\n  setIsAutoplayOn(type: HMSPlaylistType = HMSPlaylistType.audio, autoplay: boolean) {\n    this.state[type].isAutoplayOn = autoplay;\n  }\n\n  getPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element ? element.playbackRate : 1.0;\n  }\n\n  setPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio, value: number) {\n    if (value < 0.25 || value > 2.0) {\n      throw Error('Please pass a value between 0.25 and 2.0');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.playbackRate = value;\n    }\n  }\n\n  async setEnabled(\n    enabled: boolean,\n    { id, type = HMSPlaylistType.audio }: { id: string; type: HMSPlaylistType },\n  ): Promise<void> {\n    const list = this.state[type].list;\n    const currentIndex = list.findIndex(item => item.id === id);\n    if (!id || currentIndex === -1) {\n      HMSLogger.w(this.TAG, 'Pass a valid id');\n      return;\n    }\n    const url = this.state[type].list[currentIndex].url;\n    if (enabled) {\n      await this.play(url, type);\n    } else {\n      await this.pause(url, type);\n    }\n    this.state[type].currentIndex = currentIndex;\n    this.setDuration(type);\n  }\n\n  async playNext(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex >= list.length - 1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached end of playlist');\n    }\n    await this.play(list[currentIndex + 1].url, type);\n    this.state[type].currentIndex = currentIndex + 1;\n    this.setDuration(type);\n  }\n\n  async playPrevious(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex <= 0) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached start of playlist');\n    }\n    await this.play(list[currentIndex - 1].url, type);\n    this.state[type].currentIndex = currentIndex - 1;\n    this.setDuration(type);\n  }\n\n  async stop(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    manager.getElement()?.pause(); //pause local video/audio and remove tracks in next step\n    await this.removeTracks(type);\n    manager.stop();\n    this.state[type].currentIndex = -1;\n  }\n\n  cleanup() {\n    this.state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n    this.eventBus.localAudioEnabled.unsubscribe(this.handlePausePlaylist);\n    this.eventBus.localVideoEnabled.unsubscribe(this.handlePausePlaylist);\n    this.audioManager.stop();\n    this.videoManager.stop();\n  }\n\n  onProgress(fn: (progress: HMSPlaylistProgressEvent) => void) {\n    this.videoManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.video,\n          progress: this.getCurrentProgress(HMSPlaylistType.video),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n    this.audioManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.audio,\n          progress: this.getCurrentProgress(HMSPlaylistType.audio),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n  }\n\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('newTrackStart', fn);\n  }\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void) {\n    this.on('playlistEnded', fn);\n  }\n\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('currentTrackEnded', fn);\n  }\n\n  private getElement(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return type === HMSPlaylistType.audio ? this.audioManager.getElement() : this.videoManager.getElement();\n  }\n\n  private async removeTracks(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const tracks = manager.getTracks();\n    for (const trackId of tracks) {\n      await this.removeTrack(trackId);\n    }\n  }\n\n  private async play(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const element = manager.getElement();\n    if (this.isItemCurrentlyPlaying(url, type)) {\n      HMSLogger.w(this.TAG, `The ${type} is currently playing`);\n      return;\n    }\n    if (element?.src.includes(url)) {\n      await element.play();\n    } else {\n      element?.pause();\n      const tracks: MediaStreamTrack[] = await manager.play(url);\n      for (const track of tracks) {\n        await this.addTrack(track, type === HMSPlaylistType.audio ? 'audioplaylist' : 'videoplaylist');\n      }\n    }\n  }\n\n  private isItemCurrentlyPlaying(url: string, type: HMSPlaylistType): boolean {\n    const element = this.getElement(type);\n    return !!(element && !element.paused && element.src.includes(url));\n  }\n\n  private setDuration(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    const { list, currentIndex } = this.state[type];\n    if (list[currentIndex]) {\n      list[currentIndex].duration = element?.duration || 0;\n    }\n    this.emit('newTrackStart', list[currentIndex]);\n  }\n\n  private async pause(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const el = this.getElement(type);\n    if (el && !el.paused && el.src.includes(url)) {\n      el.pause();\n      HMSLogger.d(this.TAG, 'paused url', url);\n    } else {\n      HMSLogger.w(this.TAG, 'The passed in url is not currently playing');\n    }\n  }\n\n  private handlePausePlaylist = async ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) => {\n    if (enabled) {\n      return;\n    }\n    let type: HMSPlaylistType | undefined = undefined;\n    if (track.source === 'audioplaylist') {\n      type = HMSPlaylistType.audio;\n    }\n    if (track.source === 'videoplaylist') {\n      type = HMSPlaylistType.video;\n    }\n    if (!type) {\n      return;\n    }\n    this.getElement(type)?.pause();\n  };\n\n  private addListeners() {\n    this.audioManager.on('ended', () => this.handleEnded(HMSPlaylistType.audio));\n    this.videoManager.on('ended', () => this.handleEnded(HMSPlaylistType.video));\n    this.eventBus.localAudioEnabled.subscribe(this.handlePausePlaylist);\n    this.eventBus.localVideoEnabled.subscribe(this.handlePausePlaylist);\n  }\n\n  /**\n   * Remove tracks if reached the end of list otherwise play next\n   * @param {HMSPlaylistType} type\n   */\n  private async handleEnded(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex, isAutoplayOn } = this.state[type];\n    if (currentIndex === list.length - 1) {\n      await this.stop(type);\n      this.emit('playlistEnded', type);\n    } else {\n      if (isAutoplayOn) {\n        this.playNext(type);\n      } else {\n        // when autoplay not allowed, pause the media element\n        await this.pause(list[currentIndex].url, type);\n      }\n    }\n    this.emit('currentTrackEnded', list[currentIndex]);\n  }\n\n  private addTrack = async (track: MediaStreamTrack, source: string) => {\n    await this.sdk.addTrack(track, source);\n    HMSLogger.d(this.TAG, 'Playlist track added', stringifyMediaStreamTrack(track));\n  };\n\n  private removeTrack = async (trackId: string) => {\n    await this.sdk.removeTrack(trackId, true);\n    HMSLogger.d(this.TAG, 'Playlist track removed', trackId);\n  };\n}\n", "import { HMSSessionStore } from '../interfaces';\nimport ITransport from '../transport/ITransport';\nimport { convertDateNumToDate } from '../utils/date';\n\nexport class SessionStore implements HMSSessionStore {\n  private observedKeys: Set<string> = new Set();\n\n  constructor(private transport: ITransport) {}\n\n  async get(key: string) {\n    const { data, updated_at } = await this.transport.getSessionMetadata(key);\n\n    return { value: data, updatedAt: convertDateNumToDate(updated_at) };\n  }\n\n  async set(key: string, data: any) {\n    const { data: value, updated_at } = await this.transport.setSessionMetadata({ key, data });\n    const updatedAt = convertDateNumToDate(updated_at);\n    return { value, updatedAt };\n  }\n\n  async observe(keys: string[]) {\n    const prevObservedKeys = new Set(this.observedKeys);\n    keys.forEach(key => this.observedKeys.add(key));\n\n    if (this.observedKeys.size !== prevObservedKeys.size) {\n      try {\n        await this.transport.listenMetadataChange(Array.from(this.observedKeys));\n      } catch (e) {\n        this.observedKeys = prevObservedKeys;\n        throw e;\n      }\n    }\n  }\n\n  async unobserve(keys: string[]) {\n    const prevObservedKeys = new Set(this.observedKeys);\n    this.observedKeys = new Set([...this.observedKeys].filter(key => !keys.includes(key)));\n\n    if (this.observedKeys.size !== prevObservedKeys.size) {\n      try {\n        await this.transport.listenMetadataChange(Array.from(this.observedKeys));\n      } catch (e) {\n        this.observedKeys = prevObservedKeys;\n        throw e;\n      }\n    }\n  }\n}\n", "import { HMSPollQuestionCreateParams, HMSPollsUpdate, PollsListener } from '../../interfaces';\nimport { HMSInteractivityCenter } from '../../interfaces/session-store/interactivity-center';\nimport {\n  HMSPoll,\n  HMSPollCreateParams,\n  HMSPollQuestionAnswer,\n  HMSPollQuestionOption,\n  HMSPollQuestionResponse,\n  HMSPollQuestionResponseCreateParams,\n  HMSPollQuestionType,\n} from '../../interfaces/session-store/polls';\nimport { IStore } from '../../sdk/store';\nimport { PollQuestionParams, PollResponseParams } from '../../signal/interfaces';\nimport HMSTransport from '../../transport';\nimport { convertDateNumToDate } from '../../utils/date';\n\nexport class InteractivityCenter implements HMSInteractivityCenter {\n  constructor(private transport: HMSTransport, private store: IStore, private listener?: PollsListener) {}\n\n  setListener(listener?: PollsListener) {\n    this.listener = listener;\n  }\n\n  async createPoll(pollParams: HMSPollCreateParams) {\n    const { poll_id: serverPollID } = await this.transport.setPollInfo({\n      ...pollParams,\n      poll_id: pollParams.id,\n      vote: pollParams.rolesThatCanVote,\n      responses: pollParams.rolesThatCanViewResponses,\n    });\n\n    if (!pollParams.id) {\n      pollParams.id = serverPollID;\n    }\n\n    if (Array.isArray(pollParams.questions)) {\n      await this.addQuestionsToPoll(pollParams.id, pollParams.questions);\n    }\n\n    const questions = await this.transport.getPollQuestions({ poll_id: pollParams.id, index: 0, count: 50 });\n\n    const poll: HMSPoll = {\n      id: pollParams.id,\n      title: pollParams.title,\n      anonymous: pollParams.anonymous,\n      type: pollParams.type,\n      duration: pollParams.duration,\n      locked: pollParams.locked, // poll is locked automatically when it starts\n      mode: pollParams.mode,\n      visibility: pollParams.visibility,\n      rolesThatCanVote: pollParams.rolesThatCanVote || [],\n      rolesThatCanViewResponses: pollParams.rolesThatCanViewResponses || [],\n      state: 'created',\n      createdBy: this.store.getLocalPeer()?.peerId,\n      questions: questions.questions.map(({ question, options, answer }) => ({ ...question, options, answer })),\n    };\n\n    this.listener?.onPollsUpdate(HMSPollsUpdate.POLL_CREATED, [poll]);\n  }\n\n  async startPoll(poll: string | HMSPollCreateParams): Promise<void> {\n    if (typeof poll === 'string') {\n      await this.transport.startPoll({ poll_id: poll });\n    } else {\n      await this.createPoll(poll);\n      await this.transport.startPoll({ poll_id: poll.id });\n    }\n  }\n\n  async addQuestionsToPoll(pollID: string, questions: HMSPollQuestionCreateParams[]): Promise<void> {\n    if (questions.length > 0) {\n      await this.transport.setPollQuestions({\n        poll_id: pollID,\n        questions: questions.map((question, index) => this.createQuestionSetParams(question, index)),\n      });\n    }\n  }\n\n  async stopPoll(pollID: string): Promise<void> {\n    await this.transport.stopPoll({ poll_id: pollID });\n  }\n\n  async addResponsesToPoll(pollID: string, responses: HMSPollQuestionResponseCreateParams[]) {\n    const poll = this.store.getPoll(pollID);\n    if (!poll) {\n      throw new Error('Invalid poll ID - Poll not found');\n    }\n    const responsesParams: PollResponseParams[] = responses.map(response => {\n      const question = this.getQuestionInPoll(poll, response.questionIndex);\n      if (question.type === HMSPollQuestionType.SINGLE_CHOICE) {\n        response.option = response.option || response.options?.[0] || -1;\n        delete response.text;\n        delete response.options;\n      } else if (question.type === HMSPollQuestionType.MULTIPLE_CHOICE) {\n        response.options?.sort();\n        delete response.text;\n        delete response.option;\n      } else {\n        delete response.option;\n        delete response.options;\n      }\n\n      if (response.skipped) {\n        delete response.option;\n        delete response.options;\n        delete response.text;\n      }\n\n      return { duration: 0, type: question.type, question: response.questionIndex, ...response };\n    });\n\n    await this.transport.setPollResponses({ poll_id: pollID, responses: responsesParams });\n  }\n\n  async getPolls(): Promise<HMSPoll[]> {\n    const pollsList = await this.transport.getPollsList({ count: 50 });\n    const polls: HMSPoll[] = [];\n    for (const pollParams of pollsList.polls) {\n      const questions = await this.transport.getPollQuestions({ poll_id: pollParams.poll_id, index: 0, count: 50 });\n      const poll: HMSPoll = {\n        id: pollParams.poll_id,\n        title: pollParams.title,\n        startedBy: pollParams.started_by,\n        createdBy: pollParams.created_by,\n        anonymous: pollParams.anonymous,\n        type: pollParams.type,\n        duration: pollParams.duration,\n        locked: pollParams.locked, // poll is locked automatically when it starts\n        mode: pollParams.mode as HMSPoll['mode'],\n        visibility: pollParams.visibility,\n        rolesThatCanVote: pollParams.vote || [],\n        rolesThatCanViewResponses: pollParams.responses || [],\n        state: pollParams.state,\n        stoppedBy: pollParams.stopped_by,\n        startedAt: convertDateNumToDate(pollParams.started_at),\n        stoppedAt: convertDateNumToDate(pollParams.stopped_at),\n        createdAt: convertDateNumToDate(pollParams.created_at),\n\n        questions: questions.questions.map(({ question, options, answer }) => ({ ...question, options, answer })),\n      };\n\n      polls.push(poll);\n      this.store.setPoll(poll);\n    }\n\n    return polls;\n  }\n\n  getResponses(_pollID: string): Promise<HMSPollQuestionResponse[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  private createQuestionSetParams(questionParams: HMSPollQuestionCreateParams, index: number): PollQuestionParams {\n    const question: PollQuestionParams['question'] = { ...questionParams, index: index + 1 };\n    let options: HMSPollQuestionOption[] | undefined;\n    const answer: HMSPollQuestionAnswer = questionParams.answer || { hidden: false };\n    if (\n      Array.isArray(questionParams.options) &&\n      [HMSPollQuestionType.SINGLE_CHOICE, HMSPollQuestionType.MULTIPLE_CHOICE].includes(questionParams.type)\n    ) {\n      options = questionParams.options?.map((option, index) => ({\n        index: index + 1,\n        text: option.text,\n        weight: option.weight,\n      }));\n\n      delete answer?.text;\n      if (questionParams.type === HMSPollQuestionType.SINGLE_CHOICE) {\n        answer.option = questionParams.options.findIndex(option => option.isCorrectAnswer) + 1 || undefined;\n      } else {\n        answer.options = questionParams.options\n          .map((option, index) => (option.isCorrectAnswer ? index + 1 : undefined))\n          .filter((val): val is number => !!val);\n      }\n    } else {\n      delete answer?.options;\n      delete answer?.option;\n    }\n\n    return { question, options, answer };\n  }\n\n  private getQuestionInPoll(poll: HMSPoll, questionIndex: number) {\n    const question = poll?.questions?.find(question => question.index === questionIndex);\n    if (!question) {\n      throw new Error('Invalid question index - Question not found in poll');\n    }\n\n    return question;\n  }\n}\n", "export class JoinParameters {\n  constructor(\n    public authToken: string,\n    public peerId: string,\n    public peerName: string = '',\n    public data: string = '',\n    public endpoint: string = 'https://prod-init.100ms.live/init',\n    public autoSubscribeVideo: boolean = false,\n  ) {}\n}\n", "export enum TransportFailureCategory {\n  ConnectFailed,\n  SignalDisconnect,\n  JoinWSMessageFailed,\n  PublishIceConnectionFailed,\n  SubscribeIceConnectionFailed,\n}\n\nexport const Dependencies = {\n  [TransportFailureCategory.ConnectFailed]: [],\n  [TransportFailureCategory.SignalDisconnect]: [],\n  [TransportFailureCategory.JoinWSMessageFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.PublishIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.SubscribeIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n};\n", "export enum TransportState {\n  Disconnected = 'Disconnected',\n  Connecting = 'Connecting',\n  Joined = 'Joined',\n  Preview = 'Preview',\n  Failed = 'Failed',\n  Reconnecting = 'Reconnecting',\n  Leaving = 'Leaving',\n}\n", "export interface PromiseCallbacks<T, K = void> {\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n  metadata?: K;\n}\n\nexport class PromiseWithCallbacks<T> {\n  promise: Promise<T>;\n  resolve!: (value: T) => void;\n  reject!: (reason?: any) => void;\n\n  constructor(cb: (resolve: (value: T) => void, reject: (reason?: any) => void) => any) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      cb(resolve, reject);\n    });\n  }\n}\n", "import { Dependencies as TFCDependencies, TransportFailureCategory as TFC } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\nimport { HMSException } from '../error/HMSException';\nimport { MAX_TRANSPORT_RETRIES, MAX_TRANSPORT_RETRY_DELAY } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { PromiseWithCallbacks } from '../utils/promise';\n\n/**\n * Task which is executed by [RetryScheduler.schedule] until max retry count\n * is reached.\n *\n * Any exception raised while executing the task assumes that task is failed.\n * Failed tasks are retried if max retry count is not reached.\n *\n * @returns True if the task if successful, otherwise False\n *\n *\n */\ntype RetryTask = () => Promise<boolean>;\n\ninterface ScheduleTaskParams {\n  category: TFC;\n  error: HMSException;\n  task: RetryTask;\n  originalState: TransportState;\n  maxFailedRetries?: number;\n  changeState?: boolean;\n}\n\nexport class RetryScheduler {\n  private readonly TAG = '[RetryScheduler]';\n  private inProgress = new Map<TFC, PromiseWithCallbacks<number>>();\n  private retryTaskIds: number[] = [];\n\n  constructor(\n    private onStateChange: (state: TransportState, error?: HMSException) => Promise<void>,\n    private sendEvent: (error: HMSException, category: TFC) => void,\n  ) {}\n\n  async schedule({\n    category,\n    error,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    changeState = true,\n  }: ScheduleTaskParams) {\n    await this.scheduleTask({ category, error, changeState, task, originalState, maxFailedRetries });\n  }\n\n  reset() {\n    this.retryTaskIds.forEach(future => clearTimeout(future));\n    this.retryTaskIds = [];\n    this.inProgress.clear();\n  }\n\n  isTaskInProgress(category: TFC) {\n    return !!this.inProgress.get(category);\n  }\n\n  // eslint-disable-next-line complexity\n  private async scheduleTask({\n    category,\n    error,\n    changeState,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    failedRetryCount = 0,\n  }: ScheduleTaskParams & { failedRetryCount?: number }): Promise<void> {\n    HMSLogger.d(this.TAG, 'schedule: ', { category: TFC[category], error });\n\n    // First schedule call\n    if (failedRetryCount === 0) {\n      const inProgressTask = this.inProgress.get(category);\n      if (inProgressTask) {\n        HMSLogger.d(this.TAG, `schedule: Already a task for ${TFC[category]} scheduled, waiting for its completion`);\n        await inProgressTask.promise;\n        return;\n      }\n\n      const taskPromise = new PromiseWithCallbacks<number>((_, __) => {});\n      this.inProgress.set(category, taskPromise);\n\n      this.sendEvent(error, category);\n    }\n\n    let hasFailedDependency = false;\n    const dependencies = TFCDependencies[category];\n\n    for (const dependencyIndexString in dependencies) {\n      const dependency = dependencies[parseInt(dependencyIndexString)];\n      try {\n        const dependencyTask = this.inProgress.get(dependency);\n        if (dependencyTask) {\n          HMSLogger.d(\n            this.TAG,\n            `schedule: Suspending retry task of ${TFC[category]}, waiting for ${TFC[dependency]} to recover`,\n          );\n          await dependencyTask.promise;\n          HMSLogger.d(\n            this.TAG,\n            `schedule: Resuming retry task ${TFC[category]} as it's dependency ${TFC[dependency]} is recovered`,\n          );\n        }\n      } catch (ex) {\n        HMSLogger.d(\n          this.TAG,\n          `schedule: Stopping retry task of ${TFC[category]} as it's dependency ${TFC[dependency]} failed to recover`,\n        );\n        hasFailedDependency = true;\n        break;\n      }\n    }\n\n    if (failedRetryCount >= maxFailedRetries || hasFailedDependency) {\n      error.description += `. [${TFC[category]}] Could not recover after ${failedRetryCount} tries`;\n\n      if (hasFailedDependency) {\n        error.description += ` Could not recover all of it's required dependencies - [${(dependencies as Array<TFC>)\n          .map(dep => TFC[dep])\n          .toString()}]`;\n      }\n      error.isTerminal = true;\n\n      // @NOTE: Don't reject to throw error for dependencies, use onStateChange\n      // const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      // taskPromise?.reject(error);\n      this.sendEvent(error, category);\n\n      this.reset();\n\n      if (changeState) {\n        this.onStateChange(TransportState.Failed, error);\n      } else {\n        throw error;\n      }\n\n      return;\n    }\n\n    if (changeState) {\n      this.onStateChange(TransportState.Reconnecting, error);\n    }\n\n    const delay = this.getDelayForRetryCount(category, failedRetryCount);\n\n    HMSLogger.d(\n      this.TAG,\n      `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Scheduling retry task in ${delay}ms`,\n    );\n\n    let taskSucceeded: boolean;\n    try {\n      taskSucceeded = await this.setTimeoutPromise(task, delay);\n    } catch (ex) {\n      taskSucceeded = false;\n      HMSLogger.w(\n        this.TAG,\n        `[${TFC[category]}] Un-caught exception ${(ex as HMSException).name} in retry-task, initiating retry`,\n        ex,\n      );\n    }\n\n    if (taskSucceeded) {\n      const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      taskPromise?.resolve(failedRetryCount);\n\n      if (changeState && this.inProgress.size === 0) {\n        this.onStateChange(originalState);\n      }\n      HMSLogger.d(this.TAG, `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Recovered \u267B\uFE0F`);\n    } else {\n      await this.scheduleTask({\n        category,\n        error,\n        changeState,\n        task,\n        originalState,\n        maxFailedRetries,\n        failedRetryCount: failedRetryCount + 1,\n      });\n    }\n  }\n\n  private getBaseDelayForTask(category: TFC, n: number) {\n    if (category === TFC.JoinWSMessageFailed) {\n      // linear backoff(2 + jitter for every retry)\n      return 2;\n    }\n    // exponential backoff\n    return Math.pow(2, n);\n  }\n\n  private getDelayForRetryCount(category: TFC, n: number) {\n    const delay = this.getBaseDelayForTask(category, n);\n    const jitter = category === TFC.JoinWSMessageFailed ? Math.random() * 2 : Math.random();\n    return Math.round(Math.min(delay + jitter, MAX_TRANSPORT_RETRY_DELAY) * 1000);\n  }\n\n  private async setTimeoutPromise<T>(task: () => Promise<T>, delay: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = window.setTimeout(async () => {\n        try {\n          const value: T = await task();\n          value && this.retryTaskIds.splice(this.retryTaskIds.indexOf(timeoutId), 1);\n          resolve(value);\n        } catch (error) {\n          reject(error);\n        }\n      }, delay);\n\n      this.retryTaskIds.push(timeoutId);\n    });\n  }\n}\n", "import { BaseSample, PublishAnalyticPayload, TrackAnalytics, VideoSample } from './interfaces';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSTrackStats } from '../../interfaces';\nimport { HMSLocalTrack } from '../../media/tracks';\nimport { HMSWebrtcStats } from '../../rtc-stats';\nimport { IStore } from '../../sdk/store';\nimport { PUBLISH_STATS_PUSH_INTERVAL, PUBLISH_STATS_SAMPLE_WINDOW } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { sleep } from '../../utils/timer-utils';\nimport AnalyticsEventFactory from '../AnalyticsEventFactory';\n\nexport class PublishStatsAnalytics {\n  private shouldSendEvent = false;\n  private sequenceNum = 1;\n  private trackAnalytics: Map<string, RunningTrackAnalytics> = new Map();\n\n  constructor(\n    private store: IStore,\n    private eventBus: EventBus,\n    private readonly sampleWindowSize = PUBLISH_STATS_SAMPLE_WINDOW,\n    private readonly pushInterval = PUBLISH_STATS_PUSH_INTERVAL,\n  ) {\n    this.start();\n  }\n\n  start() {\n    if (this.shouldSendEvent) {\n      return;\n    }\n    this.stop();\n    this.shouldSendEvent = true;\n    this.eventBus.statsUpdate.subscribe(this.handleStatsUpdate);\n    this.startLoop().catch(e => HMSLogger.e('[PublishStatsAnalytics]', e.message));\n  }\n\n  stop = () => {\n    if (this.shouldSendEvent) {\n      this.sendEvent();\n    }\n    this.eventBus.statsUpdate.unsubscribe(this.handleStatsUpdate);\n    this.shouldSendEvent = false;\n  };\n\n  private async startLoop() {\n    while (this.shouldSendEvent) {\n      await sleep(this.pushInterval * 1000);\n      this.sendEvent();\n    }\n  }\n\n  private toAnalytics(): PublishAnalyticPayload {\n    const audio: TrackAnalytics[] = [];\n    const video: TrackAnalytics[] = [];\n    this.trackAnalytics.forEach(trackAnalytic => {\n      if (trackAnalytic.track.type === 'audio') {\n        audio.push(trackAnalytic.toAnalytics());\n      } else if (trackAnalytic.track.type === 'video') {\n        video.push(trackAnalytic.toAnalytics());\n      }\n    });\n    return {\n      audio,\n      video,\n      joined_at: this.store.getRoom()?.joinedAt?.getTime()!,\n      sequence_num: this.sequenceNum++,\n      max_window_sec: PUBLISH_STATS_SAMPLE_WINDOW,\n    };\n  }\n\n  private sendEvent = () => {\n    this.eventBus.analytics.publish(AnalyticsEventFactory.publishStats(this.toAnalytics()));\n  };\n\n  private handleStatsUpdate = (hmsStats: HMSWebrtcStats) => {\n    const localTracksStats = hmsStats.getLocalTrackStats();\n    Object.keys(localTracksStats).forEach(trackIDBeingSent => {\n      const trackStats = localTracksStats[trackIDBeingSent];\n      const track = this.store.getLocalPeerTracks().find(track => track.getTrackIDBeingSent() === trackIDBeingSent);\n      Object.keys(trackStats).forEach(statId => {\n        const layerStats = trackStats[statId];\n        const identifier = track && this.getTrackIdentifier(track?.trackId, layerStats);\n        if (identifier && this.trackAnalytics.has(identifier)) {\n          this.trackAnalytics.get(identifier)?.push({\n            ...layerStats,\n            availableOutgoingBitrate: hmsStats.getLocalPeerStats()?.publish?.availableOutgoingBitrate,\n          });\n        } else {\n          if (track) {\n            const trackAnalytics = new RunningTrackAnalytics({\n              track,\n              sampleWindowSize: this.sampleWindowSize,\n              rid: layerStats.rid,\n              ssrc: layerStats.ssrc.toString(),\n              kind: layerStats.kind,\n            });\n            trackAnalytics.push({\n              ...layerStats,\n              availableOutgoingBitrate: hmsStats.getLocalPeerStats()?.publish?.availableOutgoingBitrate,\n            });\n            this.trackAnalytics.set(this.getTrackIdentifier(track?.trackId, layerStats), trackAnalytics);\n          }\n        }\n      });\n    });\n  };\n\n  private getTrackIdentifier(trackId: string, stats: HMSTrackStats) {\n    return stats.rid ? `${trackId}:${stats.rid}` : trackId;\n  }\n}\n\ntype TempPublishStats = HMSTrackStats & { availableOutgoingBitrate?: number };\n\nclass RunningTrackAnalytics {\n  readonly sampleWindowSize: number;\n  track: HMSLocalTrack;\n  track_id: string;\n  source: string;\n  ssrc: string;\n  kind: string;\n  rid?: string;\n  samples: BaseSample[] = [];\n\n  private tempStats: TempPublishStats[] = [];\n\n  constructor({\n    track,\n    ssrc,\n    rid,\n    kind,\n    sampleWindowSize,\n  }: {\n    track: HMSLocalTrack;\n    ssrc: string;\n    kind: string;\n    rid?: string;\n    sampleWindowSize: number;\n  }) {\n    this.track = track;\n    this.ssrc = ssrc;\n    this.rid = rid;\n    this.kind = kind;\n    this.track_id = this.track.trackId;\n    this.source = this.track.source!;\n    this.sampleWindowSize = sampleWindowSize;\n  }\n\n  push(stat: TempPublishStats) {\n    this.tempStats.push(stat);\n\n    if (this.shouldCreateSample()) {\n      this.samples.push(this.createSample());\n      this.tempStats.length = 0;\n    }\n  }\n\n  toAnalytics(): TrackAnalytics {\n    return {\n      track_id: this.track_id,\n      ssrc: this.ssrc,\n      source: this.source,\n      rid: this.rid,\n      samples: this.samples,\n    };\n  }\n\n  private createSample(): BaseSample | VideoSample {\n    const latestStat = this.getLatestStat();\n\n    const qualityLimitationDurations = latestStat.qualityLimitationDurations;\n    const total_quality_limitation = qualityLimitationDurations && {\n      bandwidth_sec: qualityLimitationDurations.bandwidth,\n      cpu_sec: qualityLimitationDurations.cpu,\n      other_sec: qualityLimitationDurations.other,\n    };\n\n    const resolution = latestStat.frameHeight\n      ? {\n          height_px: this.getLatestStat().frameHeight,\n          width_px: this.getLatestStat().frameWidth,\n        }\n      : undefined;\n    const avg_jitter = this.calculateAverage('jitter', false);\n    const avg_jitter_ms = avg_jitter ? Math.round(avg_jitter * 1000) : undefined;\n\n    const avg_round_trip_time = this.calculateAverage('roundTripTime', false);\n    const avg_round_trip_time_ms = avg_round_trip_time ? Math.round(avg_round_trip_time * 1000) : undefined;\n\n    return removeUndefinedFromObject({\n      timestamp: Date.now(),\n      avg_available_outgoing_bitrate_bps: this.calculateAverage('availableOutgoingBitrate'),\n      avg_bitrate_bps: this.calculateAverage('bitrate'),\n      avg_fps: this.calculateAverage('framesPerSecond'),\n      total_packets_lost: this.calculateDifferenceForSample('packetsLost'),\n      total_packets_sent: this.calculateDifferenceForSample('packetsSent'),\n      total_packet_sent_delay_sec: parseFloat(this.calculateDifferenceForSample('totalPacketSendDelay').toFixed(4)),\n      total_fir_count: this.calculateDifferenceForSample('firCount'),\n      total_pli_count: this.calculateDifferenceForSample('pliCount'),\n      total_nack_count: this.calculateDifferenceForSample('nackCount'),\n      avg_jitter_ms,\n      avg_round_trip_time_ms,\n      total_quality_limitation,\n      resolution,\n    });\n  }\n\n  private getLatestStat() {\n    return this.tempStats[this.tempStats.length - 1];\n  }\n\n  private shouldCreateSample() {\n    const length = this.tempStats.length;\n    const newStat = this.tempStats[length - 1];\n    const prevStat = this.tempStats[length - 2];\n\n    return (\n      length === PUBLISH_STATS_SAMPLE_WINDOW ||\n      hasEnabledStateChanged(newStat, prevStat) ||\n      (newStat.kind === 'video' && hasResolutionChanged(newStat, prevStat))\n    );\n  }\n\n  private calculateSum(key: keyof TempPublishStats) {\n    const checkStat = this.getLatestStat()[key];\n    if (typeof checkStat !== 'number') {\n      return;\n    }\n    return this.tempStats.reduce((partialSum, stat) => {\n      return partialSum + ((stat[key] || 0) as number);\n    }, 0);\n  }\n\n  private calculateAverage(key: keyof TempPublishStats, round = true) {\n    const sum = this.calculateSum(key);\n    const avg = sum !== undefined ? sum / this.tempStats.length : undefined;\n    return avg ? (round ? Math.round(avg) : avg) : undefined;\n  }\n\n  private calculateDifferenceForSample(key: keyof TempPublishStats) {\n    const firstValue = Number(this.tempStats[0][key]) || 0;\n    const latestValue = Number(this.getLatestStat()[key]) || 0;\n\n    return latestValue - firstValue;\n  }\n}\n\nconst hasResolutionChanged = (newStat: TempPublishStats, prevStat: TempPublishStats) =>\n  newStat && prevStat && (newStat.frameWidth !== prevStat.frameWidth || newStat.frameHeight !== prevStat.frameHeight);\n\nconst hasEnabledStateChanged = (newStat: TempPublishStats, prevStat: TempPublishStats) =>\n  newStat && prevStat && newStat.enabled !== prevStat.enabled;\n\nconst removeUndefinedFromObject = <T extends Record<string, any>>(data: T) => {\n  return Object.entries(data)\n    .filter(([, value]) => value !== undefined)\n    .reduce((obj, [key, value]) => {\n      obj[key as keyof T] = value;\n      return obj;\n    }, {} as T);\n};\n", "import { ANALYTICS_BUFFER_SIZE } from '../../utils/constants';\nimport { LocalStorage } from '../../utils/local-storage';\nimport { Queue } from '../../utils/queue';\nimport AnalyticsEvent from '../AnalyticsEvent';\n\nexport class LocalStorageEvents extends Queue<AnalyticsEvent> {\n  private localStorage = new LocalStorage<AnalyticsEvent[]>('hms-analytics');\n\n  constructor() {\n    super(ANALYTICS_BUFFER_SIZE);\n    // @TODO: Currently we don't send failed events of old sessions. So reset localstorage for every session.\n    // Once support for failed events from old sessions is added, remove clear and init queue from localstorage.\n    this.localStorage.clear();\n    this.initLocalStorageQueue();\n  }\n\n  enqueue(event: AnalyticsEvent) {\n    super.enqueue(event);\n    this.localStorage.set(this.storage);\n  }\n\n  dequeue() {\n    const removedEvent = super.dequeue();\n    this.localStorage.set(this.storage);\n    return removedEvent;\n  }\n\n  private initLocalStorageQueue() {\n    this.localStorage.get()?.forEach(event => {\n      const eventInstance = new AnalyticsEvent(event);\n      super.enqueue(eventInstance);\n    });\n  }\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\nimport HMSLogger from '../utils/logger';\nimport { Queue } from '../utils/queue';\n\nexport abstract class AnalyticsTransport {\n  abstract transportProvider: IAnalyticsTransportProvider;\n  abstract failedEvents: Queue<AnalyticsEvent>;\n  private readonly TAG = '[AnalyticsTransport]';\n\n  sendEvent(event: AnalyticsEvent) {\n    try {\n      this.sendSingleEvent(event);\n      this.flushFailedEvents();\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'sendEvent failed', error);\n    }\n  }\n\n  flushFailedEvents(currentPeerId?: string) {\n    try {\n      HMSLogger.d(this.TAG, 'Flushing failed events', this.failedEvents);\n      while (this.failedEvents.size() > 0) {\n        const event = this.failedEvents.dequeue();\n        if (event) {\n          const isEventFromCurrentPeer = event.metadata?.peer.peer_id === currentPeerId;\n          if (isEventFromCurrentPeer || !event.metadata.peer.peer_id) {\n            this.sendSingleEvent(event);\n          } else {\n            HTTPAnalyticsTransport.sendEvent(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'flushFailedEvents failed', error);\n    }\n  }\n\n  private sendSingleEvent(event: AnalyticsEvent) {\n    try {\n      this.transportProvider.sendEvent(event);\n      HMSLogger.d(this.TAG, 'Sent event', event.name, event);\n    } catch (error) {\n      HMSLogger.w(this.TAG, `${this.transportProvider.TAG}.sendEvent failed, adding to local storage events`, {\n        event,\n        error,\n      });\n      this.failedEvents.enqueue(event);\n      throw error;\n    }\n  }\n}\n", "import { LocalStorageEvents } from './LocalStoageEvents';\nimport { ISignal } from '../../signal/ISignal';\nimport { AnalyticsTransport } from '../AnalyticsTransport';\n\nexport class SignalAnalyticsTransport extends AnalyticsTransport {\n  failedEvents = new LocalStorageEvents();\n\n  constructor(public transportProvider: ISignal) {\n    super();\n  }\n}\n", "// Sent in trickle messages as target - biz understands only 0 and 1\nexport enum HMSConnectionRole {\n  Publish = 0,\n  Subscribe = 1,\n}\n\nexport interface HMSTrickle {\n  candidate: RTCIceCandidateInit;\n  target: HMSConnectionRole;\n}\n", "import * as sdpTransform from 'sdp-transform';\nimport { isPresent } from './validations';\nimport { TrackState } from '../notification-manager';\n\n/**\n * @DISCUSS: Should we have a wrapper over RTCSessionDescriptionInit(SDP) and have these methods in it?\n */\n\nexport function fixMsid(desc: RTCSessionDescriptionInit, tracks?: Map<string, TrackState>): RTCSessionDescriptionInit {\n  const parsedSdp = sdpTransform.parse(desc.sdp!);\n\n  if (!parsedSdp.origin?.username.startsWith('mozilla')) {\n    // This isn't firefox, so we return the original offer without doing anything\n    return desc;\n  }\n\n  const mediaTracks = tracks ? Array.from(tracks.values()) : [];\n\n  parsedSdp.media.forEach(m => {\n    const streamId = m.msid?.split(' ')[0];\n    // check for both type and streamid as both video and screenshare have same type but different stream_id\n    const trackId = mediaTracks.find(val => val.type === m.type && val.stream_id === streamId)?.track_id;\n    if (trackId) {\n      m.msid = m.msid?.replace(/\\s(.+)/, ` ${trackId}`);\n    }\n  });\n\n  return { type: desc.type, sdp: sdpTransform.write(parsedSdp) };\n}\n\n/**\n * Get the track ID from the SDP using the transceiver's mid from RTCTrackEvent\n * @TODO: This could take more processing time in a large room and when the SDP is big.\n * Consider using this for Firefox only?\n */\nexport function getSdpTrackIdForMid(\n  desc?: RTCSessionDescriptionInit | null,\n  mid?: RTCRtpTransceiver['mid'],\n): string | undefined {\n  if (!desc?.sdp || !mid) {\n    return undefined;\n  }\n  const parsedSdp = sdpTransform.parse(desc.sdp);\n  const trackSection = parsedSdp.media.find(media => isPresent(media.mid) && parseInt(media.mid!) === parseInt(mid));\n  const trackId = trackSection?.msid?.split(' ')[1];\n  return trackId;\n}\n\nexport function enableOpusDtx(desc: RTCSessionDescriptionInit): RTCSessionDescriptionInit {\n  if (desc.sdp!.includes('usedtx=1')) {\n    return desc;\n  }\n\n  return { type: desc.type, sdp: desc.sdp!.replace('useinbandfec=1', 'useinbandfec=1;usedtx=1') };\n}\n", "import { HMSConnectionRole } from './model';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { HMSLocalTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { TrackState } from '../notification-manager';\nimport { ISignal } from '../signal/ISignal';\nimport HMSLogger from '../utils/logger';\nimport { enableOpusDtx, fixMsid } from '../utils/session-description';\n\nconst TAG = '[HMSConnection]';\ninterface RTCIceCandidatePair {\n  local: RTCIceCandidate;\n  remote: RTCIceCandidate;\n}\n\nexport default abstract class HMSConnection {\n  readonly role: HMSConnectionRole;\n  protected readonly signal: ISignal;\n\n  abstract readonly nativeConnection: RTCPeerConnection;\n  /**\n   * We keep a list of pending IceCandidates received\n   * from the signalling server. When the peer-connection\n   * is initialized we call [addIceCandidate] for each.\n   *\n   * WARN:\n   *  - [HMSPublishConnection] keeps the complete list of candidates (for\n   *      ice-connection failed/disconnect) forever.\n   *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]\n   */\n  readonly candidates = new Array<RTCIceCandidateInit>();\n\n  selectedCandidatePair?: RTCIceCandidatePair;\n\n  protected constructor(role: HMSConnectionRole, signal: ISignal) {\n    this.role = role;\n    this.signal = signal;\n  }\n\n  public get iceConnectionState(): RTCIceConnectionState {\n    return this.nativeConnection.iceConnectionState;\n  }\n\n  public get connectionState(): RTCPeerConnectionState {\n    return this.nativeConnection.connectionState;\n  }\n\n  private get action() {\n    return this.role === HMSConnectionRole.Publish ? HMSAction.PUBLISH : HMSAction.SUBSCRIBE;\n  }\n\n  addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver {\n    return this.nativeConnection.addTransceiver(track, init);\n  }\n\n  async createOffer(tracks?: Map<string, TrackState>, options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit> {\n    try {\n      const offer = await this.nativeConnection.createOffer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createOffer offer=${JSON.stringify(offer, null, 1)}`);\n      return enableOpusDtx(fixMsid(offer, tracks));\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateOfferFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async createAnswer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    try {\n      const answer = await this.nativeConnection.createAnswer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createAnswer answer=${JSON.stringify(answer, null, 1)}`);\n      return answer;\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateAnswerFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setLocalDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setLocalDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setLocalDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetLocalDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setRemoteDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setRemoteDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetRemoteDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    if (this.nativeConnection.signalingState === 'closed') {\n      HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate signalling state closed`);\n      return;\n    }\n    HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate candidate=${JSON.stringify(candidate, null, 1)}`);\n    await this.nativeConnection.addIceCandidate(candidate);\n  }\n\n  public get remoteDescription(): RTCSessionDescription | null {\n    return this.nativeConnection.remoteDescription;\n  }\n\n  getSenders(): Array<RTCRtpSender> {\n    return this.nativeConnection.getSenders();\n  }\n\n  logSelectedIceCandidatePairs() {\n    /**\n     * for the very first peer in the room we don't have any subscribe ice candidates\n     * because the peer hasn't subscribed to anything.\n     *\n     * For all peers joining after this peer, we have published and subscribed at the time of join itself\n     * so we're able to log both publish and subscribe ice candidates.\n     * Added try catch for the whole section as the getSenders and getReceivers is throwing errors in load test\n     */\n    try {\n      const transmitters = this.role === HMSConnectionRole.Publish ? this.getSenders() : this.getReceivers();\n\n      transmitters.forEach(transmitter => {\n        const kindOfTrack = transmitter.track?.kind;\n        if (transmitter.transport) {\n          const iceTransport = transmitter.transport.iceTransport;\n\n          const logSelectedCandidate = () => {\n            // @ts-expect-error\n            if (typeof iceTransport.getSelectedCandidatePair === 'function') {\n              // @ts-expect-error\n              this.selectedCandidatePair = iceTransport.getSelectedCandidatePair();\n              HMSLogger.d(\n                TAG,\n                `${HMSConnectionRole[this.role]} connection`,\n                `selected ${kindOfTrack || 'unknown'} candidate pair`,\n                JSON.stringify(this.selectedCandidatePair, null, 2),\n              );\n            }\n          };\n\n          // @ts-expect-error\n          if (typeof iceTransport.onselectedcandidatepairchange === 'function') {\n            // @ts-expect-error\n            iceTransport.onselectedcandidatepairchange = logSelectedCandidate;\n          }\n          logSelectedCandidate();\n        }\n      });\n    } catch (error) {\n      HMSLogger.w(\n        TAG,\n        `Error in logging selected ice candidate pair for ${HMSConnectionRole[this.role]} connection`,\n        error,\n      );\n    }\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (this.nativeConnection.signalingState !== 'closed') {\n      this.nativeConnection.removeTrack(sender);\n    }\n  }\n\n  async setMaxBitrateAndFramerate(track: HMSLocalTrack) {\n    const maxBitrate = track.settings.maxBitrate;\n    const maxFramerate = track instanceof HMSLocalVideoTrack && track.settings.maxFramerate;\n    const sender = this.getSenders().find(s => s?.track?.id === track.getTrackIDBeingSent());\n\n    if (sender) {\n      const params = sender.getParameters();\n      // modify only for non-simulcast encodings\n      if (params.encodings.length === 1) {\n        if (maxBitrate) {\n          params.encodings[0].maxBitrate = maxBitrate * 1000;\n        }\n        if (maxFramerate) {\n          // @ts-ignore\n          params.encodings[0].maxFramerate = maxFramerate;\n        }\n      }\n      await sender.setParameters(params);\n    } else {\n      HMSLogger.w(\n        TAG,\n        `no sender found to setMaxBitrate for track - ${track.trackId}, sentTrackId - ${track.getTrackIDBeingSent()}`,\n      );\n    }\n  }\n\n  async getStats() {\n    return await this.nativeConnection.getStats();\n  }\n\n  async close() {\n    this.nativeConnection.close();\n  }\n\n  private getReceivers() {\n    return this.nativeConnection.getReceivers();\n  }\n}\n", "import { IPublishConnectionObserver } from './IPublishConnectionObserver';\nimport { ISignal } from '../../signal/ISignal';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSConnection from '../HMSConnection';\nimport { HMSConnectionRole } from '../model';\n\nexport default class HMSPublishConnection extends HMSConnection {\n  private readonly TAG = '[HMSPublishConnection]';\n  private readonly observer: IPublishConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n\n  constructor(signal: ISignal, config: RTCConfiguration, observer: IPublishConnectionObserver) {\n    super(HMSConnectionRole.Publish, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {\n      protocol: 'SCTP',\n    });\n\n    this.nativeConnection.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        signal.trickle(this.role, candidate);\n      }\n    };\n\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n  }\n\n  initAfterJoin() {\n    this.nativeConnection.onnegotiationneeded = async () => {\n      HMSLogger.d(this.TAG, `onnegotiationneeded`);\n      await this.observer.onRenegotiationNeeded();\n    };\n  }\n}\n", "import EventEmitter from 'eventemitter2';\nimport { v4 as uuid } from 'uuid';\nimport ISubscribeConnectionObserver from './ISubscribeConnectionObserver';\nimport { HMSRemoteStream, HMSSimulcastLayer } from '../../internal';\nimport { HMSRemoteAudioTrack } from '../../media/tracks/HMSRemoteAudioTrack';\nimport { HMSRemoteVideoTrack } from '../../media/tracks/HMSRemoteVideoTrack';\nimport { InitFlags } from '../../signal/init/models';\nimport { ISignal } from '../../signal/ISignal';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { getSdpTrackIdForMid } from '../../utils/session-description';\nimport { sleep } from '../../utils/timer-utils';\nimport { PreferAudioLayerParams, PreferLayerResponse, PreferVideoLayerParams } from '../channel-messages';\nimport HMSConnection from '../HMSConnection';\nimport HMSDataChannel from '../HMSDataChannel';\nimport { HMSConnectionRole } from '../model';\n\nexport default class HMSSubscribeConnection extends HMSConnection {\n  private readonly TAG = '[HMSSubscribeConnection]';\n  private readonly remoteStreams = new Map<string, HMSRemoteStream>();\n  private readonly observer: ISubscribeConnectionObserver;\n  private readonly MAX_RETRIES = 3;\n\n  readonly nativeConnection: RTCPeerConnection;\n\n  private pendingMessageQueue: string[] = [];\n\n  private apiChannel?: HMSDataChannel;\n  private eventEmitter = new EventEmitter({ maxListeners: 60 });\n\n  private initNativeConnectionCallbacks() {\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n\n    this.nativeConnection.ondatachannel = e => {\n      if (e.channel.label !== API_DATA_CHANNEL) {\n        // TODO: this.observer.onDataChannel(e.channel);\n        return;\n      }\n\n      this.apiChannel = new HMSDataChannel(\n        e.channel,\n        {\n          onMessage: (value: string) => {\n            this.eventEmitter.emit('message', value);\n            this.observer.onApiChannelMessage(value);\n          },\n        },\n        `role=${this.role}`,\n      );\n\n      e.channel.onopen = this.handlePendingApiMessages;\n    };\n\n    this.nativeConnection.onicecandidate = e => {\n      if (e.candidate !== null) {\n        this.signal.trickle(this.role, e.candidate);\n      }\n    };\n\n    this.nativeConnection.ontrack = e => {\n      const stream = e.streams[0];\n      const streamId = stream.id;\n\n      if (!this.remoteStreams.has(streamId)) {\n        const remote = new HMSRemoteStream(stream, this);\n        this.remoteStreams.set(streamId, remote);\n      }\n\n      stream.addEventListener('removetrack', (ev: MediaStreamTrackEvent) => {\n        if (ev.track.id !== e.track.id) {\n          return;\n        }\n        /*\n         * this match has to be with nativetrack.id instead of track.trackId as the latter refers to sdp track id for\n         * ease of correlating update messages coming from the backend. The two track ids are usually the same, but\n         * can be different for some browsers. checkout sdptrackid field in HMSTrack for more details.\n         */\n        const toRemoveTrackIdx = remote.tracks.findIndex(\n          track => track.nativeTrack.id === ev.track.id && e.transceiver.mid === track.transceiver?.mid,\n        );\n        if (toRemoveTrackIdx >= 0) {\n          const toRemoveTrack = remote.tracks[toRemoveTrackIdx];\n          this.observer.onTrackRemove(toRemoveTrack);\n          remote.tracks.splice(toRemoveTrackIdx, 1);\n          // If the length becomes 0 we assume that stream is removed entirely\n          if (remote.tracks.length === 0) {\n            this.remoteStreams.delete(streamId);\n          }\n        }\n      });\n\n      const remote = this.remoteStreams.get(streamId)!;\n      const TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;\n      const track = new TrackCls(remote, e.track);\n      // reset the simulcast layer to none when new video tracks are added, UI will subscribe when required\n      if (e.track.kind === 'video') {\n        remote.setVideoLayerLocally(HMSSimulcastLayer.NONE, 'addTrack', 'subscribeConnection');\n      }\n      track.transceiver = e.transceiver;\n      const trackId = getSdpTrackIdForMid(this.remoteDescription, e.transceiver?.mid);\n      trackId && track.setSdpTrackId(trackId);\n      remote.tracks.push(track);\n      this.observer.onTrackAdd(track);\n    };\n  }\n\n  constructor(\n    signal: ISignal,\n    config: RTCConfiguration,\n    private isFlagEnabled: (flag: InitFlags) => boolean,\n    observer: ISubscribeConnectionObserver,\n  ) {\n    super(HMSConnectionRole.Subscribe, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.initNativeConnectionCallbacks();\n  }\n\n  sendOverApiDataChannel(message: string) {\n    if (this.apiChannel && this.apiChannel.readyState === 'open') {\n      this.apiChannel.send(message);\n    } else {\n      HMSLogger.w(this.TAG, `API Data channel not ${this.apiChannel ? 'open' : 'present'}, queueing`, message);\n      this.pendingMessageQueue.push(message);\n    }\n  }\n\n  async sendOverApiDataChannelWithResponse<T extends PreferAudioLayerParams | PreferVideoLayerParams>(\n    message: T,\n    requestId?: string,\n  ): Promise<PreferLayerResponse> {\n    const id = uuid();\n    if (message.method === 'prefer-video-track-state') {\n      const disableAutoUnsubscribe = this.isFlagEnabled(InitFlags.FLAG_DISABLE_VIDEO_TRACK_AUTO_UNSUBSCRIBE);\n      if (disableAutoUnsubscribe && message.params.max_spatial_layer === HMSSimulcastLayer.NONE) {\n        HMSLogger.d(this.TAG, 'video auto unsubscribe is disabled, request is ignored');\n        return { id } as PreferLayerResponse;\n      }\n    }\n    const request = JSON.stringify({\n      id: requestId || id,\n      jsonrpc: '2.0',\n      ...message,\n    });\n    return this.sendMessage(request, id);\n  }\n\n  async close() {\n    await super.close();\n    this.apiChannel?.close();\n  }\n\n  private handlePendingApiMessages = () => {\n    this.eventEmitter.emit('open', true);\n    if (this.pendingMessageQueue.length > 0) {\n      HMSLogger.d(this.TAG, 'Found pending message queue, sending messages');\n      this.pendingMessageQueue.forEach(msg => this.sendOverApiDataChannel(msg));\n      this.pendingMessageQueue.length = 0;\n    }\n  };\n\n  // eslint-disable-next-line complexity\n  private sendMessage = async (request: string, requestId: string): Promise<PreferLayerResponse> => {\n    if (this.apiChannel?.readyState !== 'open') {\n      await this.eventEmitter.waitFor('open');\n    }\n    let response: PreferLayerResponse;\n    for (let i = 0; i < this.MAX_RETRIES; i++) {\n      this.apiChannel!.send(request);\n      response = await this.waitForResponse(requestId);\n      const error = response.error;\n      if (error) {\n        // Don't retry or do anything, track is already removed\n        if (error.code === 404) {\n          HMSLogger.d(this.TAG, `Track not found ${requestId}`, { request, try: i + 1, error });\n          break;\n        }\n        HMSLogger.d(this.TAG, `Failed sending ${requestId}`, { request, try: i + 1, error });\n        const shouldRetry = error.code / 100 === 5 || error.code === 429;\n        if (!shouldRetry) {\n          throw Error(`code=${error.code}, message=${error.message}`);\n        }\n        const delay = (2 + Math.random() * 2) * 1000;\n        await sleep(delay);\n      } else {\n        break;\n      }\n    }\n    return response!;\n  };\n\n  private waitForResponse = async (requestId: string): Promise<PreferLayerResponse> => {\n    const res = await this.eventEmitter.waitFor('message', function (value) {\n      return value.includes(requestId);\n    });\n    const response = JSON.parse(res[0] as string);\n    HMSLogger.d(this.TAG, `response for ${requestId} -`, JSON.stringify(response, null, 2));\n    return response;\n  };\n}\n", "import HMSLogger from '../utils/logger';\n\nexport interface DataChannelObserver {\n  onMessage(value: string): void;\n}\n\nexport default class HMSDataChannel {\n  private readonly TAG = '[HMSDataChannel]';\n  private readonly nativeChannel: RTCDataChannel;\n  private readonly observer: DataChannelObserver;\n  private readonly metadata: string;\n\n  public get id() {\n    return this.nativeChannel.id;\n  }\n\n  public get label() {\n    return this.nativeChannel.label;\n  }\n\n  public get readyState() {\n    return this.nativeChannel.readyState;\n  }\n\n  constructor(nativeChannel: RTCDataChannel, observer: DataChannelObserver, metadata = '') {\n    this.nativeChannel = nativeChannel;\n    this.observer = observer;\n    this.metadata = metadata;\n\n    nativeChannel.onmessage = e => {\n      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);\n      this.observer.onMessage(e.data);\n    };\n  }\n\n  send(message: string) {\n    HMSLogger.d(this.TAG, `[${this.metadata}] Sending [size=${message.length}] message=${message}`);\n    this.nativeChannel.send(message);\n  }\n\n  close() {\n    this.nativeChannel.close();\n  }\n}\n", "import { InitConfig } from './models';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport HMSLogger from '../../utils/logger';\n\nconst TAG = '[InitService]';\nexport default class InitService {\n  private static handleError(response: Response, body: { code: number; message: string }) {\n    switch (response.status) {\n      case 404:\n        throw ErrorFactory.APIErrors.EndpointUnreachable(HMSAction.INIT, body.message || response.statusText);\n      case 200:\n        break;\n      default:\n        throw ErrorFactory.APIErrors.ServerErrors(\n          body.code || response.status,\n          HMSAction.INIT,\n          body.message || response?.statusText,\n        );\n    }\n  }\n\n  static async fetchInitConfig({\n    token,\n    peerId,\n    userAgent,\n    initEndpoint = 'https://prod-init.100ms.live',\n    region = '',\n  }: {\n    token: string;\n    peerId: string;\n    userAgent: string;\n    initEndpoint?: string;\n    region?: string;\n  }): Promise<InitConfig> {\n    HMSLogger.d(TAG, `fetchInitConfig: initEndpoint=${initEndpoint} token=${token} peerId=${peerId} region=${region} `);\n    const url = getUrl(initEndpoint, peerId, userAgent, region);\n    try {\n      const response = await fetch(url, {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n      try {\n        const config = await response.clone().json();\n        this.handleError(response, config);\n        HMSLogger.d(TAG, `config is ${JSON.stringify(config, null, 2)}`);\n        return transformInitConfig(config);\n      } catch (err) {\n        const text = await response.text();\n        HMSLogger.e(TAG, 'json error', (err as Error).message, text);\n        throw ErrorFactory.APIErrors.ServerErrors(response.status, HMSAction.INIT, text);\n      }\n    } catch (err) {\n      const error = err as Error;\n      if (['Failed to fetch', 'NetworkError', 'ECONNRESET'].some(message => error.message.includes(message))) {\n        throw ErrorFactory.APIErrors.EndpointUnreachable(HMSAction.INIT, error.message);\n      }\n      throw error;\n    }\n  }\n}\n\nexport function getUrl(endpoint: string, peerId: string, userAgent: string, region?: string) {\n  try {\n    const url = new URL('/init', endpoint);\n\n    if (region && region.trim().length > 0) {\n      url.searchParams.set('region', region.trim());\n    }\n    url.searchParams.set('peer_id', peerId);\n    url.searchParams.set('user_agent_v2', userAgent);\n    return url.toString();\n  } catch (err) {\n    const error = err as Error;\n    HMSLogger.e(TAG, error.name, error.message);\n    throw error;\n  }\n}\n\nexport function transformInitConfig(config: any): InitConfig {\n  return {\n    ...config,\n    rtcConfiguration: { ...config.rtcConfiguration, iceServers: config.rtcConfiguration?.ice_servers },\n  };\n}\n", "import { v4 as uuid } from 'uuid';\nimport { convertSignalMethodtoErrorAction, HMSSignalMethod, JsonRpcRequest, JsonRpcResponse } from './models';\nimport AnalyticsEvent from '../../analytics/AnalyticsEvent';\nimport { HMSConnectionRole, HMSTrickle } from '../../connection/model';\nimport { ErrorFactory } from '../../error/ErrorFactory';\nimport { HMSAction } from '../../error/HMSAction';\nimport { HMSException } from '../../error/HMSException';\nimport Message from '../../sdk/models/HMSMessage';\nimport {\n  DEFAULT_SIGNAL_PING_INTERVAL,\n  DEFAULT_SIGNAL_PING_TIMEOUT,\n  PONG_RESPONSE_TIMES_SIZE,\n} from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { PromiseCallbacks } from '../../utils/promise';\nimport { Queue } from '../../utils/queue';\nimport { isPageHidden } from '../../utils/support';\nimport { sleep } from '../../utils/timer-utils';\nimport {\n  AcceptRoleChangeParams,\n  BroadcastResponse,\n  getPeerRequestParams,\n  GetSessionMetadataResponse,\n  HLSRequestParams,\n  HLSTimedMetadataParams,\n  JoinLeaveGroupResponse,\n  MultiTrackUpdateRequestParams,\n  PollInfoGetParams,\n  PollInfoGetResponse,\n  PollInfoSetParams,\n  PollInfoSetResponse,\n  PollListParams,\n  PollListResponse,\n  PollQuestionsGetParams,\n  PollQuestionsGetResponse,\n  PollQuestionsSetParams,\n  PollQuestionsSetResponse,\n  PollResponseSetParams,\n  PollResponseSetResponse,\n  PollResponsesGetParams,\n  PollResponsesGetResponse,\n  PollResultParams,\n  PollResultResponse,\n  PollStartParams,\n  PollStartResponse,\n  PollStopParams,\n  PollStopResponse,\n  RemovePeerRequest,\n  RequestForBulkRoleChangeParams,\n  RequestForRoleChangeParams,\n  SetSessionMetadataParams,\n  SetSessionMetadataResponse,\n  StartRTMPOrRecordingRequestParams,\n  Track,\n  TrackUpdateRequestParams,\n  UpdatePeerRequestParams,\n} from '../interfaces';\nimport { ISignal } from '../ISignal';\nimport { ISignalEventsObserver } from '../ISignalEventsObserver';\n\nexport default class JsonRpcSignal implements ISignal {\n  readonly TAG = '[SIGNAL]: ';\n  readonly observer: ISignalEventsObserver;\n  readonly pongResponseTimes = new Queue<number>(PONG_RESPONSE_TIMES_SIZE);\n\n  /**\n   * Sometimes before [join] is completed, there could be a lot of trickles\n   * Sending [HMSTrickle]` before [join] web socket message leads to\n   * error: [500] no rtc transport exists for this Peer\n   *\n   * We keep a list of pending trickles and send them immediately after [join]\n   * is done.\n   */\n  private isJoinCompleted = false;\n  private pendingTrickle: Array<HMSTrickle> = [];\n\n  private socket: WebSocket | null = null;\n\n  private callbacks = new Map<string, PromiseCallbacks<string, { method: HMSSignalMethod }>>();\n\n  private _isConnected = false;\n  private id = 0;\n\n  private onCloseHandler: (event: CloseEvent) => void = () => {};\n\n  public get isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  public setIsConnected(newValue: boolean, reason = '') {\n    HMSLogger.d(this.TAG, `isConnected set id: ${this.id}, oldValue: ${this._isConnected}, newValue: ${newValue}`);\n    if (this._isConnected === newValue) {\n      return;\n    }\n\n    if (this._isConnected && !newValue) {\n      // went offline\n      this._isConnected = newValue;\n      this.rejectPendingCalls(reason);\n      this.observer.onOffline(reason);\n    } else if (!this._isConnected && newValue) {\n      // went online\n      this._isConnected = newValue;\n      this.observer.onOnline();\n    }\n  }\n\n  constructor(observer: ISignalEventsObserver) {\n    this.observer = observer;\n    window.addEventListener('offline', this.offlineListener);\n    window.addEventListener('online', this.onlineListener);\n\n    this.onMessageHandler = this.onMessageHandler.bind(this);\n  }\n\n  getPongResponseTimes() {\n    return this.pongResponseTimes.toList();\n  }\n\n  private async internalCall<T>(method: string, params: any): Promise<T> {\n    const id = uuid();\n    const message = { method, params, id, jsonrpc: '2.0' } as JsonRpcRequest;\n\n    this.socket?.send(JSON.stringify(message));\n\n    try {\n      const response = await new Promise<any>((resolve, reject) => {\n        this.callbacks.set(id, { resolve, reject, metadata: { method: method as HMSSignalMethod } });\n      });\n\n      return response;\n    } catch (ex) {\n      if (ex instanceof HMSException) {\n        throw ex;\n      }\n\n      const error = ex as JsonRpcResponse['error'];\n      throw ErrorFactory.WebsocketMethodErrors.ServerErrors(\n        Number(error.code),\n        convertSignalMethodtoErrorAction(method as HMSSignalMethod),\n        error.message,\n      );\n    }\n  }\n\n  private notify(method: string, params: any) {\n    const message = { method, params };\n\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket?.send(JSON.stringify(message));\n    }\n  }\n\n  open(uri: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      let promiseSettled = false;\n      // cleanup\n      if (this.socket) {\n        this.socket.close();\n        this.socket.removeEventListener('close', this.onCloseHandler);\n        this.socket.removeEventListener('message', this.onMessageHandler);\n      }\n\n      this.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test\n\n      const errorListener = () => {\n        /**\n         * there was an error received from websocket leading to disconnection, this can happen either if server\n         * disconnects the websocket for some reason, there is a network disconnect or a firewall/antivirus on user's\n         * device is breaking the websocket connecting(which can happen even after a successful connect).\n         */\n        HMSLogger.e(this.TAG, 'Error from websocket');\n        promiseSettled = true;\n        // above error does not contain any description hence not sent here\n        reject(\n          ErrorFactory.WebSocketConnectionErrors.FailedToConnect(HMSAction.JOIN, `Error opening websocket connection`),\n        );\n      };\n\n      this.onCloseHandler = (event: CloseEvent) => {\n        HMSLogger.w(`Websocket closed code=${event.code}`);\n        if (promiseSettled) {\n          this.setIsConnected(false, `code: ${event.code}${event.code !== 1000 ? ', unexpected websocket close' : ''}`);\n        } else {\n          promiseSettled = true;\n          reject(\n            ErrorFactory.WebSocketConnectionErrors.AbnormalClose(\n              HMSAction.JOIN,\n              `Error opening websocket connection - websocket closed unexpectedly with code=${event.code}`,\n            ),\n          );\n        }\n      };\n\n      this.socket.addEventListener('error', errorListener);\n\n      const openHandler = () => {\n        promiseSettled = true;\n        resolve();\n        this.setIsConnected(true);\n        this.id++;\n        this.socket?.removeEventListener('open', openHandler);\n        this.socket?.removeEventListener('error', errorListener);\n        this.pingPongLoop(this.id);\n      };\n\n      this.socket.addEventListener('open', openHandler);\n      this.socket.addEventListener('close', this.onCloseHandler);\n      this.socket.addEventListener('message', this.onMessageHandler);\n    });\n  }\n\n  async close(): Promise<void> {\n    window.removeEventListener('offline', this.offlineListener);\n    window.removeEventListener('online', this.onlineListener);\n\n    // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1\n    if (this.socket) {\n      this.socket.close(1000, 'Normal Close');\n      this.setIsConnected(false, 'code: 1000, normal websocket close');\n      this.socket.removeEventListener('close', this.onCloseHandler);\n      this.socket.removeEventListener('message', this.onMessageHandler);\n    } else {\n      this.setIsConnected(false, 'websocket not connected yet');\n    }\n  }\n\n  async join(\n    name: string,\n    data: string,\n    disableVidAutoSub: boolean,\n    serverSubDegrade: boolean,\n    simulcast: boolean,\n    onDemandTracks: boolean,\n    offer?: RTCSessionDescriptionInit,\n  ): Promise<RTCSessionDescriptionInit> {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.JOIN,\n        'Failed to send join over WS connection',\n      );\n    }\n    const params = {\n      name,\n      disableVidAutoSub,\n      data,\n      offer,\n      server_sub_degrade: serverSubDegrade,\n      simulcast,\n      onDemandTracks,\n    };\n    const response: RTCSessionDescriptionInit = await this.internalCall(HMSSignalMethod.JOIN, params);\n\n    this.isJoinCompleted = true;\n    this.pendingTrickle.forEach(({ target, candidate }) => this.trickle(target, candidate));\n    this.pendingTrickle.length = 0;\n\n    HMSLogger.d(this.TAG, `join: response=${JSON.stringify(response, null, 1)}`);\n    return response;\n  }\n\n  trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit) {\n    if (this.isJoinCompleted) {\n      this.notify(HMSSignalMethod.TRICKLE, { target, candidate });\n    } else {\n      this.pendingTrickle.push({ target, candidate });\n    }\n  }\n\n  async offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit> {\n    const response = await this.call(HMSSignalMethod.OFFER, {\n      desc,\n      tracks: Object.fromEntries(tracks),\n    });\n    return response as RTCSessionDescriptionInit;\n  }\n\n  answer(desc: RTCSessionDescriptionInit) {\n    this.notify(HMSSignalMethod.ANSWER, { desc });\n  }\n\n  trackUpdate(tracks: Map<string, Track>) {\n    this.notify(HMSSignalMethod.TRACK_UPDATE, { tracks: Object.fromEntries(tracks) });\n  }\n\n  async broadcast(message: Message) {\n    return await this.call<BroadcastResponse>(HMSSignalMethod.BROADCAST, message.toSignalParams());\n  }\n\n  leave() {\n    this.notify(HMSSignalMethod.LEAVE, {});\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.call(HMSSignalMethod.END_ROOM, { lock, reason });\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.isConnected) {\n      throw Error(`${this.TAG} not connected. Could not send event ${event}`);\n    }\n    this.notify(HMSSignalMethod.ANALYTICS, event.toSignalParams());\n  }\n\n  ping(timeout: number): Promise<number> {\n    const pingTime = Date.now();\n    const timer: Promise<number> = new Promise(resolve => {\n      setTimeout(() => {\n        resolve(Date.now() - pingTime);\n      }, timeout + 1);\n    });\n    const pongTimeDiff = this.internalCall(HMSSignalMethod.PING, { timestamp: pingTime })\n      .then(() => Date.now() - pingTime)\n      .catch(() => Date.now() - pingTime);\n\n    return Promise.race([timer, pongTimeDiff]);\n  }\n\n  async requestRoleChange(params: RequestForRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async requestBulkRoleChange(params: RequestForBulkRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async acceptRoleChangeRequest(params: AcceptRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE, params);\n  }\n\n  async requestTrackStateChange(params: TrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.TRACK_UPDATE_REQUEST, params);\n  }\n\n  async requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.CHANGE_TRACK_MUTE_STATE_REQUEST, params);\n  }\n\n  async removePeer(params: RemovePeerRequest) {\n    await this.call(HMSSignalMethod.PEER_LEAVE_REQUEST, params);\n  }\n\n  async startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams) {\n    await this.call(HMSSignalMethod.START_RTMP_OR_RECORDING_REQUEST, { ...params });\n  }\n\n  async stopRTMPAndRecording() {\n    await this.call(HMSSignalMethod.STOP_RTMP_AND_RECORDING_REQUEST, {});\n  }\n\n  async startHLSStreaming(params: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.START_HLS_STREAMING, { ...params });\n  }\n\n  async stopHLSStreaming(params?: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.STOP_HLS_STREAMING, { ...params });\n  }\n\n  async sendHLSTimedMetadata(params?: HLSTimedMetadataParams): Promise<void> {\n    await this.call(HMSSignalMethod.HLS_TIMED_METADATA, { ...params });\n  }\n\n  async updatePeer(params: UpdatePeerRequestParams) {\n    await this.call(HMSSignalMethod.UPDATE_PEER_METADATA, { ...params });\n  }\n\n  async getPeer(params: getPeerRequestParams) {\n    await this.call(HMSSignalMethod.GET_PEER, { ...params });\n  }\n\n  async joinGroup(name: string): Promise<JoinLeaveGroupResponse> {\n    return await this.call(HMSSignalMethod.GROUP_JOIN, { name });\n  }\n\n  async leaveGroup(name: string): Promise<JoinLeaveGroupResponse> {\n    return await this.call(HMSSignalMethod.GROUP_LEAVE, { name });\n  }\n\n  async addToGroup(peerId: string, name: string) {\n    await this.call(HMSSignalMethod.GROUP_ADD, { name, peer_id: peerId });\n  }\n\n  async removeFromGroup(peerId: string, name: string): Promise<void> {\n    await this.call(HMSSignalMethod.GROUP_REMOVE, { name, peer_id: peerId });\n  }\n\n  setSessionMetadata(params: SetSessionMetadataParams) {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.RECONNECT_SIGNAL,\n        'Failed to set session store value due to network disconnection',\n      );\n    }\n    return this.call<SetSessionMetadataResponse>(HMSSignalMethod.SET_METADATA, { ...params });\n  }\n\n  listenMetadataChange(keys: string[]): Promise<void> {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.RECONNECT_SIGNAL,\n        'Failed to observe session store key due to network disconnection',\n      );\n    }\n    return this.call(HMSSignalMethod.LISTEN_METADATA_CHANGE, { keys });\n  }\n\n  getSessionMetadata(key?: string) {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.RECONNECT_SIGNAL,\n        'Failed to set session store value due to network disconnection',\n      );\n    }\n    return this.call<GetSessionMetadataResponse>(HMSSignalMethod.GET_METADATA, { key });\n  }\n\n  setPollInfo(params: PollInfoSetParams) {\n    this.valiateConnection();\n    return this.call<PollInfoSetResponse>(HMSSignalMethod.POLL_INFO_SET, { ...params });\n  }\n\n  getPollInfo(params: PollInfoGetParams) {\n    this.valiateConnection();\n    return this.call<PollInfoGetResponse>(HMSSignalMethod.POLL_INFO_GET, { ...params });\n  }\n\n  setPollQuestions(params: PollQuestionsSetParams) {\n    this.valiateConnection();\n    return this.call<PollQuestionsSetResponse>(HMSSignalMethod.POLL_QUESTIONS_SET, { ...params });\n  }\n\n  startPoll(params: PollStartParams) {\n    this.valiateConnection();\n    return this.call<PollStartResponse>(HMSSignalMethod.POLL_START, { ...params });\n  }\n\n  stopPoll(params: PollStopParams) {\n    this.valiateConnection();\n    return this.call<PollStopResponse>(HMSSignalMethod.POLL_STOP, { ...params });\n  }\n\n  getPollQuestions(params: PollQuestionsGetParams): Promise<PollQuestionsGetResponse> {\n    this.valiateConnection();\n    return this.call<PollQuestionsGetResponse>(HMSSignalMethod.POLL_QUESTIONS_GET, { ...params });\n  }\n\n  setPollResponses(params: PollResponseSetParams): Promise<PollResponseSetResponse> {\n    this.valiateConnection();\n    return this.call<PollResponseSetResponse>(HMSSignalMethod.POLL_RESPONSE_SET, { ...params });\n  }\n\n  getPollResponses(params: PollResponsesGetParams): Promise<PollResponsesGetResponse> {\n    this.valiateConnection();\n    return this.call<PollResponsesGetResponse>(HMSSignalMethod.POLL_RESPONSES, { ...params });\n  }\n\n  getPollsList(params: PollListParams): Promise<PollListResponse> {\n    this.valiateConnection();\n    return this.call<PollListResponse>(HMSSignalMethod.POLL_LIST, { ...params });\n  }\n\n  getPollResult(params: PollResultParams): Promise<PollResultResponse> {\n    this.valiateConnection();\n    return this.call<PollResultResponse>(HMSSignalMethod.POLL_RESULT, { ...params });\n  }\n\n  private valiateConnection() {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.RECONNECT_SIGNAL,\n        'Failed to send message due to network disconnection',\n      );\n    }\n  }\n\n  private onMessageHandler(event: MessageEvent) {\n    const text: string = event.data;\n    const response = JSON.parse(text);\n    this.resolvePingOnAnyResponse();\n    if (response.id) {\n      this.handleResponseWithId(response);\n    } else if (response.method) {\n      this.handleResponseWithMethod(response);\n    } else {\n      throw Error(`WebSocket message has no 'method' or 'id' field, message=${response}`);\n    }\n  }\n\n  private handleResponseWithId(response: any) {\n    /** This is a response to [call] */\n    const typedResponse = response as JsonRpcResponse;\n    const id: string = typedResponse.id;\n    if (this.callbacks.has(id)) {\n      const cb = this.callbacks.get(id)!;\n      this.callbacks.delete(id);\n      if (typedResponse.result) {\n        cb.resolve(typedResponse.result);\n      } else {\n        cb.reject(typedResponse.error);\n      }\n    } else {\n      this.observer.onNotification(typedResponse);\n    }\n  }\n\n  private handleResponseWithMethod(response: any) {\n    switch (response.method) {\n      case HMSSignalMethod.OFFER:\n        this.observer.onOffer(response.params);\n        break;\n      case HMSSignalMethod.TRICKLE:\n        this.observer.onTrickle(response.params);\n        break;\n      case HMSSignalMethod.SERVER_ERROR:\n        this.observer.onServerError(\n          ErrorFactory.WebsocketMethodErrors.ServerErrors(\n            Number(response.params.code),\n            HMSSignalMethod.SERVER_ERROR,\n            response.params.message,\n          ),\n        );\n        break;\n      case HMSSignalMethod.SERVER_WARNING:\n        HMSLogger.w(this.TAG, response.params);\n        break;\n      default:\n        this.observer.onNotification(response);\n        break;\n    }\n  }\n\n  private resolvePingOnAnyResponse = () => {\n    this.callbacks.forEach((callback, key) => {\n      if (callback.metadata?.method === HMSSignalMethod.PING) {\n        //@ts-ignore\n        callback.resolve({ timestamp: Date.now() });\n        this.callbacks.delete(key);\n      }\n    });\n  };\n\n  private rejectPendingCalls(reason = '') {\n    this.callbacks.forEach((callback, id) => {\n      if (callback.metadata?.method !== HMSSignalMethod.PING) {\n        HMSLogger.e(this.TAG, `rejecting pending callback ${callback.metadata?.method}, id=${id}`);\n        callback.reject(\n          ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n            callback.metadata?.method\n              ? convertSignalMethodtoErrorAction(callback.metadata?.method)\n              : HMSAction.RECONNECT_SIGNAL,\n            reason,\n          ),\n        );\n        this.callbacks.delete(id);\n      }\n    });\n  }\n\n  private async pingPongLoop(id: number) {\n    const pingTimeout = window.HMS?.PING_TIMEOUT || DEFAULT_SIGNAL_PING_TIMEOUT;\n    if (this.isConnected) {\n      const pongTimeDiff = await this.ping(pingTimeout);\n      this.pongResponseTimes.enqueue(pongTimeDiff);\n      if (pongTimeDiff > pingTimeout) {\n        HMSLogger.d(this.TAG, `Pong timeout ${id}, pageHidden=${isPageHidden()}`);\n        if (this.id === id) {\n          this.setIsConnected(false, 'ping pong failure');\n        }\n      } else {\n        setTimeout(() => this.pingPongLoop(id), window.HMS?.PING_INTERVAL || DEFAULT_SIGNAL_PING_INTERVAL);\n      }\n    }\n  }\n\n  private async call<T>(method: HMSSignalMethod, params: Record<string, any>): Promise<T> {\n    const MAX_RETRIES = 3;\n    let error: HMSException = ErrorFactory.WebsocketMethodErrors.ServerErrors(500, method, `Default ${method} error`);\n\n    let retry;\n    for (retry = 1; retry <= MAX_RETRIES; retry++) {\n      try {\n        HMSLogger.d(this.TAG, `Try number ${retry} sending ${method}`, params);\n        return await this.internalCall(method, params);\n      } catch (err) {\n        error = err as HMSException;\n        HMSLogger.e(this.TAG, `Failed sending ${method} try: ${retry}`, { method, params, error });\n        const shouldRetry = parseInt(`${error.code / 100}`) === 5 || error.code === 429;\n        if (!shouldRetry) {\n          break;\n        }\n\n        const delay = (2 + Math.random() * 2) * 1000;\n        await sleep(delay);\n      }\n    }\n    HMSLogger.e(`Sending ${method} over WS failed after ${Math.min(retry, MAX_RETRIES)} retries`, {\n      method,\n      params,\n      error,\n    });\n    throw error;\n  }\n\n  private offlineListener = () => {\n    HMSLogger.d(this.TAG, 'Window network offline');\n    this.setIsConnected(false, 'Window network offline');\n  };\n\n  private onlineListener = () => {\n    HMSLogger.d(this.TAG, 'Window network online');\n    this.observer.onNetworkOnline();\n  };\n}\n", "// @ts-nocheck\nimport { isBrowser } from './support';\n\nexport const getNetworkInfo = () => {\n  if (!isBrowser || typeof navigator.connection === 'undefined') {\n    return;\n  }\n\n  const connection = navigator.connection;\n  const networkInfo = {\n    downlink: connection.downlink,\n    downlinkMax: connection.downlinkMax,\n    effectiveType: connection.effectiveType,\n    rtt: connection.rtt,\n    saveData: connection.saveData,\n    type: connection.type,\n  };\n  return networkInfo;\n};\n", "import { JoinParameters } from './models/JoinParameters';\nimport { TransportFailureCategory } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\nimport ITransport from './ITransport';\nimport ITransportObserver from './ITransportObserver';\nimport { RetryScheduler } from './RetryScheduler';\nimport { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { HTTPAnalyticsTransport } from '../analytics/HTTPAnalyticsTransport';\nimport { PublishStatsAnalytics } from '../analytics/publish-stats';\nimport { SignalAnalyticsTransport } from '../analytics/signal-transport/SignalAnalyticsTransport';\nimport { HMSConnectionRole, HMSTrickle } from '../connection/model';\nimport { IPublishConnectionObserver } from '../connection/publish/IPublishConnectionObserver';\nimport HMSPublishConnection from '../connection/publish/publishConnection';\nimport ISubscribeConnectionObserver from '../connection/subscribe/ISubscribeConnectionObserver';\nimport HMSSubscribeConnection from '../connection/subscribe/subscribeConnection';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport { HLSConfig, HLSTimedMetadata, HMSPeer, HMSRole, HMSRoleChangeRequest } from '../interfaces';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport { HMSLocalStream } from '../media/streams/HMSLocalStream';\nimport { HMSLocalTrack, HMSLocalVideoTrack, HMSTrack } from '../media/tracks';\nimport { TrackState } from '../notification-manager';\nimport { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';\nimport Message from '../sdk/models/HMSMessage';\nimport { IStore } from '../sdk/store';\nimport InitService from '../signal/init';\nimport { InitConfig, InitFlags } from '../signal/init/models';\nimport {\n  HLSRequestParams,\n  HLSTimedMetadataParams,\n  HLSVariant,\n  JoinLeaveGroupResponse,\n  MultiTrackUpdateRequestParams,\n  PollInfoGetParams,\n  PollInfoGetResponse,\n  PollInfoSetParams,\n  PollInfoSetResponse,\n  PollListParams,\n  PollListResponse,\n  PollQuestionsGetParams,\n  PollQuestionsGetResponse,\n  PollQuestionsSetParams,\n  PollQuestionsSetResponse,\n  PollResponseSetParams,\n  PollResponseSetResponse,\n  PollResponsesGetParams,\n  PollResponsesGetResponse,\n  PollResultParams,\n  PollResultResponse,\n  PollStartParams,\n  PollStartResponse,\n  PollStopParams,\n  SetSessionMetadataParams,\n  StartRTMPOrRecordingRequestParams,\n  TrackUpdateRequestParams,\n} from '../signal/interfaces';\nimport { ISignal } from '../signal/ISignal';\nimport { ISignalEventsObserver } from '../signal/ISignalEventsObserver';\nimport JsonRpcSignal from '../signal/jsonrpc';\nimport {\n  ICE_DISCONNECTION_TIMEOUT,\n  MAX_TRANSPORT_RETRIES,\n  PROTOCOL_SPEC,\n  PROTOCOL_VERSION,\n  RENEGOTIATION_CALLBACK_ID,\n  SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID,\n  SUBSCRIBE_TIMEOUT,\n} from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { getNetworkInfo } from '../utils/network-info';\nimport { PromiseCallbacks } from '../utils/promise';\n\nconst TAG = '[HMSTransport]:';\n\n// @DISCUSS: action and extra are not used at all.\ninterface CallbackTriple {\n  promise: PromiseCallbacks<boolean>;\n  action: HMSAction;\n  extra: any;\n}\n\ninterface NegotiateJoinParams {\n  name: string;\n  data: string;\n  autoSubscribeVideo: boolean;\n}\n\nexport default class HMSTransport implements ITransport {\n  private state: TransportState = TransportState.Disconnected;\n  private trackStates: Map<string, TrackState> = new Map();\n  private publishConnection: HMSPublishConnection | null = null;\n  private subscribeConnection: HMSSubscribeConnection | null = null;\n  private initConfig?: InitConfig;\n  private endpoint!: string;\n  private joinParameters?: JoinParameters;\n  private retryScheduler: RetryScheduler;\n  private webrtcInternals?: HMSWebrtcInternals;\n  private publishStatsAnalytics?: PublishStatsAnalytics;\n  private maxSubscribeBitrate = 0;\n  joinRetryCount = 0;\n\n  constructor(\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private store: IStore,\n    private eventBus: EventBus,\n    private analyticsEventsService: AnalyticsEventsService,\n    private analyticsTimer: AnalyticsTimer,\n  ) {\n    this.webrtcInternals = new HMSWebrtcInternals(\n      this.store,\n      this.eventBus,\n      this.publishConnection?.nativeConnection,\n      this.subscribeConnection?.nativeConnection,\n    );\n\n    const onStateChange = async (state: TransportState, error?: HMSException) => {\n      if (state !== this.state) {\n        this.state = state;\n        await this.observer.onStateChange(this.state, error);\n      }\n    };\n    this.retryScheduler = new RetryScheduler(onStateChange, this.sendErrorAnalyticsEvent.bind(this));\n\n    this.eventBus.statsUpdate.subscribe(stats => {\n      const currentSubscribeBitrate = stats.getLocalPeerStats()?.subscribe?.bitrate || 0;\n      this.maxSubscribeBitrate = Math.max(this.maxSubscribeBitrate, currentSubscribeBitrate);\n    });\n\n    this.eventBus.localAudioEnabled.subscribe(({ track }) => this.trackUpdate(track));\n    this.eventBus.localVideoEnabled.subscribe(({ track }) => this.trackUpdate(track));\n  }\n\n  /**\n   * Map of callbacks used to wait for an event to fire.\n   * Used here for:\n   *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete\n   */\n  private readonly callbacks = new Map<string, CallbackTriple>();\n\n  private signalObserver: ISignalEventsObserver = {\n    onOffer: async (jsep: RTCSessionDescriptionInit) => {\n      try {\n        if (!this.subscribeConnection) {\n          return;\n        }\n        await this.subscribeConnection.setRemoteDescription(jsep);\n        HMSLogger.d(\n          TAG,\n          `[SUBSCRIBE] Adding ${this.subscribeConnection.candidates.length} ice-candidates`,\n          this.subscribeConnection.candidates,\n        );\n        for (const candidate of this.subscribeConnection.candidates) {\n          await this.subscribeConnection.addIceCandidate(candidate);\n        }\n        this.subscribeConnection.candidates.length = 0;\n        const answer = await this.subscribeConnection.createAnswer();\n        await this.subscribeConnection.setLocalDescription(answer);\n        this.signal.answer(answer);\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation DONE \u2705');\n      } catch (err) {\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation FAILED \u274C', err);\n        this.state = TransportState.Failed;\n        let ex: HMSException;\n        if (err instanceof HMSException) {\n          ex = err;\n        } else {\n          ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n        }\n        this.observer.onFailure(ex);\n        this.eventBus.analytics.publish(AnalyticsEventFactory.subscribeFail(ex));\n      }\n    },\n\n    onTrickle: async (trickle: HMSTrickle) => {\n      const connection =\n        trickle.target === HMSConnectionRole.Publish ? this.publishConnection : this.subscribeConnection;\n      if (!connection?.remoteDescription) {\n        // ICE candidates can't be added without any remote session description\n        connection?.candidates.push(trickle.candidate);\n      } else {\n        await connection.addIceCandidate(trickle.candidate);\n      }\n    },\n\n    onNotification: (message: any) => this.observer.onNotification(message),\n\n    onServerError: async (error: HMSException) => {\n      await this.observer.onStateChange(TransportState.Failed, error);\n    },\n\n    onFailure: (error: HMSException) => {\n      // @DISCUSS: Should we remove this? Pong failure would have already scheduled signal retry.\n      if (this.joinParameters) {\n        this.retryScheduler.schedule({\n          category: TransportFailureCategory.SignalDisconnect,\n          error,\n          task: this.retrySignalDisconnectTask,\n          originalState: this.state,\n        });\n      }\n    },\n\n    onOffline: async (reason: string) => {\n      HMSLogger.d(TAG, 'socket offline', TransportState[this.state]);\n      try {\n        if (this.state !== TransportState.Leaving && this.joinParameters) {\n          this.retryScheduler.schedule({\n            category: TransportFailureCategory.SignalDisconnect,\n            error: ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(HMSAction.RECONNECT_SIGNAL, reason),\n            task: this.retrySignalDisconnectTask,\n            originalState: this.state,\n          });\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    },\n\n    // this is called when socket connection is successful\n    onOnline: () => {\n      HMSLogger.d(TAG, 'socket online', TransportState[this.state]);\n      this.analyticsSignalTransport.flushFailedEvents(this.store.getLocalPeer()?.peerId);\n    },\n    // this is called when window.online event is triggered\n    onNetworkOnline: () => {\n      this.analyticsEventsService.flushFailedClientEvents();\n    },\n  };\n\n  private signal: ISignal = new JsonRpcSignal(this.signalObserver);\n  private analyticsSignalTransport = new SignalAnalyticsTransport(this.signal);\n\n  private publishConnectionObserver: IPublishConnectionObserver = {\n    onRenegotiationNeeded: async () => {\n      await this.performPublishRenegotiation();\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Publish ice connection state change: ${newState}`);\n\n      // @TODO: Uncomment this and remove connectionstatechange\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Publish connection state change: ${newState}`);\n\n      if (newState === 'connected') {\n        this.publishConnection?.logSelectedIceCandidatePairs();\n      }\n\n      if (newState === 'disconnected') {\n        // if state stays disconnected for 5 seconds, retry\n        setTimeout(() => {\n          if (this.publishConnection?.connectionState === 'disconnected') {\n            this.handleIceConnectionFailure(\n              HMSConnectionRole.Publish,\n              ErrorFactory.WebrtcErrors.ICEDisconnected(\n                HMSAction.PUBLISH,\n                `local candidate - ${this.publishConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.publishConnection?.selectedCandidatePair?.remote.candidate}`,\n              ),\n            );\n          }\n        }, ICE_DISCONNECTION_TIMEOUT);\n      }\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(\n          HMSConnectionRole.Publish,\n          ErrorFactory.WebrtcErrors.ICEFailure(\n            HMSAction.PUBLISH,\n            `local candidate - ${this.publishConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.publishConnection?.selectedCandidatePair?.remote.candidate}`,\n          ),\n        );\n      }\n    },\n  };\n\n  private subscribeConnectionObserver: ISubscribeConnectionObserver = {\n    onApiChannelMessage: (message: string) => {\n      this.observer.onNotification(JSON.parse(message));\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackAdd', `${track}`);\n      this.observer.onTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackRemove', `${track}`);\n      this.observer.onTrackRemove(track);\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Subscribe ice connection state change: ${newState}`);\n\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Subscribe connection state change: ${newState}`);\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(\n          HMSConnectionRole.Subscribe,\n          ErrorFactory.WebrtcErrors.ICEFailure(\n            HMSAction.SUBSCRIBE,\n            `local candidate - ${this.subscribeConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.subscribeConnection?.selectedCandidatePair?.remote.candidate}`,\n          ),\n        );\n      }\n\n      if (newState === 'disconnected') {\n        setTimeout(() => {\n          if (this.subscribeConnection?.connectionState === 'disconnected') {\n            this.handleIceConnectionFailure(\n              HMSConnectionRole.Subscribe,\n              ErrorFactory.WebrtcErrors.ICEDisconnected(\n                HMSAction.SUBSCRIBE,\n                `local candidate - ${this.subscribeConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.subscribeConnection?.selectedCandidatePair?.remote.candidate}`,\n              ),\n            );\n          }\n        }, ICE_DISCONNECTION_TIMEOUT);\n      }\n\n      if (newState === 'connected') {\n        this.handleSubscribeConnectionConnected();\n      }\n    },\n  };\n\n  getWebrtcInternals() {\n    return this.webrtcInternals;\n  }\n\n  isFlagEnabled(flag: InitFlags) {\n    const config = this.initConfig?.config;\n    const flags = config?.enabledFlags || [];\n    return flags.includes(flag);\n  }\n\n  async preview(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    const initConfig = await this.connect(token, endpoint, peerId, customData, autoSubscribeVideo);\n    this.state = TransportState.Preview;\n    this.observer.onStateChange(this.state);\n    return initConfig;\n  }\n\n  async join(\n    authToken: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    initEndpoint: string,\n    autoSubscribeVideo = false,\n  ): Promise<void> {\n    HMSLogger.d(TAG, 'join: started \u23F0');\n    try {\n      if (!this.signal.isConnected || !this.initConfig) {\n        await this.connect(authToken, initEndpoint, peerId, customData, autoSubscribeVideo);\n      }\n\n      this.validateNotDisconnected('connect');\n\n      if (this.initConfig) {\n        await this.waitForLocalRoleAvailability();\n        await this.createConnectionsAndNegotiateJoin(customData, autoSubscribeVideo);\n        await this.initRtcStatsMonitor();\n\n        HMSLogger.d(TAG, '\u2705 join: Negotiated over PUBLISH connection');\n      }\n    } catch (error) {\n      HMSLogger.e(TAG, `join: failed \u274C [token=${authToken}]`, error);\n      this.state = TransportState.Failed;\n      const ex = error as HMSException;\n      // set isTerminal to true if not already when error code is 500(internal biz server error)\n      ex.isTerminal = ex.isTerminal || ex.code === 500;\n      await this.observer.onStateChange(this.state, ex);\n      throw ex;\n    }\n\n    HMSLogger.d(TAG, '\u2705 join: successful');\n    this.state = TransportState.Joined;\n    this.observer.onStateChange(this.state);\n  }\n\n  async connect(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    this.setTransportStateForConnect();\n    this.joinParameters = new JoinParameters(\n      token,\n      peerId,\n      customData.name,\n      customData.metaData,\n      endpoint,\n      autoSubscribeVideo,\n    );\n    try {\n      const response = await this.internalConnect(token, endpoint, peerId);\n      return response;\n    } catch (error) {\n      const shouldRetry =\n        error instanceof HMSException &&\n        ([\n          ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n          ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n          ErrorCodes.WebSocketConnectionErrors.ABNORMAL_CLOSE,\n          ErrorCodes.APIErrors.ENDPOINT_UNREACHABLE,\n        ].includes(error.code) ||\n          error.code.toString().startsWith('5') ||\n          error.code.toString().startsWith('429'));\n\n      if (shouldRetry) {\n        const task = async () => {\n          await this.internalConnect(token, endpoint, peerId);\n          return Boolean(this.initConfig && this.initConfig.endpoint);\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.ConnectFailed,\n          error,\n          task,\n          originalState: this.state,\n          maxFailedRetries: MAX_TRANSPORT_RETRIES,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async leave(notifyServer: boolean): Promise<void> {\n    this.retryScheduler.reset();\n    this.joinParameters = undefined;\n    HMSLogger.d(TAG, 'leaving in transport');\n    try {\n      this.state = TransportState.Leaving;\n      this.publishStatsAnalytics?.stop();\n      this.webrtcInternals?.cleanup();\n      await this.publishConnection?.close();\n      await this.subscribeConnection?.close();\n      if (notifyServer) {\n        try {\n          this.signal.leave();\n          HMSLogger.d(TAG, 'signal leave done');\n        } catch (err) {\n          HMSLogger.w(TAG, 'failed to send leave on websocket to server', err);\n        }\n      }\n      this.analyticsEventsService.flushFailedClientEvents();\n      this.analyticsEventsService.reset();\n      await this.signal.close();\n    } catch (err) {\n      this.eventBus.analytics.publish(AnalyticsEventFactory.disconnect(err as Error));\n      HMSLogger.e(TAG, 'leave: FAILED \u274C', err);\n    } finally {\n      this.state = TransportState.Disconnected;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const changedFromNonWebRTCToWebRTC = !this.doesRoleNeedWebRTC(oldRole) && this.doesRoleNeedWebRTC(newRole);\n    if (!changedFromNonWebRTCToWebRTC) {\n      return;\n    }\n\n    HMSLogger.d(\n      TAG,\n      'Local peer role updated to webrtc role, creating PeerConnections and performing inital publish negotiation \u23F3',\n    );\n    this.createPeerConnections();\n    await this.negotiateOnFirstPublish();\n  };\n\n  async publish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      try {\n        await this.publishTrack(track);\n      } catch (error) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.publish({\n            devices: this.deviceManager.getDevices(),\n            error: error as Error,\n          }),\n        );\n      }\n    }\n  }\n\n  async unpublish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.unpublishTrack(track);\n    }\n  }\n\n  async sendMessage(message: Message) {\n    return await this.signal.broadcast(message);\n  }\n\n  /**\n   * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and\n   * source. The hack won't work if there are multiple tracks with same source and type.\n   */\n  trackUpdate(track: HMSLocalTrack) {\n    const currentTrackStates = Array.from(this.trackStates.values());\n    const originalTrackState = currentTrackStates.find(\n      trackState => track.type === trackState.type && track.source === trackState.source,\n    );\n    if (originalTrackState) {\n      const newTrackState = new TrackState({\n        ...originalTrackState,\n        mute: !track.enabled,\n      });\n      this.trackStates.set(originalTrackState.track_id, newTrackState);\n      HMSLogger.d(TAG, 'Track Update', this.trackStates, track);\n      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));\n    }\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async changeRoleOfPeer(forPeer: HMSPeer, toRole: string, force: boolean) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string) {\n    await this.signal.requestBulkRoleChange({\n      roles: roles.map((role: HMSRole) => role.name),\n      role: toRole,\n      force: true,\n    });\n  }\n\n  async acceptRoleChange(request: HMSRoleChangeRequest) {\n    await this.signal.acceptRoleChangeRequest({\n      requested_by: request.requestedBy?.peerId,\n      role: request.role.name,\n      token: request.token,\n    });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.signal.endRoom(lock, reason);\n  }\n\n  async removePeer(peerId: string, reason: string) {\n    await this.signal.removePeer({ requested_for: peerId, reason });\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    const signalParams: StartRTMPOrRecordingRequestParams = {\n      meeting_url: params.meetingURL,\n      record: params.record,\n    };\n\n    if (params.rtmpURLs?.length) {\n      signalParams.rtmp_urls = params.rtmpURLs;\n    }\n\n    if (params.resolution) {\n      signalParams.resolution = params.resolution;\n    }\n\n    await this.signal.startRTMPOrRecording(signalParams);\n  }\n\n  async stopRTMPOrRecording() {\n    await this.signal.stopRTMPAndRecording();\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    const hlsParams: HLSRequestParams = {};\n    if (params && params.variants && params.variants.length > 0) {\n      hlsParams.variants = params.variants.map(variant => {\n        const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n        if (variant.metadata) {\n          hlsVariant.metadata = variant.metadata;\n        }\n        return hlsVariant;\n      });\n    }\n    if (params?.recording) {\n      hlsParams.hls_recording = {\n        single_file_per_layer: params.recording.singleFilePerLayer,\n        hls_vod: params.recording.hlsVod,\n      };\n    }\n    await this.signal.startHLSStreaming(hlsParams);\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (params) {\n      const hlsParams: HLSRequestParams = {\n        variants: params?.variants?.map(variant => {\n          const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n          if (variant.metadata) {\n            hlsVariant.metadata = variant.metadata;\n          }\n          return hlsVariant;\n        }),\n      };\n      await this.signal.stopHLSStreaming(hlsParams);\n    }\n    await this.signal.stopHLSStreaming();\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    if (metadataList.length > 0) {\n      const hlsMtParams: HLSTimedMetadataParams = {\n        metadata_objs: metadataList,\n      };\n\n      await this.signal.sendHLSTimedMetadata(hlsMtParams);\n    }\n  }\n  async changeName(name: string) {\n    const peer = this.store.getLocalPeer();\n    if (peer && peer.name !== name) {\n      await this.signal.updatePeer({\n        name: name,\n      });\n    }\n  }\n\n  async changeMetadata(metadata: string) {\n    await this.signal.updatePeer({\n      data: metadata,\n    });\n  }\n\n  getSessionMetadata(key?: string) {\n    return this.signal.getSessionMetadata(key);\n  }\n\n  setSessionMetadata(params: SetSessionMetadataParams) {\n    return this.signal.setSessionMetadata(params);\n  }\n\n  listenMetadataChange(keys: string[]): Promise<void> {\n    return this.signal.listenMetadataChange(keys);\n  }\n\n  setPollInfo(params: PollInfoSetParams): Promise<PollInfoSetResponse> {\n    return this.signal.setPollInfo(params);\n  }\n\n  getPollInfo(params: PollInfoGetParams): Promise<PollInfoGetResponse> {\n    return this.signal.getPollInfo(params);\n  }\n\n  setPollQuestions(params: PollQuestionsSetParams): Promise<PollQuestionsSetResponse> {\n    return this.signal.setPollQuestions(params);\n  }\n\n  getPollQuestions(params: PollQuestionsGetParams): Promise<PollQuestionsGetResponse> {\n    return this.signal.getPollQuestions(params);\n  }\n\n  startPoll(params: PollStartParams): Promise<PollStartResponse> {\n    return this.signal.startPoll(params);\n  }\n\n  stopPoll(params: PollStopParams): Promise<PollStartResponse> {\n    return this.signal.stopPoll(params);\n  }\n\n  setPollResponses(params: PollResponseSetParams): Promise<PollResponseSetResponse> {\n    return this.signal.setPollResponses(params);\n  }\n\n  getPollResponses(params: PollResponsesGetParams): Promise<PollResponsesGetResponse> {\n    return this.signal.getPollResponses(params);\n  }\n\n  getPollsList(params: PollListParams): Promise<PollListResponse> {\n    return this.signal.getPollsList(params);\n  }\n\n  getPollResult(params: PollResultParams): Promise<PollResultResponse> {\n    return this.signal.getPollResult(params);\n  }\n\n  async joinGroup(name: string): Promise<JoinLeaveGroupResponse> {\n    return this.signal.joinGroup(name);\n  }\n\n  async leaveGroup(name: string): Promise<JoinLeaveGroupResponse> {\n    return this.signal.leaveGroup(name);\n  }\n\n  async addToGroup(peerId: string, name: string) {\n    this.signal.addToGroup(peerId, name);\n  }\n\n  async removeFromGroup(peerId: string, name: string): Promise<void> {\n    this.signal.removeFromGroup(peerId, name);\n  }\n\n  async changeTrackState(trackUpdateRequest: TrackUpdateRequestParams) {\n    await this.signal.requestTrackStateChange(trackUpdateRequest);\n  }\n\n  async changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams) {\n    await this.signal.requestMultiTrackStateChange(trackUpdateRequest);\n  }\n\n  private async publishTrack(track: HMSLocalTrack): Promise<void> {\n    track.publishedTrackId = track.getTrackIDBeingSent();\n    HMSLogger.d(\n      TAG,\n      `\u23F3 publishTrack: trackId=${track.trackId}, toPublishTrackId=${track.publishedTrackId}`,\n      `${track}`,\n    );\n    this.trackStates.set(track.publishedTrackId, new TrackState(track));\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.PUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.setConnection(this.publishConnection!);\n    const simulcastLayers = this.store.getSimulcastLayers(track.source!);\n    stream.addTransceiver(track, simulcastLayers);\n    HMSLogger.time(`publish-${track.trackId}-${track.type}`);\n    await p;\n    HMSLogger.timeEnd(`publish-${track.trackId}-${track.type}`);\n    // add track to store after publish\n    this.store.addTrack(track);\n\n    await stream\n      .setMaxBitrateAndFramerate(track)\n      .then(() => {\n        HMSLogger.d(\n          TAG,\n          `Setting maxBitrate=${track.settings.maxBitrate} kpbs${\n            track instanceof HMSLocalVideoTrack ? ` and maxFramerate=${track.settings.maxFramerate}` : ''\n          } for ${track.source} ${track.type} ${track.trackId}`,\n        );\n      })\n      .catch(error => HMSLogger.w(TAG, 'Failed setting maxBitrate and maxFramerate', error));\n\n    track.isPublished = true;\n\n    HMSLogger.d(TAG, `\u2705 publishTrack: trackId=${track.trackId}`, `${track}`, this.callbacks);\n  }\n\n  private async unpublishTrack(track: HMSLocalTrack): Promise<void> {\n    HMSLogger.d(TAG, `\u23F3 unpublishTrack: trackId=${track.trackId}`, `${track}`);\n    if (track.publishedTrackId && this.trackStates.has(track.publishedTrackId)) {\n      this.trackStates.delete(track.publishedTrackId);\n    } else {\n      // TODO: hotfix to unpublish replaced video track id, solve it properly\n      // it won't work when there are multiple regular video tracks, hmslocalvideotrack can store\n      // the original initial track id for a proper fix\n      const currentTrackStates = Array.from(this.trackStates.values());\n      const originalTrackState = currentTrackStates.find(\n        trackState => track.type === trackState.type && track.source === trackState.source,\n      );\n      if (originalTrackState) {\n        this.trackStates.delete(originalTrackState.track_id);\n      }\n    }\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.UNPUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.removeSender(track);\n    await p;\n    await track.cleanup();\n    // remove track from store on unpublish\n    this.store.removeTrack(track);\n    HMSLogger.d(TAG, `\u2705 unpublishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  private waitForLocalRoleAvailability() {\n    if (this.store.hasRoleDetailsArrived()) {\n      return;\n    } else {\n      return new Promise<void>(resolve => {\n        this.eventBus.policyChange.subscribeOnce(() => resolve());\n      });\n    }\n  }\n\n  private async createConnectionsAndNegotiateJoin(\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ) {\n    const isWebRTC = this.doesLocalPeerNeedWebRTC();\n    if (isWebRTC) {\n      this.createPeerConnections();\n    }\n\n    this.analyticsTimer.start(TimedEvent.JOIN_RESPONSE);\n    await this.negotiateJoinWithRetry({\n      name: customData.name,\n      data: customData.metaData,\n      autoSubscribeVideo,\n      isWebRTC,\n    });\n    this.analyticsTimer.end(TimedEvent.JOIN_RESPONSE);\n  }\n\n  private createPeerConnections() {\n    if (this.initConfig) {\n      if (!this.publishConnection) {\n        this.publishConnection = new HMSPublishConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.publishConnectionObserver,\n        );\n      }\n\n      if (!this.subscribeConnection) {\n        this.subscribeConnection = new HMSSubscribeConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.isFlagEnabled.bind(this),\n          this.subscribeConnectionObserver,\n        );\n      }\n    }\n  }\n\n  private async negotiateJoinWithRetry({\n    name,\n    data,\n    autoSubscribeVideo,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }) {\n    try {\n      await this.negotiateJoin({ name, data, autoSubscribeVideo, isWebRTC });\n    } catch (error) {\n      HMSLogger.e(TAG, 'Join negotiation failed \u274C', error);\n      const hmsError =\n        error instanceof HMSException\n          ? error\n          : ErrorFactory.WebsocketMethodErrors.ServerErrors(\n              500,\n              HMSAction.JOIN,\n              `Websocket join error - ${(error as Error).message}`,\n            );\n      const shouldRetry =\n        parseInt(`${hmsError.code / 100}`) === 5 ||\n        [ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST, 429].includes(hmsError.code);\n\n      if (hmsError.code === 410) {\n        hmsError.isTerminal = true;\n      }\n\n      if (shouldRetry) {\n        this.joinRetryCount = 0;\n        hmsError.isTerminal = false;\n        const task = async () => {\n          this.joinRetryCount++;\n          return await this.negotiateJoin({ name, data, autoSubscribeVideo, isWebRTC });\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.JoinWSMessageFailed,\n          error: hmsError,\n          task,\n          originalState: TransportState.Joined,\n          maxFailedRetries: 3,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private async negotiateJoin({\n    name,\n    data,\n    autoSubscribeVideo,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }): Promise<boolean> {\n    if (isWebRTC) {\n      return await this.negotiateJoinWebRTC({ name, data, autoSubscribeVideo });\n    } else {\n      return await this.negotiateJoinNonWebRTC({ name, data, autoSubscribeVideo });\n    }\n  }\n\n  private async negotiateJoinWebRTC({ name, data, autoSubscribeVideo }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer();\n    await this.publishConnection.setLocalDescription(offer);\n    const serverSubDegrade = this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION);\n    const simulcast = this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST);\n    const onDemandTracks = this.isFlagEnabled(InitFlags.FLAG_ON_DEMAND_TRACKS);\n    const answer = await this.signal.join(\n      name,\n      data,\n      !autoSubscribeVideo,\n      serverSubDegrade,\n      simulcast,\n      onDemandTracks,\n      offer,\n    );\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async negotiateJoinNonWebRTC({ name, data, autoSubscribeVideo }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating Non-WebRTC');\n    const serverSubDegrade = this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION);\n    const simulcast = this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST);\n    const onDemandTracks = this.isFlagEnabled(InitFlags.FLAG_ON_DEMAND_TRACKS);\n    const response = await this.signal.join(\n      name,\n      data,\n      !autoSubscribeVideo,\n      serverSubDegrade,\n      simulcast,\n      onDemandTracks,\n    );\n    return !!response;\n  }\n\n  /**\n   * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer\n   */\n  private async negotiateOnFirstPublish() {\n    HMSLogger.d(TAG, '\u23F3 Negotiating offer over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer(this.trackStates);\n    await this.publishConnection.setLocalDescription(offer);\n    const answer = await this.signal.offer(offer, this.trackStates);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async performPublishRenegotiation(constraints?: RTCOfferOptions) {\n    HMSLogger.d(TAG, `\u23F3 [role=PUBLISH] onRenegotiationNeeded START`, this.trackStates);\n    const callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);\n    if (!callback) {\n      return;\n    }\n\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot renegotiate');\n      return;\n    }\n\n    try {\n      const offer = await this.publishConnection.createOffer(this.trackStates, constraints);\n      await this.publishConnection.setLocalDescription(offer);\n      HMSLogger.time(`renegotiation-offer-exchange`);\n      const answer = await this.signal.offer(offer, this.trackStates);\n      this.callbacks.delete(RENEGOTIATION_CALLBACK_ID);\n      HMSLogger.timeEnd(`renegotiation-offer-exchange`);\n      await this.publishConnection.setRemoteDescription(answer);\n      callback.promise.resolve(true);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded DONE \u2705`);\n    } catch (err) {\n      let ex: HMSException;\n      if (err instanceof HMSException) {\n        ex = err;\n      } else {\n        ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n      }\n\n      callback!.promise.reject(ex);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded FAILED \u274C`);\n    }\n  }\n\n  private async handleIceConnectionFailure(role: HMSConnectionRole, error: HMSException) {\n    // ice retry is already in progress(from disconnect state)\n    if (\n      this.retryScheduler.isTaskInProgress(\n        HMSConnectionRole.Publish\n          ? TransportFailureCategory.PublishIceConnectionFailed\n          : TransportFailureCategory.SubscribeIceConnectionFailed,\n      )\n    ) {\n      return;\n    }\n\n    if (role === HMSConnectionRole.Publish) {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.PublishIceConnectionFailed,\n        error,\n        task: this.retryPublishIceFailedTask,\n        originalState: TransportState.Joined,\n      });\n    } else {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.SubscribeIceConnectionFailed,\n        error,\n        task: this.retrySubscribeIceFailedTask,\n        originalState: TransportState.Joined,\n        maxFailedRetries: 1,\n      });\n    }\n  }\n\n  private async internalConnect(token: string, initEndpoint: string, peerId: string) {\n    HMSLogger.d(TAG, 'connect: started \u23F0');\n    const connectRequestedAt = new Date();\n    try {\n      this.analyticsTimer.start(TimedEvent.INIT);\n      this.initConfig = await InitService.fetchInitConfig({\n        token,\n        peerId,\n        userAgent: this.store.getUserAgent(),\n        initEndpoint,\n      });\n      this.analyticsTimer.end(TimedEvent.INIT);\n      HTTPAnalyticsTransport.setWebsocketEndpoint(this.initConfig.endpoint);\n      // if leave was called while init was going on, don't open websocket\n      this.validateNotDisconnected('post init');\n      await this.openSignal(token, peerId);\n      this.observer.onConnected();\n      this.store.setSimulcastEnabled(this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST));\n      HMSLogger.d(TAG, 'Adding Analytics Transport: JsonRpcSignal');\n      this.analyticsEventsService.setTransport(this.analyticsSignalTransport);\n      this.analyticsEventsService.flush();\n      return this.initConfig;\n    } catch (error) {\n      if (this.state !== TransportState.Reconnecting) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.connect(\n            error as Error,\n            this.getAdditionalAnalyticsProperties(),\n            connectRequestedAt,\n            new Date(),\n            initEndpoint,\n          ),\n        );\n      }\n      HMSLogger.e(TAG, '\u274C internal connect: failed', error);\n      throw error;\n    }\n  }\n\n  // leave could be called between any two async tasks, which would make\n  // the state disconnected instead of connecting, throw error for those cases.\n  private validateNotDisconnected(stage: string) {\n    if (this.state === TransportState.Disconnected) {\n      HMSLogger.w(TAG, 'aborting join as transport state is disconnected');\n      throw ErrorFactory.GenericErrors.ValidationFailed(`leave called before join could complete - stage=${stage}`);\n    }\n  }\n\n  private async openSignal(token: string, peerId: string) {\n    if (!this.initConfig) {\n      throw ErrorFactory.APIErrors.InitConfigNotAvailable(HMSAction.INIT, 'Init Config not found');\n    }\n\n    HMSLogger.d(TAG, '\u23F3 internal connect: connecting to ws endpoint', this.initConfig.endpoint);\n    const url = new URL(this.initConfig.endpoint);\n    url.searchParams.set('peer', peerId);\n    url.searchParams.set('token', token);\n    url.searchParams.set('user_agent_v2', this.store.getUserAgent());\n    url.searchParams.set('protocol_version', PROTOCOL_VERSION);\n    url.searchParams.set('protocol_spec', PROTOCOL_SPEC);\n\n    this.endpoint = url.toString();\n    this.analyticsTimer.start(TimedEvent.WEBSOCKET_CONNECT);\n    await this.signal.open(this.endpoint);\n    this.analyticsTimer.end(TimedEvent.WEBSOCKET_CONNECT);\n    this.analyticsTimer.start(TimedEvent.ON_POLICY_CHANGE);\n    this.analyticsTimer.start(TimedEvent.ROOM_STATE);\n    HMSLogger.d(TAG, '\u2705 internal connect: connected to ws endpoint');\n  }\n\n  private async initRtcStatsMonitor() {\n    this.webrtcInternals?.setPeerConnections({\n      publish: this.publishConnection?.nativeConnection,\n      subscribe: this.subscribeConnection?.nativeConnection,\n    });\n\n    if (this.isFlagEnabled(InitFlags.FLAG_PUBLISH_STATS)) {\n      this.publishStatsAnalytics = new PublishStatsAnalytics(\n        this.store,\n        this.eventBus,\n        this.initConfig?.config.publishStats?.maxSampleWindowSize,\n        this.initConfig?.config.publishStats?.maxSamplePushInterval,\n      );\n\n      this.getWebrtcInternals()?.start();\n    }\n  }\n\n  /**\n   * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything\n   * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role\n   */\n  private doesRoleNeedWebRTC(role: HMSRole) {\n    if (!this.isFlagEnabled(InitFlags.FLAG_NON_WEBRTC_DISABLE_OFFER)) {\n      return true;\n    }\n\n    const isPublishing = Boolean(role.publishParams.allowed && role.publishParams.allowed?.length > 0);\n    const isSubscribing = Boolean(\n      role.subscribeParams.subscribeToRoles && role.subscribeParams.subscribeToRoles?.length > 0,\n    );\n\n    return isPublishing || isSubscribing;\n  }\n\n  private doesLocalPeerNeedWebRTC() {\n    const localRole = this.store.getLocalPeer()?.role;\n    if (!localRole) {\n      return true;\n    }\n\n    return this.doesRoleNeedWebRTC(localRole);\n  }\n\n  private retryPublishIceFailedTask = async () => {\n    /**\n     * Proceed with the retry even if the connection state is connected as the offer could have failed\n     * which will cause missing tiles if it is not sent again.\n     * Do iceRestart only if not connected\n     */\n    if (this.publishConnection) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n      await this.performPublishRenegotiation({ iceRestart: this.publishConnection.connectionState !== 'connected' });\n      await p;\n    }\n\n    return true;\n  };\n\n  private retrySubscribeIceFailedTask = async () => {\n    if (this.subscribeConnection && this.subscribeConnection.connectionState !== 'connected') {\n      const p = new Promise<boolean>((resolve, reject) => {\n        // Use subscribe constant string\n        this.callbacks.set(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n\n      const timeout = new Promise(resolve => {\n        setTimeout(resolve, SUBSCRIBE_TIMEOUT, false);\n      });\n\n      return Promise.race([p, timeout]) as Promise<boolean>;\n    }\n\n    return true;\n  };\n\n  private retrySignalDisconnectTask = async () => {\n    HMSLogger.d(TAG, 'retrySignalDisconnectTask', { signalConnected: this.signal.isConnected });\n    // Check if ws is disconnected - otherwise if only publishIce fails\n    // and ws connect is success then we don't need to reconnect to WebSocket\n    if (!this.signal.isConnected) {\n      await this.internalConnect(\n        this.joinParameters!.authToken,\n        this.joinParameters!.endpoint,\n        this.joinParameters!.peerId,\n      );\n    }\n\n    // Only retry publish failed task after joining the call - not needed in preview signal reconnect\n    const ok = this.store.getRoom()?.joinedAt\n      ? this.signal.isConnected && (await this.retryPublishIceFailedTask())\n      : this.signal.isConnected;\n    // Send track update to sync local track state changes during reconnection\n    this.signal.trackUpdate(this.trackStates);\n\n    return ok;\n  };\n\n  private handleSubscribeConnectionConnected() {\n    this.subscribeConnection?.logSelectedIceCandidatePairs();\n    const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n    this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n    if (callback) {\n      callback.promise.resolve(true);\n    }\n  }\n\n  private setTransportStateForConnect() {\n    if (this.state === TransportState.Failed) {\n      this.state = TransportState.Disconnected;\n    }\n\n    if (this.state !== TransportState.Disconnected && this.state !== TransportState.Reconnecting) {\n      throw ErrorFactory.WebsocketMethodErrors.AlreadyJoined(\n        HMSAction.JOIN,\n        `Cannot join a meeting in ${this.state} state`,\n      );\n    }\n\n    if (this.state === TransportState.Disconnected) {\n      this.state = TransportState.Connecting;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  private sendErrorAnalyticsEvent(error: HMSException, category: TransportFailureCategory) {\n    const additionalProps = this.getAdditionalAnalyticsProperties();\n    let event: AnalyticsEvent;\n    switch (category) {\n      case TransportFailureCategory.ConnectFailed:\n        event = AnalyticsEventFactory.connect(error, additionalProps);\n        break;\n      case TransportFailureCategory.SignalDisconnect:\n        event = AnalyticsEventFactory.disconnect(error, additionalProps);\n        break;\n      case TransportFailureCategory.JoinWSMessageFailed:\n        event = AnalyticsEventFactory.join({\n          error,\n          time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n          init_response_time: this.analyticsTimer.getTimeTaken(TimedEvent.INIT),\n          ws_connect_time: this.analyticsTimer.getTimeTaken(TimedEvent.WEBSOCKET_CONNECT),\n          on_policy_change_time: this.analyticsTimer.getTimeTaken(TimedEvent.ON_POLICY_CHANGE),\n          local_audio_track_time: this.analyticsTimer.getTimeTaken(TimedEvent.LOCAL_AUDIO_TRACK),\n          local_video_track_time: this.analyticsTimer.getTimeTaken(TimedEvent.LOCAL_VIDEO_TRACK),\n          retries_join: this.joinRetryCount,\n        });\n        break;\n      case TransportFailureCategory.PublishIceConnectionFailed:\n        event = AnalyticsEventFactory.publish({ error });\n        break;\n      case TransportFailureCategory.SubscribeIceConnectionFailed:\n        event = AnalyticsEventFactory.subscribeFail(error);\n        break;\n    }\n    this.eventBus.analytics.publish(event!);\n  }\n\n  getSubscribeConnection() {\n    return this.subscribeConnection;\n  }\n\n  getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties {\n    const network_info = getNetworkInfo();\n    const document_hidden = typeof document !== 'undefined' && document.hidden;\n    const num_degraded_tracks = this.store.getRemoteVideoTracks().filter(track => track.degraded).length;\n    const publishBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.publish?.bitrate;\n    const subscribeBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.subscribe?.bitrate;\n\n    return {\n      network_info,\n      document_hidden,\n      num_degraded_tracks,\n      bitrate: {\n        publish: publishBitrate,\n        subscribe: subscribeBitrate,\n      },\n      max_sub_bitrate: this.maxSubscribeBitrate,\n      recent_pong_response_times: this.signal.getPongResponseTimes(),\n      transport_state: this.state,\n    };\n  }\n}\n", "import { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\n\n/**\n * @param retryCodes codes from the server reponse that needs to be retried\n */\n// eslint-disable-next-line complexity\nexport const fetchWithRetry = async (\n  url: RequestInfo,\n  options: RequestInit,\n  retryCodes?: number[],\n): Promise<Response> => {\n  const MAX_RETRIES = 4;\n  let error = Error('something went wrong during fetch');\n  for (let i = 0; i < MAX_RETRIES; i++) {\n    try {\n      // fetch will throw error if there's a browser-level issue\n      const response = await fetch(url, options);\n      const data = await response.clone().json();\n      // throw error for additional codes to retry based on server's response\n      if (retryCodes && retryCodes.length && !response.ok && retryCodes.includes(data.code)) {\n        throw ErrorFactory.APIErrors.ServerErrors(data.code, HMSAction.GET_TOKEN, data.message, false);\n      }\n\n      return response;\n    } catch (err) {\n      error = err as unknown as Error;\n    }\n  }\n  if (['Failed to fetch', 'NetworkError'].some(message => error.message.includes(message))) {\n    throw ErrorFactory.APIErrors.EndpointUnreachable(HMSAction.GET_TOKEN, error.message);\n  }\n  throw error;\n};\n", "import { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\n\nexport interface AuthToken {\n  roomId: string;\n  userId: string;\n  role: string;\n}\n\nexport default function decodeJWT(token?: string): AuthToken {\n  if (!token || token.length === 0) {\n    throw ErrorFactory.APIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      'Token cannot be an empty string or undefined or null',\n    );\n  }\n\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw ErrorFactory.APIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `Expected 3 '.' separate fields - header, payload and signature respectively`,\n    );\n  }\n\n  const payloadStr = atob(parts[1]);\n  try {\n    const payload = JSON.parse(payloadStr);\n    return {\n      roomId: payload.room_id,\n      userId: payload.user_id,\n      role: payload.role,\n    } as AuthToken;\n  } catch (err) {\n    throw ErrorFactory.APIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `couldn't parse to json - ${(err as Error).message}`,\n    );\n  }\n}\n", "import Message from './models/HMSMessage';\nimport HMSRoom from './models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from './models/peer';\nimport { LocalTrackManager } from './LocalTrackManager';\nimport { NetworkTestManager } from './NetworkTestManager';\nimport RoleChangeManager from './RoleChangeManager';\nimport { IStore, Store } from './store';\nimport { WakeLockManager } from './WakeLockManager';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { HMSAnalyticsLevel } from '../analytics/AnalyticsEventLevel';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { DeviceManager } from '../device-manager';\nimport { AudioOutputManager } from '../device-manager/AudioOutputManager';\nimport { DeviceStorageManager } from '../device-manager/DeviceStorage';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory } from '../error/ErrorFactory';\nimport { HMSAction } from '../error/HMSAction';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport {\n  HMSChangeMultiTrackStateParams,\n  HMSConfig,\n  HMSConnectionQualityListener,\n  HMSDeviceChangeEvent,\n  HMSFrameworkInfo,\n  HMSMessageInput,\n  HMSPlaylistType,\n  HMSPreviewConfig,\n  HMSRole,\n  HMSRoleChangeRequest,\n  HMSScreenShareConfig,\n  TokenRequest,\n  TokenRequestOptions,\n} from '../interfaces';\nimport { DeviceChangeListener } from '../interfaces/devices';\nimport { IErrorListener } from '../interfaces/error-listener';\nimport { HLSConfig, HLSTimedMetadata } from '../interfaces/hls-config';\nimport { HMSInterface } from '../interfaces/hms';\nimport { HMSLeaveRoomRequest } from '../interfaces/leave-room-request';\nimport { HMSPreviewListener } from '../interfaces/preview-listener';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSAudioListener, HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport { HMSLocalStream } from '../media/streams/HMSLocalStream';\nimport {\n  HMSLocalAudioTrack,\n  HMSLocalTrack,\n  HMSLocalVideoTrack,\n  HMSRemoteTrack,\n  HMSTrackSource,\n  HMSTrackType,\n  HMSVideoTrack,\n} from '../media/tracks';\nimport { HMSNotificationMethod, PeerLeaveRequestNotification } from '../notification-manager';\nimport { NotificationManager } from '../notification-manager/NotificationManager';\nimport { PlaylistManager } from '../playlist-manager';\nimport { SessionStore } from '../session-store';\nimport { InteractivityCenter } from '../session-store/interactivity-center';\nimport { InitConfig } from '../signal/init/models';\nimport HMSTransport from '../transport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport { TransportState } from '../transport/models/TransportState';\nimport { HAND_RAISE_GROUP_NAME } from '../utils/constants';\nimport { fetchWithRetry } from '../utils/fetch';\nimport decodeJWT from '../utils/jwt';\nimport HMSLogger, { HMSLogLevel } from '../utils/logger';\nimport { HMSAudioContextHandler } from '../utils/media';\nimport { isNode } from '../utils/support';\nimport { validateMediaDevicesExistence, validateRTCPeerConnection } from '../utils/validations';\n\nconst INITIAL_STATE = {\n  published: false,\n  isInitialised: false,\n  isReconnecting: false,\n  isPreviewInProgress: false,\n  isPreviewCalled: false,\n  isJoinInProgress: false,\n  deviceManagersInitialised: false,\n};\n\nexport class HMSSdk implements HMSInterface {\n  private transport!: HMSTransport;\n  private readonly TAG = '[HMSSdk]:';\n  private listener?: HMSUpdateListener;\n  private errorListener?: IErrorListener;\n  private deviceChangeListener?: DeviceChangeListener;\n  private audioListener?: HMSAudioListener;\n  private store!: IStore;\n  private notificationManager?: NotificationManager;\n  private deviceManager!: DeviceManager;\n  private audioSinkManager!: AudioSinkManager;\n  private playlistManager!: PlaylistManager;\n  private audioOutput!: AudioOutputManager;\n  private transportState: TransportState = TransportState.Disconnected;\n  private roleChangeManager?: RoleChangeManager;\n  private localTrackManager!: LocalTrackManager;\n  private analyticsEventsService!: AnalyticsEventsService;\n  private analyticsTimer = new AnalyticsTimer();\n  private eventBus!: EventBus;\n  private networkTestManager!: NetworkTestManager;\n  private wakeLockManager!: WakeLockManager;\n  private sessionStore!: SessionStore;\n  private interactivityCenter!: InteractivityCenter;\n  private sdkState = { ...INITIAL_STATE };\n  private frameworkInfo?: HMSFrameworkInfo;\n\n  private initNotificationManager() {\n    if (!this.notificationManager) {\n      this.notificationManager = new NotificationManager(\n        this.store,\n        this.eventBus,\n        this.transport!,\n        this.listener,\n        this.audioListener,\n      );\n    }\n  }\n\n  private initStoreAndManagers() {\n    if (this.sdkState.isInitialised) {\n      /**\n       * Set listener after both join and preview, since they can have different listeners\n       */\n      this.notificationManager?.setListener(this.listener);\n      this.audioSinkManager.setListener(this.listener);\n      this.interactivityCenter.setListener(this.listener);\n      return;\n    }\n\n    this.sdkState.isInitialised = true;\n    this.store = new Store();\n    this.eventBus = new EventBus();\n    this.wakeLockManager = new WakeLockManager();\n    this.networkTestManager = new NetworkTestManager(this.eventBus, this.listener);\n    this.playlistManager = new PlaylistManager(this, this.eventBus);\n    this.deviceManager = new DeviceManager(this.store, this.eventBus);\n    this.audioSinkManager = new AudioSinkManager(this.store, this.deviceManager, this.eventBus);\n    this.audioOutput = new AudioOutputManager(this.deviceManager, this.audioSinkManager);\n    this.audioSinkManager.setListener(this.listener);\n    this.eventBus.autoplayError.subscribe(this.handleAutoplayError);\n    this.localTrackManager = new LocalTrackManager(\n      this.store,\n      this.observer,\n      this.deviceManager,\n      this.eventBus,\n      this.analyticsTimer,\n    );\n    this.analyticsEventsService = new AnalyticsEventsService(this.store);\n    this.transport = new HMSTransport(\n      this.observer,\n      this.deviceManager,\n      this.store,\n      this.eventBus,\n      this.analyticsEventsService,\n      this.analyticsTimer,\n    );\n    this.sessionStore = new SessionStore(this.transport);\n    this.interactivityCenter = new InteractivityCenter(this.transport, this.store, this.listener);\n\n    /**\n     * Note: Subscribe to events here right after creating stores and managers\n     * to not miss events that are published before the handlers are subscribed.\n     */\n    this.eventBus.analytics.subscribe(this.sendAnalyticsEvent);\n    this.eventBus.deviceChange.subscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.subscribe(this.handleAudioPluginError);\n  }\n\n  private validateJoined(name: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, `Not connected - ${name}`);\n    }\n  }\n\n  // @ts-ignore\n  private sendHLSAnalytics(error: HMSException) {\n    this.sendAnalyticsEvent(AnalyticsEventFactory.hlsPlayerError(error));\n  }\n\n  async refreshDevices() {\n    this.validateJoined('refreshDevices');\n    await this.deviceManager.init(true);\n  }\n\n  getWebrtcInternals() {\n    return this.transport?.getWebrtcInternals();\n  }\n\n  getSessionStore() {\n    return this.sessionStore;\n  }\n\n  getPlaylistManager(): PlaylistManager {\n    return this.playlistManager;\n  }\n\n  getRecordingState() {\n    return this.store.getRoom()?.recording;\n  }\n\n  getRTMPState() {\n    return this.store.getRoom()?.rtmp;\n  }\n\n  getHLSState() {\n    return this.store.getRoom()?.hls;\n  }\n\n  getTemplateAppData() {\n    return this.store.getTemplateAppData();\n  }\n\n  getInteractivityCenter() {\n    return this.interactivityCenter;\n  }\n\n  private handleAutoplayError = (error: HMSException) => {\n    this.errorListener?.onError?.(error);\n  };\n\n  private get localPeer(): HMSLocalPeer | undefined {\n    return this.store?.getLocalPeer();\n  }\n\n  private observer: ITransportObserver = {\n    onNotification: (message: any) => {\n      if (message.method === HMSNotificationMethod.PEER_LEAVE_REQUEST) {\n        this.handlePeerLeaveRequest(message.params as PeerLeaveRequestNotification);\n        return;\n      }\n\n      switch (message.method) {\n        case HMSNotificationMethod.POLICY_CHANGE:\n          this.analyticsTimer.end(TimedEvent.ON_POLICY_CHANGE);\n          break;\n        case HMSNotificationMethod.PEER_LIST:\n          this.analyticsTimer.end(TimedEvent.PEER_LIST);\n          this.sendJoinAnalyticsEvent(this.sdkState.isPreviewCalled);\n          break;\n        case HMSNotificationMethod.ROOM_STATE:\n          this.analyticsTimer.end(TimedEvent.ROOM_STATE);\n          break;\n        default:\n      }\n\n      this.notificationManager?.handleNotification(message, this.sdkState.isReconnecting);\n    },\n\n    onConnected: () => {\n      this.initNotificationManager();\n    },\n\n    onTrackAdd: (track: HMSRemoteTrack) => {\n      this.notificationManager?.handleTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSRemoteTrack) => {\n      this.notificationManager?.handleTrackRemove(track);\n    },\n\n    onFailure: (exception: HMSException) => {\n      this.errorListener?.onError(exception);\n    },\n\n    onStateChange: async (state: TransportState, error?: HMSException) => {\n      const handleFailedState = async (error?: HMSException) => {\n        await this.internalLeave(true, error);\n        /**\n         * no need to call onError here when preview/join is in progress\n         * since preview/join will call onError when they receive leave event from the above call\n         */\n        if (!this.sdkState.isPreviewInProgress && !this.sdkState.isJoinInProgress) {\n          this.errorListener?.onError?.(error!);\n        }\n        this.sdkState.isReconnecting = false;\n      };\n\n      switch (state) {\n        case TransportState.Preview:\n        case TransportState.Joined:\n          this.initNotificationManager();\n          if (this.transportState === TransportState.Reconnecting) {\n            this.listener?.onReconnected();\n          }\n          break;\n        case TransportState.Failed:\n          await handleFailedState(error);\n          break;\n        case TransportState.Reconnecting:\n          this.sdkState.isReconnecting = true;\n          this.listener?.onReconnecting(error!);\n          break;\n      }\n\n      this.transportState = state;\n      HMSLogger.d(this.TAG, 'Transport State Change', this.transportState);\n    },\n  };\n\n  private handlePeerLeaveRequest = (message: PeerLeaveRequestNotification) => {\n    const peer = message.requested_by ? this.store.getPeerById(message.requested_by) : undefined;\n    const request: HMSLeaveRoomRequest = {\n      roomEnded: message.room_end,\n      reason: message.reason,\n      requestedBy: peer,\n    };\n    this.listener?.onRemovedFromRoom(request);\n    this.internalLeave(false);\n  };\n\n  async preview(config: HMSPreviewConfig, listener: HMSPreviewListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      return Promise.reject(\n        ErrorFactory.GenericErrors.PreviewAlreadyInProgress(HMSAction.PREVIEW, 'Preview already called'),\n      );\n    }\n\n    if ([TransportState.Joined, TransportState.Reconnecting].includes(this.transportState)) {\n      return this.midCallPreview(config.asRole, config.settings);\n    }\n\n    this.analyticsTimer.start(TimedEvent.PREVIEW);\n    this.setUpPreview(config, listener);\n\n    // Request permissions and populate devices before waiting for policy\n    if (config.alwaysRequestPermissions) {\n      this.localTrackManager.requestPermissions().then(async () => {\n        await this.initDeviceManagers();\n      });\n    }\n\n    let initSuccessful = false;\n    let networkTestFinished = false;\n    const timerId = setTimeout(() => {\n      // If init or network is not done by 3s send -1\n      if (!initSuccessful || !networkTestFinished) {\n        this.listener?.onNetworkQuality?.(-1);\n      }\n    }, 3000);\n    return new Promise<void>((resolve, reject) => {\n      const policyHandler = async () => {\n        if (this.localPeer) {\n          const newRole = config.asRole && this.store.getPolicyForRole(config.asRole);\n          this.localPeer.asRole = newRole || this.localPeer.role;\n        }\n        const tracks = await this.localTrackManager.getTracksToPublish(config.settings);\n        tracks.forEach(track => this.setLocalPeerTrack(track));\n        this.localPeer?.audioTrack && this.initPreviewTrackAudioLevelMonitor();\n        await this.initDeviceManagers();\n        this.sdkState.isPreviewInProgress = false;\n        this.analyticsTimer.end(TimedEvent.PREVIEW);\n        const room = this.store.getRoom();\n        if (room) {\n          listener.onPreview(room, tracks);\n        }\n        this.sendPreviewAnalyticsEvent();\n        resolve();\n      };\n\n      const errorHandler = (ex?: HMSException) => {\n        this.analyticsTimer.end(TimedEvent.PREVIEW);\n        ex && this.errorListener?.onError(ex);\n        this.sendPreviewAnalyticsEvent(ex);\n        this.sdkState.isPreviewInProgress = false;\n        reject(ex as HMSException);\n      };\n\n      this.eventBus.policyChange.subscribeOnce(policyHandler);\n      this.eventBus.leave.subscribeOnce(errorHandler);\n\n      this.transport\n        .preview(\n          config.authToken,\n          config.initEndpoint!,\n          this.localPeer!.peerId,\n          { name: config.userName, metaData: config.metaData || '' },\n          config.autoVideoSubscribe,\n        )\n        .then((initConfig: InitConfig | void) => {\n          initSuccessful = true;\n          clearTimeout(timerId);\n          if (initConfig && config.captureNetworkQualityInPreview) {\n            this.networkTestManager.start(initConfig.config?.networkHealth).then(() => {\n              networkTestFinished = true;\n            });\n          }\n        })\n        .catch(errorHandler);\n    });\n  }\n\n  private async midCallPreview(asRole?: string, settings?: InitialSettings): Promise<void> {\n    if (!this.localPeer || this.transportState !== TransportState.Joined) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'Not connected - midCallPreview');\n    }\n\n    const newRole = asRole && this.store.getPolicyForRole(asRole);\n    if (!newRole) {\n      throw ErrorFactory.GenericErrors.InvalidRole(HMSAction.PREVIEW, `role ${asRole} does not exist in policy`);\n    }\n    this.localPeer.asRole = newRole;\n\n    const tracks = await this.localTrackManager.getTracksToPublish(settings);\n    tracks.forEach(track => this.setLocalPeerTrack(track));\n    this.localPeer?.audioTrack && this.initPreviewTrackAudioLevelMonitor();\n    await this.initDeviceManagers();\n\n    this.listener?.onPreview(this.store.getRoom()!, tracks);\n  }\n\n  async cancelMidCallPreview() {\n    if (!this.localPeer || !this.localPeer.isInPreview()) {\n      HMSLogger.w(this.TAG, 'Cannot cancel mid call preview as preview is not in progress');\n    }\n\n    if (this.localPeer?.asRole && this.localPeer.role) {\n      const oldRole = this.localPeer.asRole;\n      const newRole = this.localPeer.role;\n      delete this.localPeer.asRole;\n      await this.roleChangeManager?.diffRolesAndPublishTracks({\n        oldRole,\n        newRole,\n      });\n\n      this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, this.localPeer);\n    }\n  }\n\n  private handleDeviceChange = (event: HMSDeviceChangeEvent) => {\n    HMSLogger.d(this.TAG, 'Device Change event', event);\n    this.deviceChangeListener?.onDeviceChange?.(event);\n    if (event.error && event.type) {\n      const track = event.type.includes('audio') ? this.localPeer?.audioTrack : this.localPeer?.videoTrack;\n      this.errorListener?.onError(event.error);\n      if (\n        [\n          ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n          ErrorCodes.TracksErrors.DEVICE_IN_USE,\n          ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        ].includes(event.error.code) &&\n        track\n      ) {\n        track.setEnabled(false);\n        this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, this.localPeer!);\n      }\n    }\n  };\n\n  private handleAudioPluginError = (error: HMSException) => {\n    HMSLogger.e(this.TAG, 'Audio Plugin Error event', error);\n    this.errorListener?.onError(error);\n  };\n\n  async join(config: HMSConfig, listener: HMSUpdateListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      throw ErrorFactory.GenericErrors.NotReady(HMSAction.JOIN, \"Preview is in progress, can't join\");\n    }\n\n    this.analyticsTimer.start(TimedEvent.JOIN);\n    this.sdkState.isJoinInProgress = true;\n\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    const previewRole = this.localPeer?.asRole?.name || this.localPeer?.role?.name;\n    this.networkTestManager?.stop();\n    this.listener = listener;\n    this.commonSetup(config, roomId, listener);\n    this.removeDevicesFromConfig(config);\n    this.store.setConfig(config);\n    /** set after config since we need config to get env for user agent */\n    this.store.createAndSetUserAgent(this.frameworkInfo);\n    HMSAudioContextHandler.resumeContext();\n    // acquire screen lock to stay awake while in call\n    const storeConfig = this.store.getConfig();\n    if (storeConfig?.autoManageWakeLock) {\n      this.wakeLockManager.acquireLock();\n    }\n\n    if (!this.localPeer) {\n      this.createAndAddLocalPeerToStore(config, role, userId);\n    } else {\n      this.localPeer.name = config.userName;\n      this.localPeer.role = this.store.getPolicyForRole(role);\n      this.localPeer.customerUserId = userId;\n      this.localPeer.metadata = config.metaData;\n      delete this.localPeer.asRole;\n    }\n\n    this.roleChangeManager = new RoleChangeManager(\n      this.store,\n      this.transport,\n      this.deviceManager,\n      this.getAndPublishTracks.bind(this),\n      this.removeTrack.bind(this),\n      this.listener,\n    );\n    this.eventBus.localRoleUpdate.subscribe(this.handleLocalRoleUpdate);\n\n    HMSLogger.d(this.TAG, `\u23F3 Joining room ${roomId}`);\n\n    HMSLogger.time(`join-room-${roomId}`);\n\n    try {\n      await this.transport.join(\n        config.authToken,\n        this.localPeer!.peerId,\n        { name: config.userName, metaData: config.metaData! },\n        config.initEndpoint!,\n        config.autoVideoSubscribe,\n      );\n      HMSLogger.d(this.TAG, `\u2705 Joined room ${roomId}`);\n      this.analyticsTimer.start(TimedEvent.PEER_LIST);\n      await this.notifyJoin();\n      this.sdkState.isJoinInProgress = false;\n      await this.publish(config.settings, previewRole);\n    } catch (error) {\n      this.analyticsTimer.end(TimedEvent.JOIN);\n      this.sdkState.isJoinInProgress = false;\n      this.listener?.onError(error as HMSException);\n      this.sendJoinAnalyticsEvent(this.sdkState.isPreviewCalled, error as HMSException);\n      HMSLogger.e(this.TAG, 'Unable to join room', error);\n      throw error;\n    }\n    HMSLogger.timeEnd(`join-room-${roomId}`);\n  }\n\n  private stringifyMetadata(config: HMSConfig) {\n    if (config.metaData && typeof config.metaData !== 'string') {\n      config.metaData = JSON.stringify(config.metaData);\n    } else if (!config.metaData) {\n      config.metaData = '';\n    }\n  }\n\n  private cleanup() {\n    this.cleanDeviceManagers();\n    this.eventBus.analytics.unsubscribe(this.sendAnalyticsEvent);\n    this.analyticsTimer.cleanup();\n    DeviceStorageManager.cleanup();\n    this.playlistManager.cleanup();\n    this.wakeLockManager?.cleanup();\n    LocalTrackManager.cleanup();\n    this.notificationManager = undefined;\n    HMSLogger.cleanup();\n    this.sdkState = { ...INITIAL_STATE };\n    /**\n     * when leave is called after preview itself without join.\n     * Store won't have the tracks in this case\n     */\n    if (this.localPeer) {\n      this.localPeer.audioTrack?.cleanup();\n      this.localPeer.audioTrack = undefined;\n      this.localPeer.videoTrack?.cleanup();\n      this.localPeer.videoTrack = undefined;\n    }\n    this.store.cleanup();\n    this.listener = undefined;\n    if (this.roleChangeManager) {\n      this.eventBus.localRoleUpdate.unsubscribe(this.handleLocalRoleUpdate);\n    }\n  }\n\n  leave(notifyServer?: boolean) {\n    return this.internalLeave(notifyServer);\n  }\n\n  private async internalLeave(notifyServer = true, error?: HMSException) {\n    const room = this.store?.getRoom();\n    if (room) {\n      const roomId = room.id;\n      this.networkTestManager?.stop();\n      this.eventBus.leave.publish(error);\n      HMSLogger.d(this.TAG, `\u23F3 Leaving room ${roomId}`);\n      // browsers often put limitation on amount of time a function set on window onBeforeUnload can take in case of\n      // tab refresh or close. Therefore prioritise the leave action over anything else, if tab is closed/refreshed\n      // we would want leave to succeed to stop stucked peer for others. The followup cleanup however is important\n      // for cases where uses stays on the page post leave.\n      await this.transport?.leave(notifyServer);\n      this.cleanup();\n      HMSLogger.d(this.TAG, `\u2705 Left room ${roomId}`);\n    }\n  }\n\n  async getAuthTokenByRoomCode(tokenRequest: TokenRequest, tokenRequestOptions?: TokenRequestOptions): Promise<string> {\n    const tokenAPIURL = (tokenRequestOptions || {}).endpoint || 'https://auth.100ms.live/v2/token';\n    this.analyticsTimer.start(TimedEvent.GET_TOKEN);\n    const response = await fetchWithRetry(\n      tokenAPIURL,\n      {\n        method: 'POST',\n        body: JSON.stringify({ code: tokenRequest.roomCode, user_id: tokenRequest.userId }),\n      },\n      [429, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511],\n    );\n\n    const data = await response.json();\n    this.analyticsTimer.end(TimedEvent.GET_TOKEN);\n\n    if (!response.ok) {\n      throw ErrorFactory.APIErrors.ServerErrors(data.code, HMSAction.GET_TOKEN, data.message, false);\n    }\n\n    const { token } = data;\n    if (!token) {\n      throw Error(data.message);\n    }\n    return token;\n  }\n\n  getLocalPeer() {\n    return this.store.getLocalPeer();\n  }\n\n  getPeers() {\n    return this.store.getPeers();\n  }\n\n  getPeerMap() {\n    return this.store.getPeerMap();\n  }\n\n  getAudioOutput() {\n    return this.audioOutput;\n  }\n\n  sendMessage(type: string, message: string) {\n    this.sendMessageInternal({ message, type });\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    return await this.sendMessageInternal({ message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: HMSRole[], type?: string) {\n    const knownRoles = this.store.getKnownRoles();\n    const recipientRoles =\n      roles.filter(role => {\n        return knownRoles[role.name];\n      }) || [];\n    if (recipientRoles.length === 0) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No valid role is present', roles);\n    }\n    return await this.sendMessageInternal({ message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peer: HMSPeer, type?: string) {\n    const recipientPeer = this.store.getPeerById(peer.peerId);\n    if (!recipientPeer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer - peer not present in the room', peer);\n    }\n    if (this.localPeer?.peerId === peer.peerId) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Cannot send message to self');\n    }\n    return await this.sendMessageInternal({ message, recipientPeer: peer, type });\n  }\n\n  private async sendMessageInternal({ recipientRoles, recipientPeer, type = 'chat', message }: HMSMessageInput) {\n    if (message.replace(/\\u200b/g, ' ').trim() === '') {\n      HMSLogger.w(this.TAG, 'sendMessage', 'Ignoring empty message send');\n      throw ErrorFactory.GenericErrors.ValidationFailed('Empty message not allowed');\n    }\n    const hmsMessage = new Message({\n      sender: this.localPeer!,\n      type,\n      message,\n      recipientPeer,\n      recipientRoles,\n      time: new Date(),\n    });\n    HMSLogger.d(this.TAG, 'Sending Message: ', hmsMessage);\n    const response = await this.transport.sendMessage(hmsMessage);\n    hmsMessage.time = new Date(response.timestamp);\n    hmsMessage.id = response.message_id;\n    return hmsMessage;\n  }\n\n  async startScreenShare(onStop: () => void, config?: HMSScreenShareConfig) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams) {\n      return;\n    }\n\n    const { allowed } = publishParams;\n    const canPublishScreen = allowed && allowed.includes('screen');\n\n    if (!canPublishScreen) {\n      HMSLogger.e(this.TAG, `Role ${this.localPeer?.role} cannot share screen`);\n      return;\n    }\n\n    if (this.localPeer?.auxiliaryTracks?.find(track => track.source === 'screen')) {\n      throw Error('Cannot share multiple screens');\n    }\n\n    const tracks = await this.getScreenshareTracks(onStop, config);\n    if (!this.localPeer) {\n      HMSLogger.d(this.TAG, 'Screenshared when not connected');\n      tracks.forEach(track => {\n        track.cleanup();\n      });\n      return;\n    }\n    await this.transport.publish(tracks);\n    tracks.forEach(track => {\n      track.peerId = this.localPeer?.peerId;\n      this.localPeer?.auxiliaryTracks.push(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    });\n  }\n\n  private async stopEndedScreenshare(onStop: () => void) {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended natively`);\n    await this.stopScreenShare();\n    onStop();\n  }\n\n  async stopScreenShare() {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended from app`);\n    const screenTracks = this.localPeer?.auxiliaryTracks.filter(t => t.source === 'screen');\n    if (screenTracks) {\n      for (const track of screenTracks) {\n        await this.removeTrack(track.trackId);\n      }\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, source: HMSTrackSource = 'regular'): Promise<void> {\n    if (!track) {\n      HMSLogger.w(this.TAG, 'Please pass a valid MediaStreamTrack');\n      return;\n    }\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot addTrack');\n    }\n    const isTrackPresent = this.localPeer.auxiliaryTracks.find(t => t.trackId === track.id);\n    if (isTrackPresent) {\n      return;\n    }\n\n    const type = track.kind;\n    const nativeStream = new MediaStream([track]);\n    const stream = new HMSLocalStream(nativeStream);\n\n    const TrackKlass = type === 'audio' ? HMSLocalAudioTrack : HMSLocalVideoTrack;\n    const hmsTrack = new TrackKlass(stream, track, source, this.eventBus);\n    this.setPlaylistSettings({\n      track,\n      hmsTrack,\n      source,\n    });\n\n    await this.transport?.publish([hmsTrack]);\n    hmsTrack.peerId = this.localPeer?.peerId;\n    this.localPeer?.auxiliaryTracks.push(hmsTrack);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer!);\n  }\n\n  async removeTrack(trackId: string, internal = false) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot removeTrack');\n    }\n    const trackIndex = this.localPeer.auxiliaryTracks.findIndex(t => t.trackId === trackId);\n    if (trackIndex > -1) {\n      const track = this.localPeer.auxiliaryTracks[trackIndex];\n      if (track.isPublished) {\n        await this.transport!.unpublish([track]);\n      } else {\n        await track.cleanup();\n      }\n      // Stop local playback when playlist track is removed\n      if (!internal) {\n        this.stopPlaylist(track);\n      }\n      this.localPeer.auxiliaryTracks.splice(trackIndex, 1);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, this.localPeer);\n    } else {\n      HMSLogger.w(this.TAG, `No track found for ${trackId}`);\n    }\n  }\n\n  setAnalyticsLevel(level: HMSAnalyticsLevel) {\n    this.analyticsEventsService.level = level;\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n  }\n\n  addAudioListener(audioListener: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.notificationManager?.setAudioListener(audioListener);\n  }\n\n  addConnectionQualityListener(qualityListener: HMSConnectionQualityListener) {\n    this.notificationManager?.setConnectionQualityListener(qualityListener);\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeer(forPeer, toRole, force);\n  }\n\n  async changeRoleOfPeer(forPeer: HMSPeer, toRole: string, force = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeer(forPeer, toRole, force);\n  }\n\n  async changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string) {\n    if (roles.length <= 0 || !toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeersWithRoles(roles, toRole);\n  }\n\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    await this.transport?.acceptRoleChange(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot end room');\n    }\n    await this.transport?.endRoom(lock, reason);\n    await this.leave();\n  }\n\n  async removePeer(peer: HMSRemotePeer, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot remove peer');\n    }\n\n    if (!this.store.getPeerById(peer.peerId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer, given peer not present in room', peer);\n    }\n    await this.transport?.removePeer(peer.peerId, reason);\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start streaming or recording',\n      );\n    }\n    await this.transport?.startRTMPOrRecording(params);\n  }\n\n  async stopRTMPAndRecording() {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop streaming or recording',\n      );\n    }\n    await this.transport?.stopRTMPOrRecording();\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start HLS streaming',\n      );\n    }\n    await this.transport?.startHLSStreaming(params);\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop HLS streaming',\n      );\n    }\n    await this.transport?.stopHLSStreaming(params);\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    this.validateJoined('sendHLSTimedMetadata');\n    await this.transport?.sendHLSTimedMetadata(metadataList);\n  }\n\n  async changeName(name: string) {\n    this.validateJoined('changeName');\n    await this.transport?.changeName(name);\n    this.notificationManager?.updateLocalPeer({ name });\n  }\n\n  async changeMetadata(metadata: string) {\n    this.validateJoined('changeMetadata');\n    await this.transport?.changeMetadata(metadata);\n    this.notificationManager?.updateLocalPeer({ metadata });\n  }\n\n  async setSessionMetadata(metadata: any) {\n    await this.transport.setSessionMetadata({ key: 'default', data: metadata });\n  }\n\n  async getSessionMetadata() {\n    const response = await this.transport.getSessionMetadata('default');\n    return response.data;\n  }\n\n  getRoles(): HMSRole[] {\n    return Object.values(this.store.getKnownRoles());\n  }\n\n  async changeTrackState(forRemoteTrack: HMSRemoteTrack, enabled: boolean) {\n    if (forRemoteTrack.type === HMSTrackType.VIDEO && forRemoteTrack.source !== 'regular') {\n      HMSLogger.w(this.TAG, `Muting non-regular video tracks is currently not supported`);\n      return;\n    }\n\n    if (forRemoteTrack.enabled === enabled) {\n      HMSLogger.w(this.TAG, `Aborting change track state, track already has enabled - ${enabled}`, forRemoteTrack);\n      return;\n    }\n\n    if (!this.store.getTrackById(forRemoteTrack.trackId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No track found for change track state', forRemoteTrack);\n    }\n\n    const peer = this.store.getPeerByTrackId(forRemoteTrack.trackId);\n\n    if (!peer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No peer found for change track state', forRemoteTrack);\n    }\n\n    await this.transport?.changeTrackState({\n      requested_for: peer.peerId,\n      track_id: forRemoteTrack.trackId,\n      stream_id: forRemoteTrack.stream.id,\n      mute: !enabled,\n    });\n  }\n\n  async changeMultiTrackState(params: HMSChangeMultiTrackStateParams) {\n    if (typeof params.enabled !== 'boolean') {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Pass a boolean for enabled');\n    }\n    const { enabled, roles, type, source } = params;\n    await this.transport?.changeMultiTrackState({\n      value: !enabled,\n      type,\n      source,\n      roles: roles?.map(role => role?.name),\n    });\n  }\n\n  async raiseLocalPeerHand() {\n    this.validateJoined('raiseLocalPeerHand');\n    await this.transport.joinGroup(HAND_RAISE_GROUP_NAME);\n  }\n  async lowerLocalPeerHand() {\n    this.validateJoined('lowerLocalPeerHand');\n    await this.transport.leaveGroup(HAND_RAISE_GROUP_NAME);\n  }\n  async raiseRemotePeerHand(peerId: string) {\n    await this.transport.addToGroup(peerId, HAND_RAISE_GROUP_NAME);\n  }\n  async lowerRemotePeerHand(peerId: string) {\n    await this.transport.addToGroup(peerId, HAND_RAISE_GROUP_NAME);\n  }\n\n  setFrameworkInfo(frameworkInfo: HMSFrameworkInfo) {\n    this.frameworkInfo = { ...this.frameworkInfo, ...frameworkInfo };\n  }\n\n  async attachVideo(track: HMSVideoTrack, videoElement: HTMLVideoElement) {\n    const config = this.store.getConfig();\n    if (config?.autoManageVideo) {\n      track.attach(videoElement);\n    } else {\n      await track.addSink(videoElement);\n    }\n  }\n\n  async detachVideo(track: HMSVideoTrack, videoElement: HTMLVideoElement) {\n    const config = this.store.getConfig();\n    if (config?.autoManageVideo) {\n      track.detach(videoElement);\n    } else {\n      await track.removeSink(videoElement);\n    }\n  }\n\n  private async publish(initialSettings?: InitialSettings, oldRole?: string) {\n    if ([this.store.getPublishParams(), !this.sdkState.published, !isNode].every(value => !!value)) {\n      // if preview asRole(oldRole) is used, use roleChangeManager to diff policy and publish, else do normal publish\n      const publishAction =\n        oldRole && oldRole !== this.localPeer?.role?.name\n          ? () =>\n              this.roleChangeManager?.diffRolesAndPublishTracks({\n                oldRole: this.store.getPolicyForRole(oldRole),\n                newRole: this.localPeer!.role!,\n              })\n          : () => this.getAndPublishTracks(initialSettings);\n\n      await publishAction?.()?.catch(error => {\n        HMSLogger.e(this.TAG, 'Error in publish', error);\n        this.listener?.onError(error);\n      });\n    }\n  }\n\n  private async getAndPublishTracks(initialSettings?: InitialSettings) {\n    const tracks = await this.localTrackManager.getTracksToPublish(initialSettings);\n    await this.setAndPublishTracks(tracks);\n    this.localPeer?.audioTrack?.initAudioLevelMonitor();\n    this.sdkState.published = true;\n  }\n\n  private handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    await this.transport.handleLocalRoleUpdate({ oldRole, newRole });\n    await this.roleChangeManager?.handleLocalPeerRoleUpdate({ oldRole, newRole });\n  };\n\n  private async setAndPublishTracks(tracks: HMSLocalTrack[]) {\n    for (const track of tracks) {\n      await this.transport.publish([track]);\n      this.setLocalPeerTrack(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    }\n    await this.initDeviceManagers();\n  }\n\n  private setLocalPeerTrack(track: HMSLocalTrack) {\n    track.peerId = this.localPeer?.peerId;\n    switch (track.type) {\n      case HMSTrackType.AUDIO:\n        this.localPeer!.audioTrack = track as HMSLocalAudioTrack;\n        break;\n\n      case HMSTrackType.VIDEO:\n        this.localPeer!.videoTrack = track as HMSLocalVideoTrack;\n        break;\n    }\n  }\n\n  private async initDeviceManagers() {\n    // No need to initialise and add listeners if already initialised in preview\n    if (this.sdkState.deviceManagersInitialised) {\n      return;\n    }\n    this.sdkState.deviceManagersInitialised = true;\n    await this.deviceManager.init();\n    if (!(await this.deviceManager.updateOutputDevice(this.store.getConfig()?.settings?.audioOutputDeviceId))) {\n      await this.deviceManager.updateOutputDevice(DeviceStorageManager.getSelection()?.audioOutput?.deviceId);\n    }\n    this.audioSinkManager.init(this.store.getConfig()?.audioSinkElementId);\n  }\n\n  private cleanDeviceManagers() {\n    this.eventBus.deviceChange.unsubscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.unsubscribe(this.handleAudioPluginError);\n    this.eventBus.autoplayError.unsubscribe(this.handleAutoplayError);\n    this.deviceManager.cleanup();\n    this.audioSinkManager.cleanup();\n  }\n\n  private initPreviewTrackAudioLevelMonitor() {\n    const localAudioTrack = this.localPeer?.audioTrack;\n    localAudioTrack?.initAudioLevelMonitor();\n    this.eventBus.trackAudioLevelUpdate.subscribe(audioLevelUpdate => {\n      const hmsSpeakers =\n        audioLevelUpdate && audioLevelUpdate.track.trackId === localAudioTrack?.trackId\n          ? [{ audioLevel: audioLevelUpdate.audioLevel, peer: this.localPeer!, track: localAudioTrack! }]\n          : [];\n      this.store.updateSpeakers(hmsSpeakers);\n      this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    });\n    this.eventBus.localAudioSilence.subscribe(this.sendAudioPresenceFailed);\n  }\n\n  private notifyJoin() {\n    const localPeer = this.store.getLocalPeer();\n    const room = this.store.getRoom();\n    if (!room) {\n      HMSLogger.w(this.TAG, 'notify join - room not present');\n      return;\n    }\n\n    room.joinedAt = new Date();\n    if (localPeer) {\n      localPeer.joinedAt = room.joinedAt;\n    }\n\n    if (localPeer?.role) {\n      this.analyticsTimer.end(TimedEvent.JOIN);\n      this.listener?.onJoin(room);\n      return;\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      this.eventBus.policyChange.subscribeOnce(() => {\n        this.analyticsTimer.end(TimedEvent.JOIN);\n        this.listener?.onJoin(room);\n        resolve();\n      });\n\n      this.eventBus.leave.subscribeOnce(ex => {\n        reject(ex);\n      });\n    });\n  }\n\n  /**\n   * Init store and other managers, setup listeners, create local peer, room\n   * @param {HMSConfig} config\n   * @param {HMSPreviewListener} listener\n   */\n  private setUpPreview(config: HMSPreviewConfig, listener: HMSPreviewListener) {\n    this.listener = listener as unknown as HMSUpdateListener;\n    this.sdkState.isPreviewCalled = true;\n    this.sdkState.isPreviewInProgress = true;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    this.commonSetup(config, roomId, listener);\n    this.store.setConfig(config);\n    /** set after config since we need config to get env for user agent */\n    this.store.createAndSetUserAgent(this.frameworkInfo);\n    this.createAndAddLocalPeerToStore(config, role, userId, config.asRole);\n  }\n\n  /**\n   * Set bitrate and dimensions for playlist track\n   */\n  private async setPlaylistSettings({\n    track,\n    hmsTrack,\n    source,\n  }: {\n    track: MediaStreamTrack;\n    hmsTrack: HMSLocalAudioTrack | HMSLocalVideoTrack;\n    source: string;\n  }) {\n    if (source === 'videoplaylist') {\n      const settings: { maxBitrate?: number; width?: number; height?: number } = {};\n      if (track.kind === 'audio') {\n        settings.maxBitrate = 64;\n      } else {\n        settings.maxBitrate = 1000;\n        const { width, height } = track.getSettings();\n        settings.width = width;\n        settings.height = height;\n      }\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings(settings);\n    } else if (source === 'audioplaylist') {\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings({ maxBitrate: 64 });\n    }\n  }\n\n  /**\n   * @param {HMSConfig} config\n   * @param {string} role\n   * @param {string} userId\n   */\n  private createAndAddLocalPeerToStore(config: HMSConfig, role: string, userId: string, asRole?: string) {\n    const policy = this.store.getPolicyForRole(role);\n    const asRolePolicy = asRole ? this.store.getPolicyForRole(asRole) : undefined;\n    const localPeer = new HMSLocalPeer({\n      name: config.userName || '',\n      customerUserId: userId,\n      metadata: config.metaData || '',\n      role: policy,\n      // default value is the original role if user didn't pass asRole in config\n      asRole: asRolePolicy || policy,\n    });\n\n    this.store.addPeer(localPeer);\n  }\n\n  /**\n   * init managers and set listeners - common for join and preview\n   * @param {HMSConfig} config\n   * @param {string} roomId\n   * @param {HMSPreviewListener | HMSUpdateListener} listener\n   */\n  private commonSetup(config: HMSConfig, roomId: string, listener: HMSPreviewListener | HMSUpdateListener) {\n    this.stringifyMetadata(config);\n    if (!config.initEndpoint) {\n      config.initEndpoint = 'https://prod-init.100ms.live';\n    }\n    this.errorListener = listener;\n    this.deviceChangeListener = listener;\n    this.initStoreAndManagers();\n\n    this.store.setErrorListener(this.errorListener);\n    if (!this.store.getRoom()) {\n      this.store.setRoom(new HMSRoom(roomId));\n    }\n  }\n\n  /**\n   * Remove deviceId's passed in config for join if preview was already called\n   * @param {HMSConfig} config\n   */\n  private removeDevicesFromConfig(config: HMSConfig) {\n    const storedConfig = this.store.getConfig();\n    if (storedConfig && config.settings) {\n      // preview was called\n      delete config.settings.audioOutputDeviceId;\n      delete config.settings.videoDeviceId;\n      delete config.settings.audioInputDeviceId;\n    }\n  }\n\n  /**\n   * Get screenshare based on policy and audioOnly flag\n   * @param {function} onStop\n   * @param config\n   * @returns\n   */\n  private async getScreenshareTracks(onStop: () => void, config?: HMSScreenShareConfig) {\n    const [videoTrack, audioTrack] = await this.localTrackManager.getLocalScreen(config);\n\n    const handleEnded = () => {\n      this.stopEndedScreenshare(onStop);\n    };\n\n    const tracks = [];\n    if (config?.audioOnly) {\n      videoTrack.nativeTrack.stop();\n      if (!audioTrack) {\n        throw ErrorFactory.TracksErrors.NothingToReturn(\n          HMSAction.TRACK,\n          'Select share audio when sharing screen',\n          'No audio found',\n        );\n      }\n      tracks.push(audioTrack);\n      audioTrack.nativeTrack.addEventListener('ended', handleEnded);\n    } else {\n      tracks.push(videoTrack);\n      videoTrack.nativeTrack.addEventListener('ended', handleEnded);\n      // audio track is not always available\n      if (audioTrack) {\n        tracks.push(audioTrack);\n      }\n    }\n    return tracks;\n  }\n\n  private sendAudioPresenceFailed = () => {\n    const error = ErrorFactory.TracksErrors.NoAudioDetected(HMSAction.PREVIEW);\n    HMSLogger.w(this.TAG, 'Audio Presence Failure', this.transportState, error);\n    // this.sendAnalyticsEvent(\n    //   AnalyticsEventFactory.audioDetectionFail(error, this.deviceManager.getCurrentSelection().audioInput),\n    // );\n    // this.listener?.onError(error);\n  };\n\n  private sendJoinAnalyticsEvent = (is_preview_called = false, error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.join({\n        error,\n        ...this.analyticsTimer.getTimes(),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n        is_preview_called,\n        retries_join: this.transport.joinRetryCount,\n      }),\n    );\n  };\n\n  private sendPreviewAnalyticsEvent = (error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.preview({\n        error,\n        ...this.analyticsTimer.getTimes(),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.PREVIEW),\n      }),\n    );\n  };\n\n  private sendAnalyticsEvent = (event: AnalyticsEvent) => {\n    this.analyticsEventsService.queue(event).flush();\n  };\n\n  private stopPlaylist(track: HMSLocalTrack) {\n    if (track.source === 'audioplaylist') {\n      this.playlistManager.stop(HMSPlaylistType.audio);\n    } else if (track.source === 'videoplaylist') {\n      this.playlistManager.stop(HMSPlaylistType.video);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_package", "__commonJSMin", "exports", "module", "src_exports", "__export", "DeviceType", "ENV", "HMSAudioCodec", "HMSAudioContextHandler", "HMSAudioPluginType", "HMSAudioPluginsManager", "HMSAudioTrack", "HMSException", "HMSFacingMode", "HMSLocalAudioTrack", "HMSLocalStream", "HMSLocalVideoTrack", "HMSLogLevel", "HMSMediaStream", "HMSPeerUpdate", "HMSPlaylistType", "HMSPluginUnsupportedTypes", "HMSPollQuestionType", "HMSPollsUpdate", "HMSRemoteAudioTrack", "HMSRemoteStream", "HMSRemoteVideoTrack", "HMSRoomUpdate", "HMSSdk", "HMSSimulcastLayer", "HMSTrack", "HMSTrackType", "HMSTrackUpdate", "HMSVideoCodec", "HMSVideoPluginCanvasContextType", "HMSVideoPluginType", "HMSVideoPluginsManager", "HMSVideoTrack", "HMSWebrtcInternals", "HMSWebrtcStats", "getLocalDevices", "getLocalScreen", "getLocalStream", "isBrowser", "isIOS", "isMobile", "isNode", "isPageHidden", "isSupported", "parsedUserAgent", "simulcastMapping", "validateDeviceAV", "__toCommonJS", "Message", "sender", "message", "type", "recipientPeer", "recipientRoles", "time", "id", "_a", "_b", "roles", "role", "peer", "sendParams", "Room", "id", "RENEGOTIATION_CALLBACK_ID", "API_DATA_CHANNEL", "SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID", "CLIENT_ANAYLTICS_PROD_ENDPOINT", "CLIENT_ANAYLTICS_QA_ENDPOINT", "HMSEvents", "PROTOCOL_VERSION", "PROTOCOL_SPEC", "HAND_RAISE_GROUP_NAME", "HMSPeer", "peerId", "name", "isLocal", "customerUserId", "metadata", "role", "joinedAt", "groups", "realtime", "_a", "HAND_RAISE_GROUP_NAME", "newRole", "newName", "quality", "data", "_b", "_c", "_d", "import_uuid", "HMSIdFactory", "uuidv4", "HMSLocalPeer", "HMSPeer", "peerData", "__spreadProps", "__spreadValues", "HMSIdFactory", "_a", "_b", "_c", "HMSRemotePeer", "HMSPeer", "peerData", "__spreadProps", "__spreadValues", "import_uuid", "import_uuid", "import_ua_parser_js", "parsedUserAgent", "isBrowser", "_a", "isNode", "ENV", "checkIsSupported", "isSupported", "isMobile", "isPageHidden", "isIOS", "getDomainCategory", "isBrowser", "baseurl", "domainCategory", "import_uuid", "LocalStorage", "key", "val", "i", "initializeLocalstoragePolyfill", "isBrowser", "LocalStorage", "key", "isBrowser", "initializeLocalstoragePolyfill", "_a", "stringItem", "value", "stringValue", "getAnalyticsDeviceId", "id", "storage", "LocalStorage", "storageId", "uuid", "HMSLogLevel", "isTestEnv", "HMSLogger", "tag", "data", "mark", "level", "entry", "error", "ErrorCodes", "HMSException", "_HMSException", "code", "name", "action", "message", "description", "isTerminal", "error", "_a", "convertSignalMethodtoErrorAction", "method", "terminalActions", "ErrorFactory", "action", "description", "HMSException", "ErrorCodes", "code", "isTerminal", "deviceInfo", "message", "jsonMessage", "entity", "TAG", "isPresent", "value", "validateRTCPeerConnection", "error", "ErrorFactory", "HMSLogger", "validateMediaDevicesExistence", "sdk_version", "createUserAgent", "sdkEnv", "frameworkInfo", "sdk", "env", "domainCategory", "isNode", "convertObjectToString", "parsedOs", "parsedUserAgent", "parsedDevice", "parsedBrowser", "os", "replaceSpaces", "os_version", "browser", "device_model", "s", "object", "delimiter", "key", "isPresent", "AnalyticsEvent", "name", "level", "properties", "includesPII", "timestamp", "createUserAgent", "uuid", "getAnalyticsDeviceId", "__spreadProps", "__spreadValues", "domainCategory", "AnalyticsEventFactory", "error", "additionalProperties", "requestedAt", "respondedAt", "endpoint", "name", "level", "properties", "__spreadProps", "__spreadValues", "AnalyticsEvent", "_a", "_b", "props", "__objRest", "_c", "_d", "devices", "settings", "selection", "type", "stats", "track", "isDegraded", "restoredAt", "duration", "device", "ok", "initialProperties", "errorProperties", "HMSException", "defaultEventNames", "AnalyticsTimer", "eventName", "_a", "HMSLogger", "error", "eventNames", "timeObject", "__spreadProps", "__spreadValues", "import_webrtc_adapter", "getDefaultError", "error", "deviceInfo", "message", "ErrorFactory", "convertMediaErrorToHMSException", "err", "adapter", "hmsError", "BuildGetMediaError", "exception", "import_webrtc_adapter", "HMSMediaStream", "nativeStream", "id", "stringifyMediaStreamTrack", "track", "HMSTrack", "stream", "track", "source", "value", "__async", "sdpTrackId", "trackId", "_a", "HMSLogger", "stringifyMediaStreamTrack", "HMSTrackType", "HMSAudioTrack", "HMSTrack", "stream", "track", "source", "value", "__async", "element", "HMSLogger", "device", "_a", "error", "HMSRemoteStream", "DeviceStorage", "LocalStorage", "devices", "value", "type", "deviceId", "groupId", "newSelection", "device", "HMSLogger", "selectedDevices", "current", "DeviceStorageManager", "HMSAudioPluginType", "HMSPluginUnsupportedTypes", "MediaPluginsAnalyticsFactory", "pluginName", "error", "name", "level", "properties", "__spreadValues", "AnalyticsEvent", "sampleRate", "duration", "loadTime", "avgPreProcessingTime", "avgProcessingTime", "inputFrameRate", "pluginFrameRate", "AudioPluginsAnalytics", "eventBus", "name", "sampleRate", "stats", "MediaPluginsAnalyticsFactory", "error", "initFn", "__async", "HMSLogger", "time", "e", "err", "ErrorFactory", "fn", "start", "DEFAULT_SAMPLE_RATE", "checkBrowserSupport", "HMSAudioPluginsManager", "track", "eventBus", "AudioPluginsAnalytics", "plugin", "__async", "_a", "name", "HMSLogger", "err", "ErrorFactory", "result", "_b", "_c", "plugins", "audioStream", "currentNode", "getAudioTrack", "settings", "__async", "err", "BuildGetMediaError", "getVideoTrack", "isEmptyTrack", "track", "getLocalStream", "constraints", "__async", "err", "BuildGetMediaError", "getLocalScreen", "getLocalDevices", "devices", "deviceGroups", "device", "HMSAudioContextHandler", "error", "HMSLogger", "Queue", "capacity", "item", "aggregationFn", "sleep", "ms", "resolve", "debounce", "fn", "delay", "timer", "args", "context", "THRESHOLD", "UPDATE_THRESHOLD", "TrackAudioLevelMonitor", "track", "audioLevelEvent", "silenceEvent", "Queue", "__async", "silenceCounter", "sleep", "stream", "ex", "HMSLogger", "audioLevel", "audioLevelUpdate", "newLevel", "values", "data", "lowest", "max", "frequency", "normalized", "audioContext", "HMSAudioContextHandler", "analyser", "HMSRoomUpdate", "HMSPeerUpdate", "HMSTrackUpdate", "HMSPollsUpdate", "HMSSimulcastLayer", "simulcastMapping", "HMSVideoCodec", "HMSAudioCodec", "HMSFacingMode", "DeviceType", "HMSPlaylistType", "HMSPollQuestionType", "HMSAudioTrackSettingsBuilder", "volume", "codec", "maxBitrate", "deviceId", "advanced", "HMSAudioTrackSettings", "HMSVideoTrackSettingsBuilder", "width", "height", "codec", "maxFramerate", "maxBitrate", "useDefault", "deviceId", "advanced", "mode", "HMSVideoTrackSettings", "facingMode", "isScreenShare", "dimensionConstraintKey", "aspectRatio", "isMobile", "HMSTrackSettingsBuilder", "HMSVideoTrackSettingsBuilder", "HMSAudioTrackSettingsBuilder", "video", "audio", "screen", "enabled", "ErrorFactory", "HMSTrackSettings", "simulcast", "properties", "__spreadValues", "generateHasPropertyChanged", "newSettings", "oldSettings", "prop", "HMSLocalAudioTrack", "_HMSLocalAudioTrack", "HMSAudioTrack", "stream", "track", "source", "eventBus", "settings", "HMSAudioTrackSettingsBuilder", "__async", "hasPropertyChanged", "internal", "DeviceStorageManager", "isEmptyTrack", "HMSAudioPluginsManager", "isIOS", "isBrowser", "prevTrack", "isLevelMonitored", "newTrack", "getAudioTrack", "HMSLogger", "localStream", "e", "value", "__superGet", "trackId", "plugin", "processedTrack", "TrackAudioLevelMonitor", "_a", "volume", "codec", "maxBitrate", "deviceId", "advanced", "__spreadValues", "HMSAudioTrackSettings", "HMSRemoteAudioTrack", "_HMSRemoteAudioTrack", "HMSAudioTrack", "value", "__async", "__superGet", "HMSVideoTrack", "HMSTrack", "stream", "track", "source", "videoHandler", "videoElement", "srcObject", "existingTrack", "import_uuid", "layerToIntMapping", "DELTA_THRESHOLD", "getClosestLayer", "simulcastLayers", "videoElementDimensions", "closestLayer", "maxDimension", "layers", "b", "videoDimesion", "i", "resolution", "layer", "layerDimension", "nextLayer", "nextLayerDimension", "HMSIntersectionObserverWrapper", "element", "onIntersection", "_a", "entries", "entry", "isSupported", "isBrowser", "HMSLogger", "HMSIntersectionObserver", "HMSResizeObserverWrapper", "element", "onResize", "options", "_a", "debounce", "entries", "entry", "isSupported", "isBrowser", "HMSLogger", "HMSResizeObserver", "VideoElementManager", "track", "entry", "__async", "isVisibile", "HMSLogger", "HMSRemoteVideoTrack", "videoElement", "_a", "_b", "uuid", "requestLayer", "isBrowser", "HMSResizeObserver", "HMSIntersectionObserver", "el", "top", "left", "width", "height", "hidden", "opacity", "display", "maxLayer", "element", "layer", "getClosestLayer", "layerToIntMapping", "HMSVideoPluginType", "HMSVideoPluginCanvasContextType", "RunningAverage", "item", "VideoPluginsAnalytics", "eventBus", "RunningAverage", "name", "inputFrameRate", "pluginFrameRate", "_a", "stats", "MediaPluginsAnalyticsFactory", "error", "initFn", "__async", "HMSLogger", "time", "e", "err", "ErrorFactory", "preProcessFn", "processFn", "fn", "start", "DEFAULT_FRAME_RATE", "DEFAULT_WIDTH", "DEFAULT_HEIGHT", "HMSVideoPluginsManager", "track", "eventBus", "VideoPluginsAnalytics", "plugin", "pluginFrameRate", "__async", "_a", "name", "HMSLogger", "err", "ErrorFactory", "_b", "inputFrameRate", "numFramesToSkip", "i", "result", "error", "sleep", "contextType", "outputStream", "sleepTimeMs", "processingTime", "start", "skipProcessing", "process", "input", "output", "currentCanvas", "nextCanvas", "srcObject", "width", "height", "inputCtx", "skip", "generateHasPropertyChanged", "newSettings", "oldSettings", "prop", "HMSLocalVideoTrack", "_HMSLocalVideoTrack", "HMSVideoTrack", "stream", "track", "source", "eventBus", "settings", "HMSVideoTrackSettingsBuilder", "width", "height", "codec", "maxFramerate", "maxBitrate", "deviceId", "advanced", "facingMode", "__spreadValues", "HMSVideoTrackSettings", "__async", "hasPropertyChanged", "internal", "DeviceStorageManager", "processedTrack", "VideoElementManager", "HMSVideoPluginsManager", "definitions", "value", "_a", "__superGet", "trackId", "videoElement", "isEmptyTrack", "plugin", "pluginFrameRate", "cropTarget", "err", "HMSLogger", "ErrorFactory", "currentFacingMode", "prevTrack", "newTrack", "getVideoTrack", "LocalTrackManager", "enabled", "localStream", "HMSRemoteVideoTrack", "_HMSRemoteVideoTrack", "HMSVideoTrack", "stream", "track", "source", "TrackHistory", "VideoElementManager", "trackId", "value", "__async", "__superGet", "layer", "HMSLogger", "videoElement", "shouldSendVideoLayer", "isEmptyTrack", "definitions", "layerUpdate", "currentLayer", "newLayer", "action", "response", "error", "targetLayer", "currLayer", "HMSLocalStream", "HMSMediaStream", "connection", "track", "simulcastLayers", "transceiver", "__async", "_a", "_transceiver", "_kind", "withTrack", "HMSLogger", "stringifyMediaStreamTrack", "sender", "_b", "toRemoveLocalTrackIdx", "trackEncodings", "HMSLocalVideoTrack", "encodings", "isNode", "HMSRemoteStream", "HMSMediaStream", "nativeStream", "connection", "enabled", "trackId", "identifier", "__async", "HMSLogger", "layer", "source", "validateDeviceAV", "__async", "videoTrackSettings", "HMSVideoTrackSettingsBuilder", "audioTrackSettings", "HMSAudioTrackSettingsBuilder", "getAudioTrack", "audioError", "isHMSDeviceError", "getLocalStream", "track", "getVideoTrack", "error", "HMSException", "getLocalTrackStats", "eventBus", "track", "peerName", "prevTrackStats", "__async", "_a", "trackReport", "trackStats", "mimeTypes", "outbound", "inbound", "stat", "__spreadValues", "codecId", "mimeType", "codec", "out", "inStats", "__spreadProps", "computeBitrate", "err", "AnalyticsEventFactory", "ErrorFactory", "HMSLogger", "getTrackStats", "getRelevantStatsFromTrackReport", "bitrate", "packetsLostRate", "computeStatRate", "streamStats", "remoteStreamStats", "getLocalPeerStatsFromReport", "type", "report", "prevStats", "activeCandidatePair", "getActiveCandidatePairFromReport", "getPacketsLostAndJitterFromReport", "result", "union", "arr1", "arr2", "statName", "newReport", "oldReport", "newVal", "oldVal", "isPresent", "condition", "computeNumberRate", "newTimestamp", "oldTimestamp", "HMSWebrtcStats", "getStats", "store", "eventBus", "trackId", "__async", "_a", "_b", "_c", "_d", "_e", "_f", "prevLocalPeerStats", "publishReport", "err", "AnalyticsEventFactory", "ErrorFactory", "HMSLogger", "publishStats", "getLocalPeerStatsFromReport", "subscribeReport", "baseSubscribeStats", "packetsLost", "jitter", "getPacketsLostAndJitterFromReport", "packetsLostRate", "computeNumberRate", "subscribeStats", "tracks", "track", "HMSRemoteVideoTrack", "HMSRemoteAudioTrack", "trackIds", "peerName", "prevTrackStats", "trackStats", "getTrackStats", "res", "trackIDs", "union", "trackID", "getLocalTrackStats", "HMSWebrtcInternals", "store", "eventBus", "publishConnection", "subscribeConnection", "__async", "_a", "statsChangeCb", "publish", "subscribe", "_b", "HMSWebrtcStats", "HMSLogger", "AnalyticsEventFactory", "ErrorFactory", "sleep", "sdk_version", "HMSLogger", "adapter", "defaultSettings", "blankCanvas", "intervalID", "LocalTrackManager", "_LocalTrackManager", "store", "observer", "deviceManager", "eventBus", "analyticsTimer", "__async", "initialSettings", "trackSettings", "canPublishAudio", "canPublishVideo", "tracksToPublish", "videoTrack", "audioTrack", "localStream", "isVideoTrackPublished", "isAudioTrackPublished", "fetchTrackOptions", "HMSLogger", "error", "settings", "nativeTracks", "AnalyticsEventFactory", "HMSTrackSettings", "partialConfig", "_a", "config", "screenSettings", "constraints", "__spreadProps", "__spreadValues", "audioConstraints", "stream", "err", "BuildGetMediaError", "tracks", "local", "HMSLocalStream", "nativeVideoTrack", "HMSLocalVideoTrack", "isCurrentTabShared", "track", "nativeAudioTrack", "HMSLocalAudioTrack", "uuid", "forceCurrentTab", "trackHandle", "ErrorFactory", "prevTrack", "_b", "_c", "width", "height", "frameRate", "ctx", "emptyTrack", "HMSAudioContextHandler", "oscillator", "dst", "videoError", "audioError", "errorType", "audioSettings", "videoSettings", "HMSTrackSettingsBuilder", "HMSException", "overConstrainedFailure", "ErrorCodes", "audioFailure", "videoFailure", "newTrackSettings", "HMSVideoTrackSettings", "HMSAudioTrackSettings", "nativeError", "ex", "newError", "localTracks", "t", "screenVideoTrack", "publishParams", "localPeer", "audioDeviceId", "HMSAudioTrackSettingsBuilder", "videoDeviceId", "video", "HMSVideoTrackSettingsBuilder", "isVideoOnly", "screen", "NetworkTestManager", "eventBus", "listener", "networkHealth", "__async", "_a", "url", "timeout", "scoreMap", "signal", "startTime", "downloadedSize", "timeoutPromise", "sleep", "reader", "readData", "completed", "value", "done", "error", "HMSLogger", "AnalyticsEventFactory", "finished", "totalTimeInSecs", "bitrate", "calculatedScore", "score", "thresholds", "newQualityScore", "_b", "RoleChangeManager", "store", "transport", "deviceManager", "publish", "removeAuxiliaryTrack", "listener", "_0", "__async", "oldRole", "newRole", "_a", "localPeer", "_b", "_c", "_d", "_e", "_f", "_g", "wasPublishing", "isPublishing", "removeVideo", "removeAudio", "removeScreen", "videoHasSimulcastDifference", "screenHasSimulcastDifference", "prevVideoEnabled", "initialSettings", "track", "predicate", "localAuxTracks", "type", "oldLayers", "newLayers", "layer", "newLayer", "ClientAnalyticsTransport", "LocalStorage", "env", "ws", "event", "requestBody", "url", "CLIENT_ANAYLTICS_PROD_ENDPOINT", "CLIENT_ANAYLTICS_QA_ENDPOINT", "response", "error", "HMSLogger", "events", "existingEvents", "existingEvent", "index", "storageEvent", "HTTPAnalyticsTransport", "Store", "createUserAgent", "enabled", "peer", "role", "peerId", "track", "HMSRemoteVideoTrack", "tracks", "trackId", "_a", "_b", "localPeer", "speaker", "frameworkInfo", "room", "params", "publishParams", "config", "_c", "DeviceStorageManager", "devices", "trackStateEntry", "speakers", "value", "__async", "device", "promises", "HMSRemoteAudioTrack", "source", "simulcastLayers", "__spreadProps", "__spreadValues", "layer", "width", "height", "simulcastMapping", "resolution", "poll", "id", "listener", "ErrorFactory", "url", "env", "HTTPAnalyticsTransport", "WakeLockManager", "__async", "HMSLogger", "err", "error", "AnalyticsEventsService", "store", "transport", "event", "removedEvent", "HMSLogger", "HTTPAnalyticsTransport", "_a", "error", "_b", "_c", "_d", "room", "localPeer", "import_uuid", "INITIAL_STATE", "AudioSinkManager", "store", "deviceManager", "eventBus", "__spreadValues", "event", "__async", "_a", "track", "HMSLogger", "audioTrack", "isMobile", "sleep", "_0", "peer", "callListener", "_b", "audioEl", "ex", "ErrorFactory", "AnalyticsEventFactory", "resolve", "promises", "listener", "value", "elementId", "audioSink", "uuid", "err", "error", "DeviceManager", "store", "eventBus", "deviceId", "__async", "newDevice", "device", "DeviceStorageManager", "_a", "_b", "localPeer", "audioDevice", "videoDevice", "audioSelection", "videoSelection", "prevDevices", "currentDevices", "devices", "prevVideoInput", "prevAudioInput", "error", "HMSLogger", "debounce", "AnalyticsEventFactory", "audioTrack", "newSelection", "settings", "newAudioTrackSettings", "HMSAudioTrackSettingsBuilder", "videoTrack", "newVideoTrackSettings", "HMSVideoTrackSettingsBuilder", "isLocalTrackEnabled", "enabled", "track", "force", "deviceInfo", "defaultDevice", "deviceChange", "inputDevice", "prevSelection", "blacklist", "inputLabel", "label", "AudioOutputManager", "deviceManager", "audioSinkManager", "value", "deviceId", "__async", "HMSAudioContextHandler", "import_eventemitter2", "HMSInternalEvent", "eventName", "eventEmitter", "event", "fn", "predicate", "EventBus", "EventEmitter", "HMSInternalEvent", "HMSEvents", "TrackState", "track", "HMSTrack", "ActiveSpeakerManager", "store", "listener", "audioListener", "speakerList", "_a", "_b", "_c", "speakers", "hmsSpeakers", "speaker", "dominantSpeaker", "dominantSpeakerPeer", "BroadcastManager", "store", "listener", "method", "notification", "messageNotification", "_a", "notifPeer", "notifMessage", "notifRoles", "sender", "recipientPeer", "recipientRoles", "knownRoles", "role", "hmsMessage", "Message", "__spreadProps", "__spreadValues", "HMSLogger", "HMSPeer", "ConnectionQualityManager", "store", "listener", "qualityList", "_a", "hmsPeers", "peer", "storePeer", "TrackManager", "store", "eventBus", "listener", "track", "HMSLogger", "notification", "trackId", "_a", "trackStateEntry", "hmsPeer", "params", "trackEntry", "HMSRemoteVideoTrack", "callListener", "_b", "notifPeer", "HMSPeer", "currentTrackStateInfo", "__spreadValues", "eventType", "_trackInfo", "_peerId", "_callListener", "state", "trackInfo", "remove", "layerUpdate", "peer", "auxiliaryTrackIndex", "remoteTrack", "simulcastDefinitions", "index", "currentTrackState", "trackState", "OnDemandTrackManager", "TrackManager", "store", "eventBus", "transport", "listener", "trackInfo", "peerId", "callListener", "_a", "hmsPeer", "HMSLogger", "remoteStream", "HMSRemoteStream", "emptyTrack", "LocalTrackManager", "track", "HMSRemoteVideoTrack", "params", "trackId", "isRegularVideo", "isEmptyTrack", "_b", "_c", "_d", "localPeer", "peer", "PeerListManager", "store", "peerManager", "trackManager", "listener", "peerList", "peers", "roomState", "roomPeers", "peer", "peersMap", "currentPeerList", "peersToRemove", "hmsPeer", "HMSLogger", "_a", "peerNotification", "newPeerNotification", "oldPeer", "newPeerTrackStates", "track", "trackData", "method", "notification", "isReconnecting", "trackId", "_b", "trackIndex", "convertDateNumToDate", "dateNum", "PeerManager", "store", "trackManager", "listener", "peers", "_a", "_b", "hmsPeers", "newPeers", "peer", "peerId", "fromRoomState", "hmsPeer", "_c", "_d", "HMSLogger", "track", "method", "notification", "_e", "newRole", "wasHandRaised", "isHandRaised", "HAND_RAISE_GROUP_NAME", "__spreadValues", "name", "data", "HMSRemotePeer", "convertDateNumToDate", "trackId", "trackInfo", "remoteTrack", "simulcastDefinitions", "PolicyChangeManager", "store", "eventBus", "params", "localPeer", "newRole", "room", "HMSLogger", "_a", "oldRole", "PollsManager", "store", "transport", "listener", "method", "notification", "__async", "_a", "polls", "pollParams", "questions", "poll", "convertDateNumToDate", "question", "options", "answer", "__spreadProps", "__spreadValues", "stoppedPolls", "savedPoll", "pollResult", "_b", "updatedPolls", "updatedPoll", "response", "peer", "final", "pollResponse", "id", "updatedQuestion", "savedQuestion", "updatedVoteCount", "index", "savedOption", "RequestManager", "store", "listener", "method", "notification", "_a", "request", "trackUpdateRequest", "requested_by", "track_id", "mute", "peer", "track", "sendNotification", "type", "source", "value", "enabled", "tracksToBeUpdated", "promises", "tracks", "RoomUpdateManager", "store", "listener", "method", "notification", "room", "HMSLogger", "_a", "roomNotification", "peerCount", "_b", "_c", "recording", "streaming", "session_id", "started_at", "name", "convertDateNumToDate", "hlsNotification", "hls", "variant", "hlsRecording", "running", "action", "error", "errMsg", "sdkError", "HMSException", "SessionMetadataManager", "store", "listener", "method", "notification", "_a", "updates", "update", "convertDateNumToDate", "NotificationManager", "store", "eventBus", "transport", "listener", "audioListener", "connectionQualityListener", "method", "track", "name", "metadata", "peer", "isOnDemandTracksEnabled", "OnDemandTrackManager", "TrackManager", "PeerManager", "PeerListManager", "BroadcastManager", "PolicyChangeManager", "RequestManager", "ActiveSpeakerManager", "ConnectionQualityManager", "RoomUpdateManager", "SessionMetadataManager", "PollsManager", "qualityListener", "message", "isReconnecting", "_a", "_b", "notification", "HMSLogger", "AudioContextManager", "element", "__async", "HMSLogger", "import_eventemitter2", "TypedEventEmitter", "EventEmitter", "eventName", "fn", "params", "PlaylistAudioManager", "TypedEventEmitter", "url", "__async", "resolve", "reject", "error", "HMSLogger", "audioTrack", "err", "_a", "_b", "_c", "audioElement", "event", "AudioContextManager", "PlaylistVideoManager", "TypedEventEmitter", "_a", "_b", "_c", "url", "resolve", "reject", "error", "HMSLogger", "__async", "stream", "audioTrack", "track", "err", "videoElement", "event", "AudioContextManager", "INITIAL_STATE", "PlaylistManager", "TypedEventEmitter", "sdk", "eventBus", "__spreadValues", "_0", "__async", "enabled", "track", "_a", "type", "source", "HMSLogger", "stringifyMediaStreamTrack", "trackId", "PlaylistAudioManager", "PlaylistVideoManager", "list", "item", "_item", "id", "currentIndex", "index", "playItem", "value", "ErrorFactory", "element", "updatedValue", "activeUrl", "autoplay", "_1", "url", "manager", "fn", "error", "tracks", "el", "isAutoplayOn", "SessionStore", "transport", "key", "__async", "data", "updated_at", "convertDateNumToDate", "value", "updatedAt", "keys", "prevObservedKeys", "e", "InteractivityCenter", "transport", "store", "listener", "pollParams", "__async", "_a", "_b", "serverPollID", "__spreadProps", "__spreadValues", "questions", "poll", "question", "options", "answer", "pollID", "index", "responses", "responsesParams", "response", "pollsList", "polls", "convertDateNumToDate", "_pollID", "questionParams", "option", "val", "questionIndex", "JoinParameters", "authToken", "peerId", "peerName", "data", "endpoint", "autoSubscribeVideo", "TransportFailureCategory", "Dependencies", "TransportState", "PromiseWithCallbacks", "cb", "resolve", "reject", "RetryScheduler", "onStateChange", "sendEvent", "_0", "__async", "category", "error", "task", "originalState", "maxFailedRetries", "changeState", "future", "failedRetryCount", "HMSLogger", "TransportFailureCategory", "inProgressTask", "taskPromise", "PromiseWithCallbacks", "_", "__", "hasFailedDependency", "dependencies", "Dependencies", "dependencyIndexString", "dependency", "dependencyTask", "ex", "dep", "delay", "taskSucceeded", "n", "jitter", "resolve", "reject", "timeoutId", "value", "PublishStatsAnalytics", "store", "eventBus", "sampleWindowSize", "pushInterval", "AnalyticsEventFactory", "hmsStats", "localTracksStats", "trackIDBeingSent", "trackStats", "track", "statId", "_a", "_b", "_c", "_d", "_e", "layerStats", "identifier", "__spreadProps", "__spreadValues", "trackAnalytics", "RunningTrackAnalytics", "HMSLogger", "__async", "sleep", "audio", "video", "trackAnalytic", "trackId", "stats", "ssrc", "rid", "kind", "stat", "latestStat", "qualityLimitationDurations", "total_quality_limitation", "resolution", "avg_jitter", "avg_jitter_ms", "avg_round_trip_time", "avg_round_trip_time_ms", "removeUndefinedFromObject", "length", "newStat", "prevStat", "hasEnabledStateChanged", "hasResolutionChanged", "key", "partialSum", "round", "sum", "avg", "firstValue", "data", "value", "obj", "LocalStorageEvents", "Queue", "LocalStorage", "event", "removedEvent", "_a", "eventInstance", "AnalyticsEvent", "AnalyticsTransport", "event", "error", "HMSLogger", "currentPeerId", "_a", "HTTPAnalyticsTransport", "SignalAnalyticsTransport", "AnalyticsTransport", "transportProvider", "LocalStorageEvents", "HMSConnectionRole", "sdpTransform", "fixMsid", "desc", "tracks", "_a", "parsedSdp", "mediaTracks", "m", "_b", "_c", "streamId", "trackId", "val", "getSdpTrackIdForMid", "mid", "trackSection", "media", "isPresent", "enableOpusDtx", "TAG", "HMSConnection", "role", "signal", "track", "init", "tracks", "options", "__async", "offer", "HMSLogger", "enableOpusDtx", "fixMsid", "error", "ErrorFactory", "answer", "description", "candidate", "transmitter", "_a", "kindOfTrack", "iceTransport", "logSelectedCandidate", "HMSConnectionRole", "sender", "maxBitrate", "maxFramerate", "HMSLocalVideoTrack", "params", "HMSPublishConnection", "HMSConnection", "signal", "config", "observer", "API_DATA_CHANNEL", "candidate", "__async", "HMSLogger", "import_eventemitter2", "import_uuid", "HMSDataChannel", "nativeChannel", "observer", "metadata", "e", "message", "HMSLogger", "HMSSubscribeConnection", "_HMSSubscribeConnection", "HMSConnection", "signal", "config", "isFlagEnabled", "observer", "EventEmitter", "HMSLogger", "msg", "request", "requestId", "__async", "_a", "response", "i", "error", "delay", "sleep", "res", "value", "e", "API_DATA_CHANNEL", "HMSDataChannel", "stream", "streamId", "remote", "HMSRemoteStream", "ev", "toRemoveTrackIdx", "track", "toRemoveTrack", "TrackCls", "HMSRemoteAudioTrack", "HMSRemoteVideoTrack", "trackId", "getSdpTrackIdForMid", "message", "id", "uuid", "__spreadValues", "__superGet", "TAG", "InitService", "response", "body", "ErrorFactory", "_0", "__async", "token", "peerId", "userAgent", "initEndpoint", "region", "HMSLogger", "url", "getUrl", "config", "transformInitConfig", "err", "text", "error", "message", "endpoint", "_a", "__spreadProps", "__spreadValues", "import_uuid", "JsonRpcSignal", "observer", "Queue", "callback", "key", "_a", "HMSLogger", "newValue", "reason", "method", "params", "__async", "id", "uuid", "message", "resolve", "reject", "ex", "HMSException", "error", "ErrorFactory", "convertSignalMethodtoErrorAction", "_b", "uri", "promiseSettled", "errorListener", "event", "openHandler", "name", "data", "disableVidAutoSub", "serverSubDegrade", "simulcast", "onDemandTracks", "offer", "response", "target", "candidate", "desc", "tracks", "lock", "timeout", "pingTime", "timer", "pongTimeDiff", "__spreadValues", "peerId", "keys", "text", "typedResponse", "cb", "_c", "_d", "pingTimeout", "isPageHidden", "retry", "err", "delay", "sleep", "getNetworkInfo", "isBrowser", "connection", "TAG", "HMSTransport", "observer", "deviceManager", "store", "eventBus", "analyticsEventsService", "analyticsTimer", "jsep", "__async", "HMSLogger", "candidate", "answer", "err", "ex", "HMSException", "ErrorFactory", "AnalyticsEventFactory", "trickle", "connection", "message", "error", "reason", "TransportState", "e", "_a", "JsonRpcSignal", "SignalAnalyticsTransport", "newState", "_b", "_c", "_d", "_e", "track", "callback", "SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID", "_0", "oldRole", "newRole", "p", "resolve", "reject", "RENEGOTIATION_CALLBACK_ID", "timeout", "ok", "HMSWebrtcInternals", "onStateChange", "state", "RetryScheduler", "stats", "currentSubscribeBitrate", "flag", "config", "token", "endpoint", "peerId", "customData", "autoSubscribeVideo", "initConfig", "authToken", "initEndpoint", "JoinParameters", "ErrorCodes", "task", "notifyServer", "tracks", "originalTrackState", "trackState", "newTrackState", "TrackState", "__spreadProps", "__spreadValues", "forPeer", "toRole", "force", "roles", "role", "request", "lock", "params", "signalParams", "hlsParams", "variant", "hlsVariant", "metadataList", "hlsMtParams", "name", "peer", "metadata", "key", "keys", "trackUpdateRequest", "stream", "simulcastLayers", "HMSLocalVideoTrack", "isWebRTC", "HMSPublishConnection", "HMSSubscribeConnection", "data", "hmsError", "shouldRetry", "offer", "serverSubDegrade", "simulcast", "onDemandTracks", "constraints", "connectRequestedAt", "InitService", "HTTPAnalyticsTransport", "stage", "url", "PROTOCOL_VERSION", "PROTOCOL_SPEC", "_f", "_g", "_h", "PublishStatsAnalytics", "isPublishing", "isSubscribing", "localRole", "category", "additionalProps", "event", "network_info", "getNetworkInfo", "document_hidden", "num_degraded_tracks", "publishBitrate", "subscribeBitrate", "fetchWithRetry", "url", "options", "retryCodes", "__async", "error", "i", "response", "data", "ErrorFactory", "err", "message", "decodeJWT", "token", "ErrorFactory", "parts", "payloadStr", "payload", "err", "INITIAL_STATE", "HMSSdk", "AnalyticsTimer", "__spreadValues", "error", "_a", "_b", "message", "track", "exception", "state", "__async", "handleFailedState", "HMSLogger", "peer", "request", "event", "_c", "_d", "_e", "_f", "ErrorCodes", "_0", "oldRole", "newRole", "ErrorFactory", "is_preview_called", "AnalyticsEventFactory", "__spreadProps", "NotificationManager", "Store", "EventBus", "WakeLockManager", "NetworkTestManager", "PlaylistManager", "DeviceManager", "AudioSinkManager", "AudioOutputManager", "LocalTrackManager", "AnalyticsEventsService", "HMSTransport", "SessionStore", "InteractivityCenter", "name", "config", "listener", "validateMediaDevicesExistence", "validateRTCPeerConnection", "initSuccessful", "networkTestFinished", "timerId", "resolve", "reject", "policyHandler", "tracks", "room", "errorHandler", "ex", "initConfig", "asRole", "settings", "roomId", "userId", "role", "decodeJWT", "previewRole", "HMSAudioContextHandler", "storeConfig", "RoleChangeManager", "DeviceStorageManager", "notifyServer", "tokenRequest", "tokenRequestOptions", "tokenAPIURL", "response", "fetchWithRetry", "data", "token", "type", "roles", "knownRoles", "recipientRoles", "recipientPeer", "hmsMessage", "Message", "onStop", "publishParams", "allowed", "screenTracks", "t", "source", "nativeStream", "stream", "HMSLocalStream", "TrackKlass", "HMSLocalAudioTrack", "HMSLocalVideoTrack", "hmsTrack", "trackId", "internal", "trackIndex", "level", "audioListener", "qualityListener", "forPeer", "toRole", "force", "lock", "reason", "params", "metadataList", "metadata", "forRemoteTrack", "enabled", "HAND_RAISE_GROUP_NAME", "peerId", "frameworkInfo", "videoElement", "initialSettings", "isNode", "value", "publishAction", "localAudioTrack", "audioLevelUpdate", "hmsSpeakers", "localPeer", "width", "height", "policy", "asRolePolicy", "HMSLocalPeer", "Room", "videoTrack", "audioTrack", "handleEnded"]
}
