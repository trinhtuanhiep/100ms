import { HMSVideoPlugin } from './HMSVideoPlugin';
import { EventBus } from '../../events/EventBus';
import { HMSLocalVideoTrack } from '../../media/tracks';
/**
 * This class manages applying different plugins on a local video track. Plugins which need to modify the video
 * are called in the order they were added. Plugins which do not need to modify the video frames are called
 * with the original input.
 *
 * Concepts -
 * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally
 * render its output on a passed in output canvas which will be shown in the UI.
 *
 * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames
 * are being produced and the rate we need to maintain in output as well.
 *
 * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an
 * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the
 * real frame rate.
 *
 * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added
 * plugins are called one by one in the order they were called.
 *
 * @see HMSVideoPlugin
 */
export declare class HMSVideoPluginsManager {
    private readonly TAG;
    /**
     * plugins loop is the loop in which all plugins are applied
     */
    private pluginsLoopRunning;
    private pluginsLoopState;
    private readonly hmsTrack;
    private readonly pluginsMap;
    private inputVideo?;
    private inputCanvas?;
    private outputCanvas?;
    private outputTrack?;
    private analytics;
    private pluginAddInProgress;
    private pluginNumFramesToSkip;
    private pluginNumFramesSkipped;
    private canvases;
    constructor(track: HMSLocalVideoTrack, eventBus: EventBus);
    getPlugins(): string[];
    /**
     * @param plugin
     * @param pluginFrameRate
     */
    addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void>;
    private addPluginInternal;
    validatePlugin(plugin: HMSVideoPlugin): import("../audio").HMSPluginSupportResult;
    validateAndThrow(name: string, plugin: HMSVideoPlugin): void;
    removePlugin(plugin: HMSVideoPlugin): Promise<void>;
    removePluginEntry(name: string): void;
    /**
     * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be
     * produced. It can await on this function to confirm and tell the new unmuted state.
     * If this is not awaited on video will freeze with a frame from past run.
     */
    waitForRestart(): Promise<void>;
    /**
     * remove every plugin one by one
     */
    cleanup(): Promise<void>;
    private initElementsAndStream;
    private startPluginsLoop;
    private stopPluginsLoop;
    private pluginsLoop;
    private doPreProcessing;
    /**
     * pass the input canvas through all plugins in a loop
     * @private
     */
    private processFramesThroughPlugins;
    /**
     * add the current native track to the inputVideoElement if it's not already added.
     * @private
     */
    private addTrackToVideo;
    /**
     * get the new video frame from input video element and put it on canvas
     * @private
     */
    private updateInputCanvas;
    private resetCanvases;
    /**
      N = ceil(inputFrameRate/pluginFrameRate) - 1
      N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame
      all the frames we are skipping are using the previous frame output
     **/
    private checkIfSkipRequired;
}
