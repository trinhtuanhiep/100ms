import ITransport from './ITransport';
import ITransportObserver from './ITransportObserver';
import { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';
import { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';
import { AnalyticsTimer } from '../analytics/AnalyticsTimer';
import HMSSubscribeConnection from '../connection/subscribe/subscribeConnection';
import { DeviceManager } from '../device-manager';
import { EventBus } from '../events/EventBus';
import { HLSConfig, HLSTimedMetadata, HMSPeer, HMSRole, HMSRoleChangeRequest } from '../interfaces';
import { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';
import { HMSLocalTrack } from '../media/tracks';
import { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';
import Message from '../sdk/models/HMSMessage';
import { IStore } from '../sdk/store';
import { InitConfig, InitFlags } from '../signal/init/models';
import { JoinLeaveGroupResponse, MultiTrackUpdateRequestParams, PollInfoGetParams, PollInfoGetResponse, PollInfoSetParams, PollInfoSetResponse, PollListParams, PollListResponse, PollQuestionsGetParams, PollQuestionsGetResponse, PollQuestionsSetParams, PollQuestionsSetResponse, PollResponseSetParams, PollResponseSetResponse, PollResponsesGetParams, PollResponsesGetResponse, PollResultParams, PollResultResponse, PollStartParams, PollStartResponse, PollStopParams, SetSessionMetadataParams, TrackUpdateRequestParams } from '../signal/interfaces';
export default class HMSTransport implements ITransport {
    private observer;
    private deviceManager;
    private store;
    private eventBus;
    private analyticsEventsService;
    private analyticsTimer;
    private state;
    private trackStates;
    private publishConnection;
    private subscribeConnection;
    private initConfig?;
    private endpoint;
    private joinParameters?;
    private retryScheduler;
    private webrtcInternals?;
    private publishStatsAnalytics?;
    private maxSubscribeBitrate;
    joinRetryCount: number;
    constructor(observer: ITransportObserver, deviceManager: DeviceManager, store: IStore, eventBus: EventBus, analyticsEventsService: AnalyticsEventsService, analyticsTimer: AnalyticsTimer);
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */
    private readonly callbacks;
    private signalObserver;
    private signal;
    private analyticsSignalTransport;
    private publishConnectionObserver;
    private subscribeConnectionObserver;
    getWebrtcInternals(): HMSWebrtcInternals | undefined;
    isFlagEnabled(flag: InitFlags): boolean;
    preview(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    join(authToken: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, initEndpoint: string, autoSubscribeVideo?: boolean): Promise<void>;
    connect(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean): Promise<InitConfig | void>;
    leave(notifyServer: boolean): Promise<void>;
    handleLocalRoleUpdate: ({ oldRole, newRole }: {
        oldRole: HMSRole;
        newRole: HMSRole;
    }) => Promise<void>;
    publish(tracks: Array<HMSLocalTrack>): Promise<void>;
    unpublish(tracks: Array<HMSLocalTrack>): Promise<void>;
    sendMessage(message: Message): Promise<import("../signal/interfaces").BroadcastResponse>;
    /**
     * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
     * source. The hack won't work if there are multiple tracks with same source and type.
     */
    trackUpdate(track: HMSLocalTrack): void;
    changeRole(forPeer: HMSPeer, toRole: string, force?: boolean): Promise<void>;
    changeRoleOfPeer(forPeer: HMSPeer, toRole: string, force: boolean): Promise<void>;
    changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string): Promise<void>;
    acceptRoleChange(request: HMSRoleChangeRequest): Promise<void>;
    endRoom(lock: boolean, reason: string): Promise<void>;
    removePeer(peerId: string, reason: string): Promise<void>;
    startRTMPOrRecording(params: RTMPRecordingConfig): Promise<void>;
    stopRTMPOrRecording(): Promise<void>;
    startHLSStreaming(params?: HLSConfig): Promise<void>;
    stopHLSStreaming(params?: HLSConfig): Promise<void>;
    sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]): Promise<void>;
    changeName(name: string): Promise<void>;
    changeMetadata(metadata: string): Promise<void>;
    getSessionMetadata(key?: string): Promise<import("../signal/interfaces").GetSessionMetadataResponse>;
    setSessionMetadata(params: SetSessionMetadataParams): Promise<import("../signal/interfaces").SetSessionMetadataResponse>;
    listenMetadataChange(keys: string[]): Promise<void>;
    setPollInfo(params: PollInfoSetParams): Promise<PollInfoSetResponse>;
    getPollInfo(params: PollInfoGetParams): Promise<PollInfoGetResponse>;
    setPollQuestions(params: PollQuestionsSetParams): Promise<PollQuestionsSetResponse>;
    getPollQuestions(params: PollQuestionsGetParams): Promise<PollQuestionsGetResponse>;
    startPoll(params: PollStartParams): Promise<PollStartResponse>;
    stopPoll(params: PollStopParams): Promise<PollStartResponse>;
    setPollResponses(params: PollResponseSetParams): Promise<PollResponseSetResponse>;
    getPollResponses(params: PollResponsesGetParams): Promise<PollResponsesGetResponse>;
    getPollsList(params: PollListParams): Promise<PollListResponse>;
    getPollResult(params: PollResultParams): Promise<PollResultResponse>;
    joinGroup(name: string): Promise<JoinLeaveGroupResponse>;
    leaveGroup(name: string): Promise<JoinLeaveGroupResponse>;
    addToGroup(peerId: string, name: string): Promise<void>;
    removeFromGroup(peerId: string, name: string): Promise<void>;
    changeTrackState(trackUpdateRequest: TrackUpdateRequestParams): Promise<void>;
    changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams): Promise<void>;
    private publishTrack;
    private unpublishTrack;
    private waitForLocalRoleAvailability;
    private createConnectionsAndNegotiateJoin;
    private createPeerConnections;
    private negotiateJoinWithRetry;
    private negotiateJoin;
    private negotiateJoinWebRTC;
    private negotiateJoinNonWebRTC;
    /**
     * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer
     */
    private negotiateOnFirstPublish;
    private performPublishRenegotiation;
    private handleIceConnectionFailure;
    private internalConnect;
    private validateNotDisconnected;
    private openSignal;
    private initRtcStatsMonitor;
    /**
     * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything
     * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role
     */
    private doesRoleNeedWebRTC;
    private doesLocalPeerNeedWebRTC;
    private retryPublishIceFailedTask;
    private retrySubscribeIceFailedTask;
    private retrySignalDisconnectTask;
    private handleSubscribeConnectionConnected;
    private setTransportStateForConnect;
    private sendErrorAnalyticsEvent;
    getSubscribeConnection(): HMSSubscribeConnection | null;
    getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties;
}
