import { HMSVideoTrack } from './HMSVideoTrack';
import { EventBus } from '../../events/EventBus';
import { HMSSimulcastLayerDefinition, HMSVideoTrackSettings as IHMSVideoTrackSettings, ScreenCaptureHandle } from '../../interfaces';
import { HMSPluginSupportResult, HMSVideoPlugin } from '../../plugins';
import { HMSVideoTrackSettings } from '../settings';
import { HMSLocalStream } from '../streams';
export declare class HMSLocalVideoTrack extends HMSVideoTrack {
    private eventBus;
    settings: HMSVideoTrackSettings;
    private pluginsManager;
    private processedTrack?;
    private _layerDefinitions;
    private TAG;
    /**
     * true if it's screenshare and current tab is what is being shared. Browser dependent, Chromium only
     * at the point of writing this comment.
     */
    isCurrentTab: boolean;
    /**
     * @internal
     * This is required for handling remote mute/unmute as the published track will not necessarily be same as
     * the first track id or current native track's id.
     * It won't be same as first track id if the native track was changed after preview started but before join happened,
     * with device change, or mute/unmute.
     * It won't be same as native track id, as the native track can change post join(and publish), when the nativetrack
     * changes, replacetrack is used which doesn't involve republishing which means from server's point of view, the track id
     * is same as what was initially published.
     * This will only be available if the track was actually published and won't be set for preview tracks.
     */
    publishedTrackId?: string;
    /**
     * will be false for preview tracks
     */
    isPublished: boolean;
    constructor(stream: HMSLocalStream, track: MediaStreamTrack, source: string, eventBus: EventBus, settings?: HMSVideoTrackSettings);
    /** @internal */
    setSimulcastDefinitons(definitions: HMSSimulcastLayerDefinition[]): void;
    /**
     * Method to get available simulcast definitions for the track
     * @returns {HMSSimulcastLayerDefinition[]}
     */
    getSimulcastDefinitions(): HMSSimulcastLayerDefinition[];
    /**
     * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.
     * @param value
     */
    setEnabled(value: boolean): Promise<void>;
    /**
     * verify if the track id being passed is of this track for correlating server messages like degradation
     */
    isPublishedTrackId(trackId: string): boolean;
    /**
     * @see HMSVideoTrack#addSink()
     */
    addSink(videoElement: HTMLVideoElement): void;
    /**
     * This function can be used to set media track settings. Frequent options -
     * deviceID: can be used to change to different input source
     * width, height - can be used to change capture dimensions
     * maxFramerate - can be used to control the capture framerate
     * @param settings
     */
    setSettings(settings: Partial<IHMSVideoTrackSettings>, internal?: boolean): Promise<void>;
    /**
     * @see HMSVideoPlugin
     */
    getPlugins(): string[];
    /**
     * @see HMSVideoPlugin
     */
    addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void>;
    /**
     * @see HMSVideoPlugin
     */
    removePlugin(plugin: HMSVideoPlugin): Promise<void>;
    /**
     * @see HMSVideoPlugin
     */
    validatePlugin(plugin: HMSVideoPlugin): HMSPluginSupportResult;
    /**
     * @internal
     */
    cleanup(): Promise<void>;
    /**
     * only for screenshare track to crop to a cropTarget
     * @internal
     */
    cropTo(cropTarget?: object): Promise<void>;
    /**
     * only for screenshare track to get the captureHandle
     * TODO: add an API for capturehandlechange event
     * @internal
     */
    getCaptureHandle(): ScreenCaptureHandle | undefined;
    /**
     * once the plugin manager has done its processing it can set or remove processed track via this method
     * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is
     * no point in replacing it. We'll update the processed track variable though so next time unmute happens
     * it's set properly.
     * @internal
     */
    setProcessedTrack(processedTrack?: MediaStreamTrack): Promise<void>;
    /**
     * @internal
     * sent track id will be different in case there was some processing done using plugins.
     * replace track is used to, start sending data from a new track without un publishing the prior one. There
     * are thus two track ids - the one which was initially published and should be unpublished when required.
     * The one whose data is currently being sent, which will be used when removing from connection senders.
     */
    getTrackIDBeingSent(): string;
    getTrackBeingSent(): MediaStreamTrack;
    /**
     * will change the facingMode to environment if current facing mode is user or vice versa.
     * will be useful when on mobile web to toggle between front and back camera's
     */
    switchCamera(): Promise<void>;
    /**
     * called when the video is unmuted
     * @private
     */
    private replaceTrackWith;
    /**
     * called when the video is muted. A blank track is used to replace the original track. This is in order to
     * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.
     * @private
     */
    private replaceTrackWithBlank;
    private replaceSender;
    private buildNewSettings;
    private handleSettingsChange;
    /**
     * Replace video track with new track on device change
     * @param settings - VideoSettings Object constructed with new settings
     * @param internal - whether the change was because of internal sdk call or external client call
     */
    private handleDeviceChange;
    /**
     * This will either remove or update the processedTrack value on the class instance.
     * It will also replace sender if the processedTrack is updated
     * @param {MediaStreamTrack|undefined}processedTrack
     */
    private removeOrReplaceProcessedTrack;
}
